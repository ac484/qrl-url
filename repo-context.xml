This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
main.py
src/__init__.py
src/app/__init__.py
src/app/application/__init__.py
src/app/application/account/__init__.py
src/app/application/account/use_cases/__init__.py
src/app/application/account/use_cases/get_balance.py
src/app/application/exchange/mexc_service.py
src/app/application/market/__init__.py
src/app/application/market/mappers/__init__.py
src/app/application/market/mappers/mexc.py
src/app/application/market/qrl/__init__.py
src/app/application/market/qrl/get_qrl_depth.py
src/app/application/market/qrl/get_qrl_kline.py
src/app/application/market/qrl/get_qrl_price.py
src/app/application/market/use_cases/__init__.py
src/app/application/market/use_cases/get_depth.py
src/app/application/market/use_cases/get_kline.py
src/app/application/market/use_cases/get_market_trades.py
src/app/application/market/use_cases/get_stats24h.py
src/app/application/market/use_cases/get_ticker.py
src/app/application/ports/__init__.py
src/app/application/ports/exchange_gateway.py
src/app/application/system/__init__.py
src/app/application/system/use_cases/__init__.py
src/app/application/system/use_cases/allocation.py
src/app/application/system/use_cases/get_server_time.py
src/app/application/system/use_cases/ping.py
src/app/application/trading/__init__.py
src/app/application/trading/dto/__init__.py
src/app/application/trading/dtos.py
src/app/application/trading/mappers/__init__.py
src/app/application/trading/mappers/mexc.py
src/app/application/trading/qrl/__init__.py
src/app/application/trading/qrl/cancel_qrl_order.py
src/app/application/trading/qrl/get_qrl_order.py
src/app/application/trading/qrl/guards/__init__.py
src/app/application/trading/qrl/guards/qrl_balance_guard.py
src/app/application/trading/qrl/guards/qrl_duplicate_guard.py
src/app/application/trading/qrl/guards/qrl_price_guard.py
src/app/application/trading/qrl/guards/qrl_rate_limit_guard.py
src/app/application/trading/qrl/place_qrl_order.py
src/app/application/trading/use_cases/__init__.py
src/app/application/trading/use_cases/cancel_order.py
src/app/application/trading/use_cases/get_kline.py
src/app/application/trading/use_cases/get_order.py
src/app/application/trading/use_cases/get_price.py
src/app/application/trading/use_cases/list_orders.py
src/app/application/trading/use_cases/list_trades.py
src/app/application/trading/use_cases/place_order.py
src/app/domain/__init__.py
src/app/domain/aggregates/__init__.py
src/app/domain/aggregates/account_state.py
src/app/domain/aggregates/market_snapshot.py
src/app/domain/aggregates/trading_session.py
src/app/domain/entities/__init__.py
src/app/domain/entities/account.py
src/app/domain/entities/kline.py
src/app/domain/entities/order_book_level.py
src/app/domain/entities/order.py
src/app/domain/entities/trade.py
src/app/domain/entities/trading_pair.py
src/app/domain/events/__init__.py
src/app/domain/events/balance_event.py
src/app/domain/events/market_depth_event.py
src/app/domain/events/order_event.py
src/app/domain/events/trade_event.py
src/app/domain/factories/aggregates.py
src/app/domain/services/__init__.py
src/app/domain/services/balance_comparison_rule.py
src/app/domain/services/depth_calculator.py
src/app/domain/services/slippage_analyzer.py
src/app/domain/services/valuation_service.py
src/app/domain/value_objects/__init__.py
src/app/domain/value_objects/api_key.py
src/app/domain/value_objects/api_secret.py
src/app/domain/value_objects/balance_comparison_result.py
src/app/domain/value_objects/balance.py
src/app/domain/value_objects/client_order_id.py
src/app/domain/value_objects/kline_interval.py
src/app/domain/value_objects/kline.py
src/app/domain/value_objects/normalized_balances.py
src/app/domain/value_objects/order_book.py
src/app/domain/value_objects/order_command.py
src/app/domain/value_objects/order_id.py
src/app/domain/value_objects/order_side.py
src/app/domain/value_objects/order_status.py
src/app/domain/value_objects/order_type.py
src/app/domain/value_objects/price.py
src/app/domain/value_objects/qrl_price.py
src/app/domain/value_objects/qrl_quantity.py
src/app/domain/value_objects/qrl_usdt_pair.py
src/app/domain/value_objects/quantity.py
src/app/domain/value_objects/side.py
src/app/domain/value_objects/slippage.py
src/app/domain/value_objects/sub_account_id.py
src/app/domain/value_objects/symbol.py
src/app/domain/value_objects/ticker.py
src/app/domain/value_objects/time_in_force.py
src/app/domain/value_objects/timestamp.py
src/app/domain/value_objects/trade_id.py
src/app/infrastructure/__init__.py
src/app/infrastructure/config.py
src/app/infrastructure/exchange/__init__.py
src/app/infrastructure/exchange/mexc_api_client.py
src/app/infrastructure/exchange/mexc/__init__.py
src/app/infrastructure/exchange/mexc/adapters/__init__.py
src/app/infrastructure/exchange/mexc/adapters/balance_mapper.py
src/app/infrastructure/exchange/mexc/adapters/depth_mapper.py
src/app/infrastructure/exchange/mexc/adapters/market_event_adapter.py
src/app/infrastructure/exchange/mexc/adapters/order_mapper.py
src/app/infrastructure/exchange/mexc/adapters/trade_mapper.py
src/app/infrastructure/exchange/mexc/factories.py
src/app/infrastructure/exchange/mexc/generated/__init__.py
src/app/infrastructure/exchange/mexc/generated/PrivateAccountV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PrivateDealsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PrivateOrdersV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicAggreBookTickerV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicAggreDealsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicAggreDepthsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicBookTickerBatchV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicBookTickerV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicDealsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicIncreaseDepthsBatchV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicIncreaseDepthsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicLimitDepthsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicMiniTickersV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicMiniTickerV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicSpotKlineV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PushDataV3ApiWrapper_pb2.py
src/app/infrastructure/exchange/mexc/mappers.py
src/app/infrastructure/exchange/mexc/proto/__init__.py
src/app/infrastructure/exchange/mexc/qrl/__init__.py
src/app/infrastructure/exchange/mexc/qrl/qrl_rest_client.py
src/app/infrastructure/exchange/mexc/qrl/qrl_settings.py
src/app/infrastructure/exchange/mexc/rest_client.py
src/app/infrastructure/exchange/mexc/settings.py
src/app/infrastructure/exchange/mexc/ws_client.py
src/app/infrastructure/exchange/mexc/ws/__init__.py
src/app/infrastructure/exchange/mexc/ws/mexc_ws_client.py
src/app/infrastructure/external/mexc/__init__.py
src/app/interfaces/__init__.py
src/app/interfaces/http/__init__.py
src/app/interfaces/http/api/__init__.py
src/app/interfaces/http/api/account_routes.py
src/app/interfaces/http/api/market_routes.py
src/app/interfaces/http/api/qrl_routes.py
src/app/interfaces/http/api/system_routes.py
src/app/interfaces/http/api/tasks_routes.py
src/app/interfaces/http/api/trading_api.py
src/app/interfaces/http/api/trading_routes.py
src/app/interfaces/http/api/ws_routes.py
src/app/interfaces/http/dependencies.py
src/app/interfaces/http/pages/__init__.py
src/app/interfaces/http/pages/dashboard_routes.py
src/app/interfaces/http/pages/static/js/application/dashboard.js
src/app/interfaces/http/pages/static/js/core/chart.js
src/app/interfaces/http/pages/static/js/core/dom.js
src/app/interfaces/http/pages/static/js/core/http.js
src/app/interfaces/http/pages/static/js/domain/depth.js
src/app/interfaces/http/pages/static/js/domain/order.js
src/app/interfaces/http/pages/static/js/domain/price.js
src/app/interfaces/http/pages/static/js/domain/trade.js
src/app/interfaces/http/pages/static/js/pages/dashboard-config.js
src/app/interfaces/http/pages/static/js/pages/dashboard-renderers.js
src/app/interfaces/http/pages/static/js/pages/dashboard.js
src/app/interfaces/http/pages/templates/dashboard/index.html
src/app/interfaces/http/schemas.py
src/app/interfaces/tasks/__init__.py
src/app/interfaces/tasks/entrypoints.py
src/app/interfaces/tasks/market_tasks.py
src/app/interfaces/tasks/system_tasks.py
src/app/interfaces/tasks/trading_tasks.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/__init__.py">
"""Root package for application code."""
</file>

<file path="src/app/__init__.py">
"""Application package root for MEXC QRL/USDT bot."""
</file>

<file path="src/app/application/__init__.py">
"""Application layer use cases (no infrastructure)."""
</file>

<file path="src/app/application/account/__init__.py">
# Account bounded context.
</file>

<file path="src/app/application/account/use_cases/__init__.py">
# Account use cases.
</file>

<file path="src/app/application/market/__init__.py">
"""Market use cases."""
</file>

<file path="src/app/application/market/mappers/__init__.py">
"""
Mappers for translating market data payloads into domain market objects.
"""
</file>

<file path="src/app/application/market/mappers/mexc.py">
from decimal import Decimal
from datetime import datetime, timezone

from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker


def map_ws_ticker_event_to_domain(event: dict) -> Ticker:
    """Map MEXC WS ticker event to Ticker VO."""
    return Ticker(
        symbol=Symbol(str(event.get("symbol", "QRLUSDT"))),
        last_price=Decimal(str(event.get("last", "0"))),
        bid_price=Decimal(str(event.get("bidPrice", "0"))),
        ask_price=Decimal(str(event.get("askPrice", "0"))),
        ts=datetime.fromtimestamp(
            int(event.get("ts", 0)) / 1000, tz=timezone.utc
        ),
    )
</file>

<file path="src/app/application/market/qrl/__init__.py">
# QRL market application use cases package
</file>

<file path="src/app/application/market/qrl/get_qrl_depth.py">
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class GetQrlDepth:
    """Fetch QRL/USDT order book snapshot."""

    def __init__(self, rest_client: QrlRestClient, limit: int = 50):
        self._client = rest_client
        self._limit = limit

    async def execute(self) -> dict:
        async with self._client as client:
            return await client.depth(limit=self._limit)
</file>

<file path="src/app/application/market/qrl/get_qrl_kline.py">
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class GetQrlKline:
    """Fetch QRL/USDT kline data."""

    def __init__(self, rest_client: QrlRestClient, interval: str = "1m", limit: int = 100):
        self._client = rest_client
        self._interval = interval
        self._limit = limit

    async def execute(self) -> list:
        async with self._client as client:
            return await client.klines(interval=self._interval, limit=self._limit)
</file>

<file path="src/app/application/market/use_cases/__init__.py">
# Market use cases.
</file>

<file path="src/app/application/market/use_cases/get_depth.py">
"""
Market use case: get order book depth for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetDepthInput:
    limit: int = 50


class GetDepthUseCase:
    """Fetch aggregated depth for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetDepthInput | None = None) -> dict:
        payload = data or GetDepthInput()
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.depth(limit=payload.limit)
</file>

<file path="src/app/application/market/use_cases/get_kline.py">
"""
Market use case: get kline data for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetKlineInput:
    interval: str = "1m"
    limit: int = 50


class GetKlineUseCase:
    """Fetch klines for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetKlineInput | None = None) -> list:
        payload = data or GetKlineInput()
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.klines(interval=payload.interval, limit=payload.limit)
</file>

<file path="src/app/application/market/use_cases/get_market_trades.py">
"""
Market use case: recent public trades for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetMarketTradesInput:
    limit: int = 50


class GetMarketTradesUseCase:
    """Fetch recent public trades for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetMarketTradesInput | None = None) -> list:
        payload = data or GetMarketTradesInput()
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.market_trades(limit=payload.limit)
</file>

<file path="src/app/application/market/use_cases/get_stats24h.py">
"""
Market use case: 24h stats for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetStats24hInput:
    include_timestamp: bool = True


class GetStats24hUseCase:
    """Fetch 24h statistics for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetStats24hInput | None = None) -> dict:
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.ticker_24h()
</file>

<file path="src/app/application/market/use_cases/get_ticker.py">
"""
Market use case: get ticker for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetTickerInput:
    include_timestamp: bool = True


class GetTickerUseCase:
    """Fetch 24h ticker for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetTickerInput | None = None) -> dict:
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.ticker_24h()
</file>

<file path="src/app/application/ports/__init__.py">
from .exchange_gateway import ExchangeGateway

__all__ = ["ExchangeGateway"]
</file>

<file path="src/app/application/ports/exchange_gateway.py">
from typing import AsyncIterator, Protocol

from app.domain.events.market_depth_event import MarketDepthEvent
from app.domain.events.trade_event import TradeEvent
from app.domain.events.order_event import OrderEvent
from app.domain.events.balance_event import BalanceEvent
from app.domain.value_objects.symbol import Symbol


class ExchangeGateway(Protocol):
    """Application port for streaming market/account data."""

    async def subscribe_market_depth(
        self, symbol: Symbol
    ) -> AsyncIterator[MarketDepthEvent]:
        ...

    async def subscribe_trades(self, symbol: Symbol) -> AsyncIterator[TradeEvent]:
        ...

    async def subscribe_orders(self) -> AsyncIterator[OrderEvent]:
        ...

    async def subscribe_balances(self) -> AsyncIterator[BalanceEvent]:
        ...
</file>

<file path="src/app/application/system/__init__.py">
"""System use cases."""
</file>

<file path="src/app/application/system/use_cases/__init__.py">
# System use cases.
</file>

<file path="src/app/application/system/use_cases/get_server_time.py">
"""
System use case: get server time.
"""

from dataclasses import dataclass
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class GetServerTimeOutput:
    server_time: Timestamp | None = None


class GetServerTimeUseCase:
    def execute(self) -> GetServerTimeOutput:
        # TODO: retrieve via port
        return GetServerTimeOutput()
</file>

<file path="src/app/application/system/use_cases/ping.py">
"""
System use case: ping.
"""


class PingUseCase:
    def execute(self) -> None:
        # TODO: implement system ping orchestration
        return None
</file>

<file path="src/app/application/trading/__init__.py">
"""Trading use cases."""
</file>

<file path="src/app/application/trading/dto/__init__.py">
# DTOs for trading application layer.
</file>

<file path="src/app/application/trading/mappers/__init__.py">
"""
Mappers for translating external MEXC payloads into domain trading objects.
"""
</file>

<file path="src/app/application/trading/mappers/mexc.py">
from decimal import Decimal
from datetime import datetime, timezone

from src.app.domain.entities.order import Order
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId


def map_rest_order_dto_to_domain(dto: dict) -> Order:
    """Map MEXC REST order DTO (primitives) to Order entity."""
    return Order(
        order_id=OrderId(str(dto.get("orderId", ""))),
        symbol=Symbol(str(dto.get("symbol", "QRLUSDT"))),
        side=Side(str(dto.get("side", "")).upper()),
        status=OrderStatus(str(dto.get("status", "")).upper()),
        price=Decimal(str(dto.get("price", "0"))),
        quantity=Quantity(Decimal(str(dto.get("origQty", "0")))),
        created_at=Timestamp(
            datetime.fromtimestamp(int(dto.get("time", 0)) / 1000, tz=timezone.utc)
        ),
        updated_at=Timestamp(
            datetime.fromtimestamp(
                int(dto.get("updateTime", dto.get("time", 0))) / 1000, tz=timezone.utc
            )
        )
        if dto.get("updateTime")
        else None,
    )


def map_rest_trade_dto_to_domain(dto: dict) -> Trade:
    """Map MEXC REST trade DTO to Trade entity."""
    return Trade(
        trade_id=TradeId(str(dto.get("id", ""))),
        order_id=OrderId(str(dto.get("orderId", ""))),
        symbol=Symbol(str(dto.get("symbol", "QRLUSDT"))),
        side=Side(str(dto.get("side", "")).upper()),
        price=Decimal(str(dto.get("price", "0"))),
        quantity=Decimal(str(dto.get("qty", "0"))),
        fee=Decimal(str(dto["commission"])) if dto.get("commission") is not None else None,
        fee_asset=str(dto["commissionAsset"]) if dto.get("commissionAsset") else None,
        timestamp=Timestamp(
            datetime.fromtimestamp(int(dto.get("time", 0)) / 1000, tz=timezone.utc)
        ),
    )
</file>

<file path="src/app/application/trading/qrl/__init__.py">
# QRL trading use cases package
</file>

<file path="src/app/application/trading/qrl/cancel_qrl_order.py">
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class CancelQrlOrder:
    """Cancel QRL/USDT order."""

    def __init__(self, rest_client: QrlRestClient):
        self._client = rest_client

    async def execute(self, *, order_id: str | None = None, client_order_id: str | None = None) -> dict:
        async with self._client as client:
            return await client.cancel_order(order_id=order_id, client_order_id=client_order_id)
</file>

<file path="src/app/application/trading/qrl/get_qrl_order.py">
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class GetQrlOrder:
    """Fetch single QRL/USDT order details."""

    def __init__(self, rest_client: QrlRestClient):
        self._client = rest_client

    async def execute(self, *, order_id: str | None = None, client_order_id: str | None = None) -> dict:
        async with self._client as client:
            return await client.get_order(order_id=order_id, client_order_id=client_order_id)
</file>

<file path="src/app/application/trading/qrl/guards/__init__.py">
# QRL guard utilities
</file>

<file path="src/app/application/trading/qrl/guards/qrl_balance_guard.py">
from decimal import Decimal


def ensure_sufficient_balance(available_usdt: Decimal, cost: Decimal) -> None:
    if cost > available_usdt:
        raise ValueError("Insufficient USDT balance for QRL order")
</file>

<file path="src/app/application/trading/qrl/guards/qrl_duplicate_guard.py">
def prevent_duplicate(client_order_id: str | None, existing_ids: set[str] | None = None) -> None:
    if client_order_id and existing_ids and client_order_id in existing_ids:
        raise ValueError("Duplicate clientOrderId for QRL order")
</file>

<file path="src/app/application/trading/qrl/guards/qrl_price_guard.py">
from src.app.domain.value_objects.qrl_price import QrlPrice


def ensure_price_range(price: QrlPrice, min_allowed: QrlPrice | None = None, max_allowed: QrlPrice | None = None) -> None:
    if min_allowed and price.value < min_allowed.value:
        raise ValueError("Price below allowed threshold")
    if max_allowed and price.value > max_allowed.value:
        raise ValueError("Price above allowed threshold")
</file>

<file path="src/app/application/trading/qrl/guards/qrl_rate_limit_guard.py">
def enforce_rate_limit(remaining_requests: int) -> None:
    if remaining_requests <= 0:
        raise ValueError("Rate limit reached for QRL operations")
</file>

<file path="src/app/application/trading/qrl/place_qrl_order.py">
from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.qrl_quantity import QrlQuantity
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class PlaceQrlOrder:
    """Place QRL/USDT order with fixed symbol and validated VOs."""

    def __init__(self, rest_client: QrlRestClient):
        self._client = rest_client

    async def execute(
        self,
        *,
        side: str,
        order_type: str,
        price: QrlPrice | None,
        quantity: QrlQuantity,
        time_in_force: str | None = "GTC",
        client_order_id: str | None = None,
    ) -> dict:
        async with self._client as client:
            return await client.create_order(
                side=side,
                order_type=order_type,
                price=str(price.value) if price else None,
                quantity=str(quantity.value),
                time_in_force=time_in_force,
                client_order_id=client_order_id,
            )
</file>

<file path="src/app/application/trading/use_cases/__init__.py">
# Trading use cases.
</file>

<file path="src/app/application/trading/use_cases/cancel_order.py">
"""Trading use case: cancel existing order for QRL/USDT."""

from dataclasses import dataclass

from src.app.application.exchange.mexc_service import CancelOrderRequest, MexcService, build_mexc_service
from src.app.application.trading.use_cases.place_order import _serialize_order
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


@dataclass
class CancelOrderInput:
    symbol: str
    order_id: str | None = None
    client_order_id: str | None = None


class CancelOrderUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, data: CancelOrderInput) -> dict:
        request = CancelOrderRequest(
            symbol=Symbol(data.symbol),
            order_id=data.order_id,
            client_order_id=data.client_order_id,
        )
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            order = await svc.cancel_order(request)
        return _serialize_order(order)
</file>

<file path="src/app/application/trading/use_cases/get_kline.py">
from dataclasses import dataclass
from typing import List

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.domain.value_objects.kline import KLine
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _serialize_kline(k: KLine) -> dict:
    return {
        "open": str(k.open),
        "high": str(k.high),
        "low": str(k.low),
        "close": str(k.close),
        "volume": str(k.volume),
        "interval": k.interval,
        "timestamp": k.timestamp.value.isoformat(),
    }


@dataclass
class GetKlineUseCase:
    settings: MexcSettings | None = None

    async def execute(self, symbol: str, interval: str, limit: int = 100) -> List[dict]:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            klines = await svc.get_kline(Symbol(symbol), interval=interval, limit=limit)
        return [_serialize_kline(k) for k in klines]
</file>

<file path="src/app/application/trading/use_cases/get_order.py">
"""Trading use case: get single order."""

from dataclasses import dataclass

from src.app.application.exchange.mexc_service import GetOrderRequest, MexcService, build_mexc_service
from src.app.application.trading.use_cases.place_order import _serialize_order
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


@dataclass
class GetOrderInput:
    symbol: str
    order_id: str | None = None
    client_order_id: str | None = None


class GetOrderUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, data: GetOrderInput) -> dict:
        request = GetOrderRequest(
            symbol=Symbol(data.symbol),
            order_id=data.order_id,
            client_order_id=data.client_order_id,
        )
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            order = await svc.get_order(request)
        return _serialize_order(order)
</file>

<file path="src/app/application/trading/use_cases/get_price.py">
from dataclasses import dataclass

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _serialize_price(price: Price) -> dict:
    return {
        "bid": str(price.bid),
        "ask": str(price.ask),
        "last": str(price.last),
        "timestamp": price.timestamp.value.isoformat(),
    }


@dataclass
class GetPriceUseCase:
    settings: MexcSettings | None = None

    async def execute(self, symbol: str) -> dict:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            price = await svc.get_price(Symbol(symbol))
        return _serialize_price(price)
</file>

<file path="src/app/application/trading/use_cases/list_orders.py">
"""Trading use case: list open/closed orders."""

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.application.trading.use_cases.place_order import _serialize_order
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class ListOrdersUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, symbol: str | None = None) -> list[dict]:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            orders = await svc.list_open_orders(Symbol(symbol) if symbol else None)
        return [_serialize_order(order) for order in orders]
</file>

<file path="src/app/domain/__init__.py">
"""Domain layer root."""
</file>

<file path="src/app/domain/entities/account.py">
from dataclasses import dataclass
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class Account:
    """Spot account snapshot."""

    can_trade: bool
    update_time: Timestamp
    balances: list[Balance]
</file>

<file path="src/app/domain/entities/trading_pair.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class TradingPair:
    """Represents a trading pair such as QRL/USDT."""

    base_currency: str
    quote_currency: str

    @property
    def symbol(self) -> str:
        return f"{self.base_currency}{self.quote_currency}".upper()
</file>

<file path="src/app/domain/events/balance_event.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class BalanceEvent:
    """Account balance snapshot/update."""

    asset: str
    free: Decimal
    locked: Decimal
    timestamp: int
</file>

<file path="src/app/domain/events/market_depth_event.py">
from dataclasses import dataclass
from typing import List, Tuple

from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol


@dataclass(frozen=True)
class MarketDepthEvent:
    """
    Order book depth snapshot/update at a point in time.

    Notes:
        - Bids/asks are sorted by price on the exchange side.
        - Versions allow consumers to detect gaps and request replay.
    """

    symbol: Symbol
    bids: List[Tuple[Price, Quantity]]
    asks: List[Tuple[Price, Quantity]]
    event_type: str | None
    from_version: str | None
    to_version: str | None
</file>

<file path="src/app/domain/events/order_event.py">
from dataclasses import dataclass

from app.domain.value_objects.order_id import OrderId
from app.domain.value_objects.order_status import OrderStatus
from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol


@dataclass(frozen=True)
class OrderEvent:
    """Private order update event."""

    order_id: OrderId
    symbol: Symbol
    price: Price
    quantity: Quantity
    status: OrderStatus
    timestamp: int
</file>

<file path="src/app/domain/events/trade_event.py">
from dataclasses import dataclass

from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol
from app.domain.value_objects.trade_id import TradeId


@dataclass(frozen=True)
class TradeEvent:
    """Public trade tick."""

    trade_id: TradeId
    symbol: Symbol
    price: Price
    quantity: Quantity
    is_buyer_maker: bool
    timestamp: int
</file>

<file path="src/app/domain/value_objects/api_key.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class ApiKey:
    """API key used for authenticated MEXC requests."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("API key cannot be empty")
</file>

<file path="src/app/domain/value_objects/api_secret.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class ApiSecret:
    """API secret used to sign requests."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("API secret cannot be empty")
</file>

<file path="src/app/domain/value_objects/balance.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class Balance:
    """Asset balance with free and locked amounts."""

    asset: str
    free: Decimal
    locked: Decimal

    def __post_init__(self):
        if not self.asset:
            raise ValueError("Asset symbol cannot be empty")
        if self.free < 0 or self.locked < 0:
            raise ValueError("Balance amounts cannot be negative")
</file>

<file path="src/app/domain/value_objects/client_order_id.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class ClientOrderId:
    """Client-supplied idempotency key for orders."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("Client order id cannot be empty")
        if len(self.value) > 32:
            raise ValueError("Client order id must be 32 characters or fewer")
</file>

<file path="src/app/domain/value_objects/kline.py">
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal

from src.app.domain.value_objects.timestamp import Timestamp


@dataclass(frozen=True)
class KLine:
    """Single candlestick for a trading pair."""

    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    interval: str
    timestamp: Timestamp

    def __post_init__(self):
        if min(self.open, self.high, self.low, self.close) < 0:
            raise ValueError("KLine prices cannot be negative")
        if self.volume < 0:
            raise ValueError("KLine volume cannot be negative")
        if not self.interval:
            raise ValueError("KLine interval is required")

    @classmethod
    def from_raw(
        cls,
        open_price: Decimal,
        high: Decimal,
        low: Decimal,
        close: Decimal,
        volume: Decimal,
        interval: str,
        timestamp_ms: int,
    ) -> "KLine":
        ts = Timestamp(datetime.fromtimestamp(timestamp_ms / 1000, tz=timezone.utc))
        return cls(open=open_price, high=high, low=low, close=close, volume=volume, interval=interval, timestamp=ts)
</file>

<file path="src/app/domain/value_objects/order_id.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class OrderId:
    """Order identifier returned by MEXC."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("OrderId cannot be empty")
</file>

<file path="src/app/domain/value_objects/order_status.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class OrderStatus:
    """Order status with a minimal allowed set."""

    value: str

    _allowed = {
        "NEW",
        "PARTIALLY_FILLED",
        "FILLED",
        "CANCELED",
        "REJECTED",
    }

    def __post_init__(self):
        if self.value not in self._allowed:
            raise ValueError(f"OrderStatus must be one of {sorted(self._allowed)}")
</file>

<file path="src/app/domain/value_objects/order_type.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class OrderType:
    """Supported MEXC order types."""

    value: str

    _allowed = {"LIMIT", "MARKET"}

    def __post_init__(self):
        if self.value not in self._allowed:
            raise ValueError(f"OrderType must be one of {sorted(self._allowed)}")
</file>

<file path="src/app/domain/value_objects/price.py">
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal

from src.app.domain.value_objects.timestamp import Timestamp


@dataclass(frozen=True)
class Price:
    """Quote for a trading pair with bid/ask/last and timestamp."""

    bid: Decimal
    ask: Decimal
    last: Decimal
    timestamp: Timestamp

    def __post_init__(self):
        if self.bid <= 0 or self.ask <= 0 or self.last <= 0:
            raise ValueError("Price values must be positive")

    @classmethod
    def from_single(cls, value: Decimal, ts: datetime | None = None) -> "Price":
        """Construct a Price when only a single quote is available."""
        stamp = Timestamp(ts or datetime.now(timezone.utc))
        return cls(bid=value, ask=value, last=value, timestamp=stamp)
</file>

<file path="src/app/domain/value_objects/qrl_price.py">
from __future__ import annotations

from decimal import Decimal, ROUND_DOWN, getcontext
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from src.app.domain.value_objects.qrl_quantity import QrlQuantity

getcontext().prec = 28


class QrlPrice:
    """
    QRL/USDT 專用價格 Value Object
    - 不可變
    - 強制 tick size
    """

    TICK_SIZE = Decimal("0.0001")
    MIN_PRICE = TICK_SIZE

    def __init__(self, value: Decimal | str | float):
        self._value = self._normalize(Decimal(str(value)))

    @staticmethod
    def _normalize(value: Decimal) -> Decimal:
        if value <= 0:
            raise ValueError("QRL price must be > 0")

        normalized = (value // QrlPrice.TICK_SIZE) * QrlPrice.TICK_SIZE

        if normalized < QrlPrice.MIN_PRICE:
            raise ValueError("QRL price below minimum tick size")

        return normalized.quantize(QrlPrice.TICK_SIZE, rounding=ROUND_DOWN)

    @property
    def value(self) -> Decimal:
        return self._value

    def __str__(self) -> str:
        return format(self._value, "f")

    def __repr__(self) -> str:
        return f"QrlPrice({self._value})"

    def multiply(self, quantity: "QrlQuantity") -> Decimal:
        return (self._value * quantity.value).quantize(
            Decimal("0.00000001"), rounding=ROUND_DOWN
        )
</file>

<file path="src/app/domain/value_objects/qrl_quantity.py">
from __future__ import annotations

from decimal import Decimal, ROUND_DOWN, getcontext

getcontext().prec = 28


class QrlQuantity:
    """
    QRL 專用數量 Value Object
    - 不可變
    - 防 fat finger
    """

    STEP_SIZE = Decimal("1")
    MIN_QTY = Decimal("1")
    MAX_QTY = Decimal("1000000")

    def __init__(self, value: Decimal | str | int | float):
        self._value = self._normalize(Decimal(str(value)))

    @staticmethod
    def _normalize(value: Decimal) -> Decimal:
        if value <= 0:
            raise ValueError("QRL quantity must be > 0")

        normalized = (value // QrlQuantity.STEP_SIZE) * QrlQuantity.STEP_SIZE

        if normalized < QrlQuantity.MIN_QTY:
            raise ValueError("QRL quantity below minimum")

        if normalized > QrlQuantity.MAX_QTY:
            raise ValueError("QRL quantity exceeds safety limit")

        return normalized.quantize(QrlQuantity.STEP_SIZE, rounding=ROUND_DOWN)

    @property
    def value(self) -> Decimal:
        return self._value

    def __str__(self) -> str:
        return format(self._value, "f")

    def __repr__(self) -> str:
        return f"QrlQuantity({self._value})"
</file>

<file path="src/app/domain/value_objects/qrl_usdt_pair.py">
class QrlUsdtPair:
    """QRL/USDT 專用交易對，不允許動態建構."""

    SYMBOL = "QRLUSDT"
    BASE = "QRL"
    QUOTE = "USDT"

    @classmethod
    def symbol(cls) -> str:
        return cls.SYMBOL

    @classmethod
    def base(cls) -> str:
        return cls.BASE

    @classmethod
    def quote(cls) -> str:
        return cls.QUOTE
</file>

<file path="src/app/domain/value_objects/quantity.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class Quantity:
    """Positive trade quantity."""

    value: Decimal

    def __post_init__(self):
        if self.value <= 0:
            raise ValueError("Quantity must be positive")
</file>

<file path="src/app/domain/value_objects/side.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class Side:
    """Order side constrained to BUY/SELL."""

    value: str

    def __post_init__(self):
        if self.value not in ("BUY", "SELL"):
            raise ValueError("Side must be BUY or SELL")
</file>

<file path="src/app/domain/value_objects/sub_account_id.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class SubAccountId:
    """Numeric sub-account identifier used by MEXC spot API."""

    value: int

    def __post_init__(self):
        if self.value <= 0:
            raise ValueError("SubAccountId must be a positive integer")
</file>

<file path="src/app/domain/value_objects/symbol.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class Symbol:
    """Trading symbol constrained to QRL/USDT scope."""

    value: str

    def __post_init__(self):
        normalized = self.value.replace("/", "").upper()
        if normalized != "QRLUSDT":
            raise ValueError("Symbol must be QRL/USDT")
</file>

<file path="src/app/domain/value_objects/ticker.py">
from dataclasses import dataclass
from decimal import Decimal
from datetime import datetime, timezone

from src.app.domain.value_objects.symbol import Symbol


@dataclass(frozen=True)
class Ticker:
    """Minimal ticker snapshot for QRL/USDT."""

    symbol: Symbol
    last_price: Decimal
    bid_price: Decimal
    ask_price: Decimal
    ts: datetime

    def __post_init__(self):
        if self.last_price <= 0 or self.bid_price <= 0 or self.ask_price <= 0:
            raise ValueError("Ticker prices must be positive")
        if self.bid_price > self.ask_price:
            raise ValueError("Bid price cannot exceed ask price")
        if self.ts.tzinfo is None:
            object.__setattr__(self, "ts", self.ts.replace(tzinfo=timezone.utc))
</file>

<file path="src/app/domain/value_objects/time_in_force.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class TimeInForce:
    """Time in force constraints for limit orders."""

    value: str

    _allowed = {"GTC", "IOC", "FOK"}

    def __post_init__(self):
        if self.value not in self._allowed:
            raise ValueError(f"TimeInForce must be one of {sorted(self._allowed)}")
</file>

<file path="src/app/domain/value_objects/timestamp.py">
from dataclasses import dataclass
from datetime import datetime, timezone


@dataclass(frozen=True)
class Timestamp:
    """UTC timestamp wrapper."""

    value: datetime

    def __post_init__(self):
        if self.value.tzinfo is None:
            object.__setattr__(self, "value", self.value.replace(tzinfo=timezone.utc))
</file>

<file path="src/app/domain/value_objects/trade_id.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class TradeId:
    """Trade identifier returned by MEXC."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("TradeId cannot be empty")
</file>

<file path="src/app/infrastructure/__init__.py">
"""Infrastructure layer placeholder (no implementations yet)."""
</file>

<file path="src/app/infrastructure/config.py">
class Config:
    """Placeholder config for skeleton build."""

    LOG_LEVEL = "INFO"
    LOG_FORMAT = "text"
    PORT = 8000
    HOST = "0.0.0.0"
    DEBUG = False


config = Config()
</file>

<file path="src/app/infrastructure/exchange/__init__.py">
# Technical exchange integrations live here.
</file>

<file path="src/app/infrastructure/exchange/mexc_api_client.py">
from datetime import datetime, timezone
from decimal import Decimal
from typing import Any, Iterable

from src.app.domain.entities.trading_pair import TradingPair
from src.app.domain.value_objects.kline import KLine
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.infrastructure.exchange.mexc.rest_client import MexcRestClient


class MexcApiClient:
    """High-level client that maps REST responses to domain value objects."""

    def __init__(self, rest_client: MexcRestClient):
        self._rest_client = rest_client

    async def __aenter__(self) -> "MexcApiClient":
        await self._rest_client.__aenter__()
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self._rest_client.__aexit__(exc_type, exc, tb)

    async def get_price(self, pair: TradingPair) -> Price:
        payload = await self._rest_client.ticker_24h(symbol=pair.symbol)
        bid = Decimal(payload.get("bidPrice", "0"))
        ask = Decimal(payload.get("askPrice", "0"))
        last = Decimal(payload.get("lastPrice", payload.get("last", "0")))
        ts_value = payload.get("closeTime") or payload.get("close_time") or int(datetime.now(tz=timezone.utc).timestamp() * 1000)
        timestamp = Timestamp(datetime.fromtimestamp(int(ts_value) / 1000, tz=timezone.utc))
        return Price(bid=bid, ask=ask, last=last, timestamp=timestamp)

    async def get_klines(self, pair: TradingPair, interval: str, limit: int = 100) -> list[KLine]:
        raw_list = await self._rest_client.klines(symbol=pair.symbol, interval=interval, limit=limit)
        klines: list[KLine] = []
        for item in raw_list:
            if not isinstance(item, Iterable):
                continue
            open_time = int(item[0])
            open_price = Decimal(item[1])
            high = Decimal(item[2])
            low = Decimal(item[3])
            close = Decimal(item[4])
            volume = Decimal(item[5])
            klines.append(KLine.from_raw(open_price, high, low, close, volume, interval, open_time))
        return klines
</file>

<file path="src/app/infrastructure/exchange/mexc/__init__.py">
# MEXC exchange integration namespace.
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/__init__.py">
from .balance_mapper import balance_proto_to_domain
from .depth_mapper import depth_proto_to_domain
from .market_event_adapter import MexcExchangeGateway
from .order_mapper import order_proto_to_domain
from .trade_mapper import trade_proto_to_domain

__all__ = [
    "MexcExchangeGateway",
    "balance_proto_to_domain",
    "depth_proto_to_domain",
    "order_proto_to_domain",
    "trade_proto_to_domain",
]
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/balance_mapper.py">
from decimal import Decimal

from app.domain.events.balance_event import BalanceEvent
from app.infrastructure.exchange.mexc.generated import PrivateAccountV3Api_pb2


def balance_proto_to_domain(
    proto: PrivateAccountV3Api_pb2.PrivateAccountV3ApiBalance,
) -> BalanceEvent:
    return BalanceEvent(
        asset=proto.asset,
        free=Decimal(proto.free),
        locked=Decimal(proto.locked),
        timestamp=proto.timestamp,
    )
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/depth_mapper.py">
from app.domain.events.market_depth_event import MarketDepthEvent
from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol
from app.infrastructure.exchange.mexc.generated import PublicAggreDepthsV3Api_pb2


def depth_proto_to_domain(
    symbol: Symbol, proto: PublicAggreDepthsV3Api_pb2.PublicAggreDepthsV3Api
) -> MarketDepthEvent:
    bids = [
        (Price(float(item.price)), Quantity(float(item.quantity))) for item in proto.bids
    ]
    asks = [
        (Price(float(item.price)), Quantity(float(item.quantity))) for item in proto.asks
    ]

    return MarketDepthEvent(
        symbol=symbol,
        bids=bids,
        asks=asks,
        event_type=proto.eventType if hasattr(proto, "eventType") else None,
        from_version=proto.fromVersion if hasattr(proto, "fromVersion") else None,
        to_version=proto.toVersion if hasattr(proto, "toVersion") else None,
    )
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/market_event_adapter.py">
from typing import AsyncIterator

from app.application.ports.exchange_gateway import ExchangeGateway
from app.domain.events.balance_event import BalanceEvent
from app.domain.events.market_depth_event import MarketDepthEvent
from app.domain.events.order_event import OrderEvent
from app.domain.events.trade_event import TradeEvent
from app.domain.value_objects.symbol import Symbol
from app.infrastructure.exchange.mexc.generated import (
    PrivateAccountV3Api_pb2,
    PrivateOrdersV3Api_pb2,
    PublicAggreDepthsV3Api_pb2,
    PublicDealsV3Api_pb2,
)
from app.infrastructure.exchange.mexc.ws.mexc_ws_client import MexcWebSocketClient
from .balance_mapper import balance_proto_to_domain
from .order_mapper import order_proto_to_domain
from .trade_mapper import trade_proto_to_domain
from .depth_mapper import depth_proto_to_domain


class MexcExchangeGateway(ExchangeGateway):
    """Infrastructure adapter that translates MEXC WS protobuf into domain events."""

    def __init__(self, ws_client: MexcWebSocketClient):
        self._ws = ws_client

    async def subscribe_market_depth(
        self, symbol: Symbol
    ) -> AsyncIterator[MarketDepthEvent]:
        async for proto in self._ws.subscribe("depth", symbol.value):
            if isinstance(proto, PublicAggreDepthsV3Api_pb2.PublicAggreDepthsV3Api):
                yield depth_proto_to_domain(symbol, proto)

    async def subscribe_trades(self, symbol: Symbol) -> AsyncIterator[TradeEvent]:
        async for proto in self._ws.subscribe("deals", symbol.value):
            if isinstance(proto, PublicDealsV3Api_pb2.PublicDealsV3Api):
                for item in proto.deals:
                    yield trade_proto_to_domain(symbol, item)

    async def subscribe_orders(self) -> AsyncIterator[OrderEvent]:
        async for proto in self._ws.subscribe("orders"):
            if isinstance(proto, PrivateOrdersV3Api_pb2.PrivateOrdersV3Api):
                yield order_proto_to_domain(proto)

    async def subscribe_balances(self) -> AsyncIterator[BalanceEvent]:
        async for proto in self._ws.subscribe("balances"):
            if isinstance(proto, PrivateAccountV3Api_pb2.PrivateAccountV3Api):
                yield balance_proto_to_domain(proto)
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/order_mapper.py">
from app.domain.events.order_event import OrderEvent
from app.domain.value_objects.order_id import OrderId
from app.domain.value_objects.order_status import OrderStatus
from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol
from app.infrastructure.exchange.mexc.generated import PrivateOrdersV3Api_pb2


def order_proto_to_domain(proto: PrivateOrdersV3Api_pb2.PrivateOrdersV3Api) -> OrderEvent:
    # MEXC push includes status as int; default to NEW when unmapped
    status_value = "NEW"
    try:
        status_value = str(proto.status).upper()
    except Exception:
        status_value = "NEW"

    try:
        status = OrderStatus(status_value)
    except ValueError:
        status = OrderStatus("NEW")

    return OrderEvent(
        order_id=OrderId(proto.id),
        symbol=Symbol("QRLUSDT"),
        price=Price(float(proto.price)),
        quantity=Quantity(float(proto.quantity)),
        status=status,
        timestamp=proto.createTime,
    )
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/trade_mapper.py">
from app.domain.events.trade_event import TradeEvent
from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol
from app.domain.value_objects.trade_id import TradeId
from app.infrastructure.exchange.mexc.generated import PublicDealsV3Api_pb2


def trade_proto_to_domain(
    symbol: Symbol, proto: PublicDealsV3Api_pb2.PublicDealsV3ApiItem
) -> TradeEvent:
    # tradeType: 1=buy, 2=sell in MEXC WS push; treat 2 as maker sell
    is_buyer_maker = proto.tradeType == 2
    return TradeEvent(
        trade_id=TradeId(str(proto.time)),
        symbol=symbol,
        price=Price(float(proto.price)),
        quantity=Quantity(float(proto.quantity)),
        is_buyer_maker=is_buyer_maker,
        timestamp=proto.time,
    )
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/__init__.py">
"""Generated protobuf modules for MEXC WebSocket V3 APIs."""
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PrivateAccountV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PrivateAccountV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PrivateAccountV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x19PrivateAccountV3Api.proto\"\xba\x01\n\x13PrivateAccountV3Api\x12\x11\n\tvcoinName\x18\x01 \x01(\t\x12\x0e\n\x06\x63oinId\x18\x02 \x01(\t\x12\x15\n\rbalanceAmount\x18\x03 \x01(\t\x12\x1b\n\x13\x62\x61lanceAmountChange\x18\x04 \x01(\t\x12\x14\n\x0c\x66rozenAmount\x18\x05 \x01(\t\x12\x1a\n\x12\x66rozenAmountChange\x18\x06 \x01(\t\x12\x0c\n\x04type\x18\x07 \x01(\t\x12\x0c\n\x04time\x18\x08 \x01(\x03\x42<\n\x1c\x63om.mxc.push.common.protobufB\x18PrivateAccountV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PrivateAccountV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\030PrivateAccountV3ApiProtoH\001P\001'
  _globals['_PRIVATEACCOUNTV3API']._serialized_start=30
  _globals['_PRIVATEACCOUNTV3API']._serialized_end=216
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PrivateDealsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PrivateDealsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PrivateDealsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x17PrivateDealsV3Api.proto\"\xec\x01\n\x11PrivateDealsV3Api\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\t\x12\x0e\n\x06\x61mount\x18\x03 \x01(\t\x12\x11\n\ttradeType\x18\x04 \x01(\x05\x12\x0f\n\x07isMaker\x18\x05 \x01(\x08\x12\x13\n\x0bisSelfTrade\x18\x06 \x01(\x08\x12\x0f\n\x07tradeId\x18\x07 \x01(\t\x12\x15\n\rclientOrderId\x18\x08 \x01(\t\x12\x0f\n\x07orderId\x18\t \x01(\t\x12\x11\n\tfeeAmount\x18\n \x01(\t\x12\x13\n\x0b\x66\x65\x65\x43urrency\x18\x0b \x01(\t\x12\x0c\n\x04time\x18\x0c \x01(\x03\x42:\n\x1c\x63om.mxc.push.common.protobufB\x16PrivateDealsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PrivateDealsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\026PrivateDealsV3ApiProtoH\001P\001'
  _globals['_PRIVATEDEALSV3API']._serialized_start=28
  _globals['_PRIVATEDEALSV3API']._serialized_end=264
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PrivateOrdersV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PrivateOrdersV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PrivateOrdersV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x18PrivateOrdersV3Api.proto\"\xe8\x05\n\x12PrivateOrdersV3Api\x12\n\n\x02id\x18\x01 \x01(\t\x12\x10\n\x08\x63lientId\x18\x02 \x01(\t\x12\r\n\x05price\x18\x03 \x01(\t\x12\x10\n\x08quantity\x18\x04 \x01(\t\x12\x0e\n\x06\x61mount\x18\x05 \x01(\t\x12\x10\n\x08\x61vgPrice\x18\x06 \x01(\t\x12\x11\n\torderType\x18\x07 \x01(\x05\x12\x11\n\ttradeType\x18\x08 \x01(\x05\x12\x0f\n\x07isMaker\x18\t \x01(\x08\x12\x14\n\x0cremainAmount\x18\n \x01(\t\x12\x16\n\x0eremainQuantity\x18\x0b \x01(\t\x12\x1d\n\x10lastDealQuantity\x18\x0c \x01(\tH\x00\x88\x01\x01\x12\x1a\n\x12\x63umulativeQuantity\x18\r \x01(\t\x12\x18\n\x10\x63umulativeAmount\x18\x0e \x01(\t\x12\x0e\n\x06status\x18\x0f \x01(\x05\x12\x12\n\ncreateTime\x18\x10 \x01(\x03\x12\x13\n\x06market\x18\x11 \x01(\tH\x01\x88\x01\x01\x12\x18\n\x0btriggerType\x18\x12 \x01(\x05H\x02\x88\x01\x01\x12\x19\n\x0ctriggerPrice\x18\x13 \x01(\tH\x03\x88\x01\x01\x12\x12\n\x05state\x18\x14 \x01(\x05H\x04\x88\x01\x01\x12\x12\n\x05ocoId\x18\x15 \x01(\tH\x05\x88\x01\x01\x12\x18\n\x0brouteFactor\x18\x16 \x01(\tH\x06\x88\x01\x01\x12\x15\n\x08symbolId\x18\x17 \x01(\tH\x07\x88\x01\x01\x12\x15\n\x08marketId\x18\x18 \x01(\tH\x08\x88\x01\x01\x12\x1d\n\x10marketCurrencyId\x18\x19 \x01(\tH\t\x88\x01\x01\x12\x17\n\ncurrencyId\x18\x1a \x01(\tH\n\x88\x01\x01\x42\x13\n\x11_lastDealQuantityB\t\n\x07_marketB\x0e\n\x0c_triggerTypeB\x0f\n\r_triggerPriceB\x08\n\x06_stateB\x08\n\x06_ocoIdB\x0e\n\x0c_routeFactorB\x0b\n\t_symbolIdB\x0b\n\t_marketIdB\x13\n\x11_marketCurrencyIdB\r\n\x0b_currencyIdB;\n\x1c\x63om.mxc.push.common.protobufB\x17PrivateOrdersV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PrivateOrdersV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\027PrivateOrdersV3ApiProtoH\001P\001'
  _globals['_PRIVATEORDERSV3API']._serialized_start=29
  _globals['_PRIVATEORDERSV3API']._serialized_end=773
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicAggreBookTickerV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicAggreBookTickerV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicAggreBookTickerV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n PublicAggreBookTickerV3Api.proto\"j\n\x1aPublicAggreBookTickerV3Api\x12\x10\n\x08\x62idPrice\x18\x01 \x01(\t\x12\x13\n\x0b\x62idQuantity\x18\x02 \x01(\t\x12\x10\n\x08\x61skPrice\x18\x03 \x01(\t\x12\x13\n\x0b\x61skQuantity\x18\x04 \x01(\tBC\n\x1c\x63om.mxc.push.common.protobufB\x1fPublicAggreBookTickerV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicAggreBookTickerV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\037PublicAggreBookTickerV3ApiProtoH\001P\001'
  _globals['_PUBLICAGGREBOOKTICKERV3API']._serialized_start=36
  _globals['_PUBLICAGGREBOOKTICKERV3API']._serialized_end=142
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicAggreDealsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicAggreDealsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicAggreDealsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1bPublicAggreDealsV3Api.proto\"U\n\x15PublicAggreDealsV3Api\x12)\n\x05\x64\x65\x61ls\x18\x01 \x03(\x0b\x32\x1a.PublicAggreDealsV3ApiItem\x12\x11\n\teventType\x18\x02 \x01(\t\"]\n\x19PublicAggreDealsV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\t\x12\x11\n\ttradeType\x18\x03 \x01(\x05\x12\x0c\n\x04time\x18\x04 \x01(\x03\x42>\n\x1c\x63om.mxc.push.common.protobufB\x1aPublicAggreDealsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicAggreDealsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\032PublicAggreDealsV3ApiProtoH\001P\001'
  _globals['_PUBLICAGGREDEALSV3API']._serialized_start=31
  _globals['_PUBLICAGGREDEALSV3API']._serialized_end=116
  _globals['_PUBLICAGGREDEALSV3APIITEM']._serialized_start=118
  _globals['_PUBLICAGGREDEALSV3APIITEM']._serialized_end=211
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicAggreDepthsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicAggreDepthsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicAggreDepthsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1cPublicAggreDepthsV3Api.proto\"\xa7\x01\n\x16PublicAggreDepthsV3Api\x12(\n\x04\x61sks\x18\x01 \x03(\x0b\x32\x1a.PublicAggreDepthV3ApiItem\x12(\n\x04\x62ids\x18\x02 \x03(\x0b\x32\x1a.PublicAggreDepthV3ApiItem\x12\x11\n\teventType\x18\x03 \x01(\t\x12\x13\n\x0b\x66romVersion\x18\x04 \x01(\t\x12\x11\n\ttoVersion\x18\x05 \x01(\t\"<\n\x19PublicAggreDepthV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\tB?\n\x1c\x63om.mxc.push.common.protobufB\x1bPublicAggreDepthsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicAggreDepthsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\033PublicAggreDepthsV3ApiProtoH\001P\001'
  _globals['_PUBLICAGGREDEPTHSV3API']._serialized_start=33
  _globals['_PUBLICAGGREDEPTHSV3API']._serialized_end=200
  _globals['_PUBLICAGGREDEPTHV3APIITEM']._serialized_start=202
  _globals['_PUBLICAGGREDEPTHV3APIITEM']._serialized_end=262
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicBookTickerBatchV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicBookTickerBatchV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicBookTickerBatchV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import PublicBookTickerV3Api_pb2 as PublicBookTickerV3Api__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n PublicBookTickerBatchV3Api.proto\x1a\x1bPublicBookTickerV3Api.proto\"C\n\x1aPublicBookTickerBatchV3Api\x12%\n\x05items\x18\x01 \x03(\x0b\x32\x16.PublicBookTickerV3ApiBC\n\x1c\x63om.mxc.push.common.protobufB\x1fPublicBookTickerBatchV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicBookTickerBatchV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\037PublicBookTickerBatchV3ApiProtoH\001P\001'
  _globals['_PUBLICBOOKTICKERBATCHV3API']._serialized_start=65
  _globals['_PUBLICBOOKTICKERBATCHV3API']._serialized_end=132
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicBookTickerV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicBookTickerV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicBookTickerV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1bPublicBookTickerV3Api.proto\"e\n\x15PublicBookTickerV3Api\x12\x10\n\x08\x62idPrice\x18\x01 \x01(\t\x12\x13\n\x0b\x62idQuantity\x18\x02 \x01(\t\x12\x10\n\x08\x61skPrice\x18\x03 \x01(\t\x12\x13\n\x0b\x61skQuantity\x18\x04 \x01(\tB>\n\x1c\x63om.mxc.push.common.protobufB\x1aPublicBookTickerV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicBookTickerV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\032PublicBookTickerV3ApiProtoH\001P\001'
  _globals['_PUBLICBOOKTICKERV3API']._serialized_start=31
  _globals['_PUBLICBOOKTICKERV3API']._serialized_end=132
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicDealsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicDealsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicDealsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x16PublicDealsV3Api.proto\"K\n\x10PublicDealsV3Api\x12$\n\x05\x64\x65\x61ls\x18\x01 \x03(\x0b\x32\x15.PublicDealsV3ApiItem\x12\x11\n\teventType\x18\x02 \x01(\t\"X\n\x14PublicDealsV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\t\x12\x11\n\ttradeType\x18\x03 \x01(\x05\x12\x0c\n\x04time\x18\x04 \x01(\x03\x42\x39\n\x1c\x63om.mxc.push.common.protobufB\x15PublicDealsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicDealsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\025PublicDealsV3ApiProtoH\001P\001'
  _globals['_PUBLICDEALSV3API']._serialized_start=26
  _globals['_PUBLICDEALSV3API']._serialized_end=101
  _globals['_PUBLICDEALSV3APIITEM']._serialized_start=103
  _globals['_PUBLICDEALSV3APIITEM']._serialized_end=191
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicIncreaseDepthsBatchV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicIncreaseDepthsBatchV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicIncreaseDepthsBatchV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import PublicIncreaseDepthsV3Api_pb2 as PublicIncreaseDepthsV3Api__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n$PublicIncreaseDepthsBatchV3Api.proto\x1a\x1fPublicIncreaseDepthsV3Api.proto\"^\n\x1ePublicIncreaseDepthsBatchV3Api\x12)\n\x05items\x18\x01 \x03(\x0b\x32\x1a.PublicIncreaseDepthsV3Api\x12\x11\n\teventType\x18\x02 \x01(\tBG\n\x1c\x63om.mxc.push.common.protobufB#PublicIncreaseDepthsBatchV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicIncreaseDepthsBatchV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB#PublicIncreaseDepthsBatchV3ApiProtoH\001P\001'
  _globals['_PUBLICINCREASEDEPTHSBATCHV3API']._serialized_start=73
  _globals['_PUBLICINCREASEDEPTHSBATCHV3API']._serialized_end=167
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicIncreaseDepthsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicIncreaseDepthsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicIncreaseDepthsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fPublicIncreaseDepthsV3Api.proto\"\x99\x01\n\x19PublicIncreaseDepthsV3Api\x12+\n\x04\x61sks\x18\x01 \x03(\x0b\x32\x1d.PublicIncreaseDepthV3ApiItem\x12+\n\x04\x62ids\x18\x02 \x03(\x0b\x32\x1d.PublicIncreaseDepthV3ApiItem\x12\x11\n\teventType\x18\x03 \x01(\t\x12\x0f\n\x07version\x18\x04 \x01(\t\"?\n\x1cPublicIncreaseDepthV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\tBB\n\x1c\x63om.mxc.push.common.protobufB\x1ePublicIncreaseDepthsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicIncreaseDepthsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\036PublicIncreaseDepthsV3ApiProtoH\001P\001'
  _globals['_PUBLICINCREASEDEPTHSV3API']._serialized_start=36
  _globals['_PUBLICINCREASEDEPTHSV3API']._serialized_end=189
  _globals['_PUBLICINCREASEDEPTHV3APIITEM']._serialized_start=191
  _globals['_PUBLICINCREASEDEPTHV3APIITEM']._serialized_end=254
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicLimitDepthsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicLimitDepthsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicLimitDepthsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1cPublicLimitDepthsV3Api.proto\"\x90\x01\n\x16PublicLimitDepthsV3Api\x12(\n\x04\x61sks\x18\x01 \x03(\x0b\x32\x1a.PublicLimitDepthV3ApiItem\x12(\n\x04\x62ids\x18\x02 \x03(\x0b\x32\x1a.PublicLimitDepthV3ApiItem\x12\x11\n\teventType\x18\x03 \x01(\t\x12\x0f\n\x07version\x18\x04 \x01(\t\"<\n\x19PublicLimitDepthV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\tB?\n\x1c\x63om.mxc.push.common.protobufB\x1bPublicLimitDepthsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicLimitDepthsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\033PublicLimitDepthsV3ApiProtoH\001P\001'
  _globals['_PUBLICLIMITDEPTHSV3API']._serialized_start=33
  _globals['_PUBLICLIMITDEPTHSV3API']._serialized_end=177
  _globals['_PUBLICLIMITDEPTHV3APIITEM']._serialized_start=179
  _globals['_PUBLICLIMITDEPTHV3APIITEM']._serialized_end=239
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicMiniTickersV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicMiniTickersV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicMiniTickersV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import PublicMiniTickerV3Api_pb2 as PublicMiniTickerV3Api__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1cPublicMiniTickersV3Api.proto\x1a\x1bPublicMiniTickerV3Api.proto\"?\n\x16PublicMiniTickersV3Api\x12%\n\x05items\x18\x01 \x03(\x0b\x32\x16.PublicMiniTickerV3ApiB?\n\x1c\x63om.mxc.push.common.protobufB\x1bPublicMiniTickersV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicMiniTickersV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\033PublicMiniTickersV3ApiProtoH\001P\001'
  _globals['_PUBLICMINITICKERSV3API']._serialized_start=61
  _globals['_PUBLICMINITICKERSV3API']._serialized_end=124
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicMiniTickerV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicMiniTickerV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicMiniTickerV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1bPublicMiniTickerV3Api.proto\"\xf4\x01\n\x15PublicMiniTickerV3Api\x12\x0e\n\x06symbol\x18\x01 \x01(\t\x12\r\n\x05price\x18\x02 \x01(\t\x12\x0c\n\x04rate\x18\x03 \x01(\t\x12\x11\n\tzonedRate\x18\x04 \x01(\t\x12\x0c\n\x04high\x18\x05 \x01(\t\x12\x0b\n\x03low\x18\x06 \x01(\t\x12\x0e\n\x06volume\x18\x07 \x01(\t\x12\x10\n\x08quantity\x18\x08 \x01(\t\x12\x15\n\rlastCloseRate\x18\t \x01(\t\x12\x1a\n\x12lastCloseZonedRate\x18\n \x01(\t\x12\x15\n\rlastCloseHigh\x18\x0b \x01(\t\x12\x14\n\x0clastCloseLow\x18\x0c \x01(\tB>\n\x1c\x63om.mxc.push.common.protobufB\x1aPublicMiniTickerV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicMiniTickerV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\032PublicMiniTickerV3ApiProtoH\001P\001'
  _globals['_PUBLICMINITICKERV3API']._serialized_start=32
  _globals['_PUBLICMINITICKERV3API']._serialized_end=276
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicSpotKlineV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicSpotKlineV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicSpotKlineV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1aPublicSpotKlineV3Api.proto\"\xc7\x01\n\x14PublicSpotKlineV3Api\x12\x10\n\x08interval\x18\x01 \x01(\t\x12\x13\n\x0bwindowStart\x18\x02 \x01(\x03\x12\x14\n\x0copeningPrice\x18\x03 \x01(\t\x12\x14\n\x0c\x63losingPrice\x18\x04 \x01(\t\x12\x14\n\x0chighestPrice\x18\x05 \x01(\t\x12\x13\n\x0blowestPrice\x18\x06 \x01(\t\x12\x0e\n\x06volume\x18\x07 \x01(\t\x12\x0e\n\x06\x61mount\x18\x08 \x01(\t\x12\x11\n\twindowEnd\x18\t \x01(\x03\x42=\n\x1c\x63om.mxc.push.common.protobufB\x19PublicSpotKlineV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicSpotKlineV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\031PublicSpotKlineV3ApiProtoH\001P\001'
  _globals['_PUBLICSPOTKLINEV3API']._serialized_start=31
  _globals['_PUBLICSPOTKLINEV3API']._serialized_end=230
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PushDataV3ApiWrapper_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PushDataV3ApiWrapper.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PushDataV3ApiWrapper.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import PublicDealsV3Api_pb2 as PublicDealsV3Api__pb2
import PublicIncreaseDepthsV3Api_pb2 as PublicIncreaseDepthsV3Api__pb2
import PublicLimitDepthsV3Api_pb2 as PublicLimitDepthsV3Api__pb2
import PrivateOrdersV3Api_pb2 as PrivateOrdersV3Api__pb2
import PublicBookTickerV3Api_pb2 as PublicBookTickerV3Api__pb2
import PrivateDealsV3Api_pb2 as PrivateDealsV3Api__pb2
import PrivateAccountV3Api_pb2 as PrivateAccountV3Api__pb2
import PublicSpotKlineV3Api_pb2 as PublicSpotKlineV3Api__pb2
import PublicMiniTickerV3Api_pb2 as PublicMiniTickerV3Api__pb2
import PublicMiniTickersV3Api_pb2 as PublicMiniTickersV3Api__pb2
import PublicBookTickerBatchV3Api_pb2 as PublicBookTickerBatchV3Api__pb2
import PublicIncreaseDepthsBatchV3Api_pb2 as PublicIncreaseDepthsBatchV3Api__pb2
import PublicAggreDepthsV3Api_pb2 as PublicAggreDepthsV3Api__pb2
import PublicAggreDealsV3Api_pb2 as PublicAggreDealsV3Api__pb2
import PublicAggreBookTickerV3Api_pb2 as PublicAggreBookTickerV3Api__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1aPushDataV3ApiWrapper.proto\x1a\x16PublicDealsV3Api.proto\x1a\x1fPublicIncreaseDepthsV3Api.proto\x1a\x1cPublicLimitDepthsV3Api.proto\x1a\x18PrivateOrdersV3Api.proto\x1a\x1bPublicBookTickerV3Api.proto\x1a\x17PrivateDealsV3Api.proto\x1a\x19PrivateAccountV3Api.proto\x1a\x1aPublicSpotKlineV3Api.proto\x1a\x1bPublicMiniTickerV3Api.proto\x1a\x1cPublicMiniTickersV3Api.proto\x1a PublicBookTickerBatchV3Api.proto\x1a$PublicIncreaseDepthsBatchV3Api.proto\x1a\x1cPublicAggreDepthsV3Api.proto\x1a\x1bPublicAggreDealsV3Api.proto\x1a PublicAggreBookTickerV3Api.proto\"\xf0\x07\n\x14PushDataV3ApiWrapper\x12\x0f\n\x07\x63hannel\x18\x01 \x01(\t\x12)\n\x0bpublicDeals\x18\xad\x02 \x01(\x0b\x32\x11.PublicDealsV3ApiH\x00\x12;\n\x14publicIncreaseDepths\x18\xae\x02 \x01(\x0b\x32\x1a.PublicIncreaseDepthsV3ApiH\x00\x12\x35\n\x11publicLimitDepths\x18\xaf\x02 \x01(\x0b\x32\x17.PublicLimitDepthsV3ApiH\x00\x12-\n\rprivateOrders\x18\xb0\x02 \x01(\x0b\x32\x13.PrivateOrdersV3ApiH\x00\x12\x33\n\x10publicBookTicker\x18\xb1\x02 \x01(\x0b\x32\x16.PublicBookTickerV3ApiH\x00\x12+\n\x0cprivateDeals\x18\xb2\x02 \x01(\x0b\x32\x12.PrivateDealsV3ApiH\x00\x12/\n\x0eprivateAccount\x18\xb3\x02 \x01(\x0b\x32\x14.PrivateAccountV3ApiH\x00\x12\x31\n\x0fpublicSpotKline\x18\xb4\x02 \x01(\x0b\x32\x15.PublicSpotKlineV3ApiH\x00\x12\x33\n\x10publicMiniTicker\x18\xb5\x02 \x01(\x0b\x32\x16.PublicMiniTickerV3ApiH\x00\x12\x35\n\x11publicMiniTickers\x18\xb6\x02 \x01(\x0b\x32\x17.PublicMiniTickersV3ApiH\x00\x12=\n\x15publicBookTickerBatch\x18\xb7\x02 \x01(\x0b\x32\x1b.PublicBookTickerBatchV3ApiH\x00\x12\x45\n\x19publicIncreaseDepthsBatch\x18\xb8\x02 \x01(\x0b\x32\x1f.PublicIncreaseDepthsBatchV3ApiH\x00\x12\x35\n\x11publicAggreDepths\x18\xb9\x02 \x01(\x0b\x32\x17.PublicAggreDepthsV3ApiH\x00\x12\x33\n\x10publicAggreDeals\x18\xba\x02 \x01(\x0b\x32\x16.PublicAggreDealsV3ApiH\x00\x12=\n\x15publicAggreBookTicker\x18\xbb\x02 \x01(\x0b\x32\x1b.PublicAggreBookTickerV3ApiH\x00\x12\x13\n\x06symbol\x18\x03 \x01(\tH\x01\x88\x01\x01\x12\x15\n\x08symbolId\x18\x04 \x01(\tH\x02\x88\x01\x01\x12\x17\n\ncreateTime\x18\x05 \x01(\x03H\x03\x88\x01\x01\x12\x15\n\x08sendTime\x18\x06 \x01(\x03H\x04\x88\x01\x01\x42\x06\n\x04\x62odyB\t\n\x07_symbolB\x0b\n\t_symbolIdB\r\n\x0b_createTimeB\x0b\n\t_sendTimeB=\n\x1c\x63om.mxc.push.common.protobufB\x19PushDataV3ApiWrapperProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PushDataV3ApiWrapper_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\031PushDataV3ApiWrapperProtoH\001P\001'
  _globals['_PUSHDATAV3APIWRAPPER']._serialized_start=477
  _globals['_PUSHDATAV3APIWRAPPER']._serialized_end=1485
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/__init__.py">
"""Protocol buffer definitions for MEXC WebSocket APIs."""
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/__init__.py">
# QRL/USDT dedicated infrastructure components
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/qrl_settings.py">
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class QrlSettings(MexcSettings):
    """Alias for QRL-only flows; reuses general MEXC credentials."""

    @property
    def symbol(self) -> str:
        return "QRLUSDT"
</file>

<file path="src/app/infrastructure/exchange/mexc/ws_client.py">
"""
MEXC WebSocket client placeholder.
"""


class MexcWebSocketClient:
    def __init__(self):
        # TODO: inject ws transport and serializer
        pass

    # TODO: methods to subscribe to ticker, depth, trades channels
</file>

<file path="src/app/infrastructure/exchange/mexc/ws/__init__.py">
from .mexc_ws_client import MexcWebSocketClient

__all__ = ["MexcWebSocketClient"]
</file>

<file path="src/app/infrastructure/exchange/mexc/ws/mexc_ws_client.py">
from typing import AsyncIterator, Optional


class MexcWebSocketClient:
    """
    Thin wrapper over MEXC V3 WebSocket transport.

    This class is intentionally minimal; transport details (auth, ping/pong,
    reconnect) can be layered later without leaking into Domain/Application.
    """

    async def subscribe(
        self, channel: str, symbol: Optional[str] = None
    ) -> AsyncIterator[object]:
        """
        Yield raw protobuf messages for the given channel.

        Args:
            channel: MEXC stream channel (e.g., depth, deals, orders).
            symbol: Optional trading pair symbol when required by the stream.
        """
        raise NotImplementedError("WebSocket transport not wired yet.")
</file>

<file path="src/app/infrastructure/external/mexc/__init__.py">
"""MEXC external client placeholders."""
</file>

<file path="src/app/interfaces/__init__.py">
from fastapi import FastAPI

from src.app.interfaces.http.api import (
    account_routes,
    market_routes,
    system_routes,
    trading_routes,
    ws_routes,
)


def register_all_routers(app: FastAPI) -> None:
    """Register all interface routers. Routes contain no business logic."""
    app.include_router(account_routes.router, prefix="/api/account", tags=["account"])
    app.include_router(trading_routes.router, prefix="/api/trading", tags=["trading"])
    app.include_router(market_routes.router, prefix="/api/market", tags=["market"])
    app.include_router(system_routes.router, prefix="/api/system", tags=["system"])
    app.include_router(ws_routes.router, prefix="/ws", tags=["websocket"])
</file>

<file path="src/app/interfaces/http/__init__.py">
"""HTTP interfaces (controllers only)."""
</file>

<file path="src/app/interfaces/http/api/__init__.py">
"""API routers for JSON endpoints."""
</file>

<file path="src/app/interfaces/http/api/account_routes.py">
from fastapi import APIRouter, HTTPException

from src.app.application.account.use_cases.get_balance import GetBalanceUseCase

router = APIRouter()


@router.get("/balance")
async def get_balance():
    """Get subaccount balance for QRL/USDT."""
    usecase = GetBalanceUseCase()
    try:
        return await usecase.execute()
    except Exception as exc:
        # Surface a clear error to the dashboard instead of a generic 500
        raise HTTPException(status_code=502, detail=f"Failed to fetch balance: {exc}") from exc
</file>

<file path="src/app/interfaces/http/api/system_routes.py">
from fastapi import APIRouter

from src.app.application.system.use_cases.get_server_time import GetServerTimeUseCase
from src.app.application.system.use_cases.ping import PingUseCase

router = APIRouter()


@router.get("/ping")
async def ping():
    """Ping endpoint."""
    usecase = PingUseCase()
    return await usecase.execute()


@router.get("/time")
async def get_server_time():
    """Get server time."""
    usecase = GetServerTimeUseCase()
    return await usecase.execute()
</file>

<file path="src/app/interfaces/http/api/trading_api.py">
from fastapi import APIRouter, Query

from src.app.application.trading.use_cases.get_kline import GetKlineUseCase
from src.app.application.trading.use_cases.get_price import GetPriceUseCase


router = APIRouter()


@router.get("/api/price/{symbol}")
async def get_price(symbol: str):
    usecase = GetPriceUseCase()
    return await usecase.execute(symbol)


@router.get("/api/kline/{symbol}/{interval}")
async def get_kline(symbol: str, interval: str, limit: int = Query(default=60, ge=1, le=500)):
    usecase = GetKlineUseCase()
    return await usecase.execute(symbol, interval, limit)
</file>

<file path="src/app/interfaces/http/api/trading_routes.py">
from decimal import Decimal

from fastapi import APIRouter, Query
from src.app.application.trading.use_cases.cancel_order import CancelOrderInput, CancelOrderUseCase
from src.app.application.trading.use_cases.get_order import GetOrderInput, GetOrderUseCase
from src.app.application.trading.use_cases.list_orders import ListOrdersUseCase
from src.app.application.trading.use_cases.list_trades import ListTradesUseCase
from src.app.application.trading.use_cases.place_order import PlaceOrderInput, PlaceOrderUseCase
from src.app.interfaces.http.schemas import (
    PlaceOrderRequest,
)


router = APIRouter()


@router.post("/orders")
async def place_order(request: PlaceOrderRequest):
    """Place spot order for QRL/USDT (subaccount)."""
    usecase = PlaceOrderUseCase()
    data = PlaceOrderInput(
        symbol=request.symbol,
        side=request.side,
        quantity=Decimal(request.quantity),
        price=Decimal(request.price) if request.price is not None else None,
        order_type=request.order_type,
        time_in_force=request.time_in_force if request.time_in_force else "GTC",
        client_order_id=request.client_order_id,
    )
    return await usecase.execute(data)


@router.post("/orders/{order_id}/cancel")
async def cancel_order(order_id: str, symbol: str = Query(default="QRLUSDT")):
    """Cancel an existing order."""
    usecase = CancelOrderUseCase()
    data = CancelOrderInput(symbol=symbol, order_id=order_id, client_order_id=None)
    return await usecase.execute(data)


@router.get("/orders/{order_id}")
async def get_order(order_id: str, symbol: str = Query(default="QRLUSDT")):
    """Get order status."""
    usecase = GetOrderUseCase()
    data = GetOrderInput(symbol=symbol, order_id=order_id, client_order_id=None)
    return await usecase.execute(data)


@router.get("/orders")
async def list_orders(symbol: str = Query(default="QRLUSDT")):
    """List recent orders."""
    usecase = ListOrdersUseCase()
    return await usecase.execute(symbol=symbol)


@router.get("/trades")
async def list_trades(symbol: str = Query(default="QRLUSDT")):
    """List recent trades."""
    usecase = ListTradesUseCase()
    return await usecase.execute(symbol)
</file>

<file path="src/app/interfaces/http/api/ws_routes.py">
from fastapi import APIRouter, WebSocket

from src.app.application.market.use_cases.get_ticker import GetTickerUseCase
from src.app.application.trading.use_cases.list_orders import ListOrdersUseCase

router = APIRouter()


@router.websocket("/market/ticker")
async def ticker_stream(websocket: WebSocket):
    """WebSocket ticker stream placeholder."""
    await websocket.accept()
    usecase = GetTickerUseCase()
    await usecase.execute()  # TODO: stream data
    await websocket.close()


@router.websocket("/trading/orders")
async def order_stream(websocket: WebSocket):
    """WebSocket order stream placeholder."""
    await websocket.accept()
    usecase = ListOrdersUseCase()
    await usecase.execute()  # TODO: stream data
    await websocket.close()
</file>

<file path="src/app/interfaces/http/dependencies.py">
"""FastAPI dependencies for interface layer."""

# TODO: add shared dependencies (auth, DB session, exchange client providers)
</file>

<file path="src/app/interfaces/http/pages/__init__.py">
"""HTML page controllers."""
</file>

<file path="src/app/interfaces/tasks/__init__.py">
"""Task interfaces placeholder."""
</file>

<file path="src/app/interfaces/tasks/market_tasks.py">
"""Market-related scheduled tasks placeholder."""


async def refresh_ticker():
    """Placeholder for refreshing ticker cache."""
    return None
</file>

<file path="src/app/interfaces/tasks/system_tasks.py">
"""System-related scheduled tasks placeholder."""


async def health_check():
    """Placeholder for system health checks."""
    return None
</file>

<file path="src/app/interfaces/tasks/trading_tasks.py">
"""Trading-related scheduled tasks placeholder."""


async def sync_orders():
    """Placeholder for syncing orders."""
    return None


async def sync_trades():
    """Placeholder for syncing trades."""
    return None
</file>

<file path="src/app/application/account/use_cases/get_balance.py">
"""Account use case: get subaccount balance with valuation."""

from dataclasses import dataclass
from decimal import Decimal

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.domain.entities.account import Account
from src.app.domain.services.valuation_service import ValuationService
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _mid(price: Price) -> Decimal:
    return (price.bid + price.ask) / Decimal("2")


def _aggregate_balances(account: Account) -> dict:
    usdt_free = usdt_locked = Decimal("0")
    qrl_free = qrl_locked = Decimal("0")
    for balance in account.balances:
        asset = balance.asset.upper()
        if asset == "USDT":
            usdt_free += balance.free
            usdt_locked += balance.locked
        elif asset == "QRL":
            qrl_free += balance.free
            qrl_locked += balance.locked
    return {
        "usdt_free": usdt_free,
        "usdt_locked": usdt_locked,
        "qrl_free": qrl_free,
        "qrl_locked": qrl_locked,
    }


def _valuation(agg: dict, mid_price: Decimal | None) -> dict:
    usdt_total = agg["usdt_free"] + agg["usdt_locked"]
    if mid_price is None:
        return {
            "price_available": False,
            "price_mid": None,
            "qrl_available_value": None,
            "qrl_locked_value": None,
            "qrl_value_usdt": None,
            "total_value_usdt": None,
            "qrl_pct": None,
            "usdt_pct": None,
        }

    qrl_available_value = ValuationService.value(agg["qrl_free"], mid_price)
    qrl_locked_value = ValuationService.value(agg["qrl_locked"], mid_price)
    qrl_value = qrl_available_value + qrl_locked_value
    total_value = qrl_value + usdt_total

    if total_value > 0:
        qrl_pct = (qrl_value / total_value) * Decimal("100")
        usdt_pct = (usdt_total / total_value) * Decimal("100")
    else:
        qrl_pct = None
        usdt_pct = None

    return {
        "price_available": True,
        "price_mid": str(mid_price),
        "qrl_available_value": str(qrl_available_value),
        "qrl_locked_value": str(qrl_locked_value),
        "qrl_value_usdt": str(qrl_value),
        "total_value_usdt": str(total_value),
        "qrl_pct": str(qrl_pct) if qrl_pct is not None else None,
        "usdt_pct": str(usdt_pct) if usdt_pct is not None else None,
    }


def _serialize_account(account: Account, valuation: dict) -> dict:
    return {
        "can_trade": account.can_trade,
        "update_time": account.update_time.value.isoformat(),
        "balances": [
            {
                "asset": balance.asset,
                "free": str(balance.free),
                "locked": str(balance.locked),
                "free_value_usdt": (
                    valuation["qrl_available_value"] if balance.asset.upper() == "QRL" else None
                ),
                "locked_value_usdt": (
                    valuation["qrl_locked_value"] if balance.asset.upper() == "QRL" else None
                ),
            }
            for balance in account.balances
        ],
        "valuation": valuation,
    }


@dataclass
class GetBalanceUseCase:
    settings: MexcSettings | None = None

    async def execute(self) -> dict:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            account = await svc.get_account()
            try:
                price = await svc.get_price(Symbol("QRLUSDT"))
                mid = _mid(price)
            except Exception:
                price = None
                mid = None

        agg = _aggregate_balances(account)
        valuation = _valuation(agg, mid)
        return _serialize_account(account, valuation)
</file>

<file path="src/app/application/exchange/mexc_service.py">
from dataclasses import dataclass
from decimal import Decimal
from typing import Iterable

from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.order_book import OrderBook
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.infrastructure.exchange.mexc.mappers import (
    account_from_api,
    order_book_from_api,
    order_from_api,
    server_time_to_timestamp,
    trade_from_api,
)
from src.app.infrastructure.exchange.mexc.rest_client import MexcRestClient
from src.app.infrastructure.exchange.mexc_api_client import MexcApiClient
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _to_str(value: Decimal | None) -> str | None:
    return str(value) if value is not None else None


def _symbol_value(symbol: Symbol) -> str:
    return symbol.value.replace("/", "").upper()


@dataclass
class PlaceOrderRequest:
    symbol: Symbol
    side: Side
    order_type: OrderType
    quantity: Quantity
    price: Price | None = None
    time_in_force: TimeInForce | None = None
    client_order_id: str | None = None


@dataclass
class CancelOrderRequest:
    symbol: Symbol
    order_id: str | None = None
    client_order_id: str | None = None


@dataclass
class GetOrderRequest:
    symbol: Symbol
    order_id: str | None = None
    client_order_id: str | None = None


class MexcService:
    """Application-level service that wraps the MEXC REST client."""

    def __init__(self, rest_client: MexcRestClient):
        self._rest_client = rest_client
        self._api_client = MexcApiClient(rest_client)

    async def __aenter__(self) -> "MexcService":
        await self._api_client.__aenter__()
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self._api_client.__aexit__(exc_type, exc, tb)

    async def get_server_time(self) -> Timestamp:
        payload = await self._rest_client.get_server_time()
        return server_time_to_timestamp(payload)

    async def get_account(self) -> Account:
        payload = await self._rest_client.get_account()
        return account_from_api(payload)

    async def place_order(self, request: PlaceOrderRequest) -> Order:
        if request.order_type.value == "LIMIT" and request.price is None:
            raise ValueError("Limit orders require price")
        payload = {
            "symbol": _symbol_value(request.symbol),
            "side": request.side.value,
            "order_type": request.order_type.value,
            "quantity": _to_str(request.quantity.value),
            "price": _to_str(request.price.last) if request.price else None,
            "time_in_force": request.time_in_force.value if request.time_in_force else None,
            "client_order_id": request.client_order_id,
        }
        response = await self._rest_client.create_order(**payload)
        return order_from_api(response)

    async def cancel_order(self, request: CancelOrderRequest) -> Order:
        response = await self._rest_client.cancel_order(
            symbol=_symbol_value(request.symbol),
            order_id=request.order_id,
            client_order_id=request.client_order_id,
        )
        return order_from_api(response)

    async def get_order(self, request: GetOrderRequest) -> Order:
        response = await self._rest_client.get_order(
            symbol=_symbol_value(request.symbol),
            order_id=request.order_id,
            client_order_id=request.client_order_id,
        )
        return order_from_api(response)

    async def list_open_orders(self, symbol: Symbol | None = None) -> list[Order]:
        response = await self._rest_client.list_open_orders(
            symbol=_symbol_value(symbol) if symbol else None
        )
        return [order_from_api(item) for item in response]

    async def list_trades(self, symbol: Symbol) -> list[Trade]:
        response = await self._rest_client.list_trades(symbol=_symbol_value(symbol))
        return [trade_from_api(item) for item in response]

    async def get_price(self, symbol: Symbol) -> Price:
        from src.app.domain.entities.trading_pair import TradingPair

        base = symbol.value.replace("/", "").upper().removesuffix("USDT")
        tp = TradingPair(base_currency=base, quote_currency="USDT")
        return await self._api_client.get_price(tp)

    async def get_kline(self, symbol: Symbol, interval: str, limit: int = 100) -> list["KLine"]:
        from src.app.domain.entities.trading_pair import TradingPair
        from src.app.domain.value_objects.kline import KLine

        base = symbol.value.replace("/", "").upper().removesuffix("USDT")
        tp = TradingPair(base_currency=base, quote_currency="USDT")
        return await self._api_client.get_klines(tp, interval=interval, limit=limit)

    async def get_depth(self, symbol: Symbol, limit: int = 50) -> OrderBook:
        response = await self._rest_client.depth(symbol=_symbol_value(symbol), limit=limit)
        return order_book_from_api(response)


def build_mexc_service(settings: MexcSettings) -> MexcService:
    """Factory to build a service with shared settings."""
    return MexcService(MexcRestClient(settings))
</file>

<file path="src/app/application/market/qrl/get_qrl_price.py">
from dataclasses import asdict, dataclass
from typing import Any

from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


@dataclass(frozen=True)
class QrlPriceSnapshot:
    bid: str | None
    ask: str | None
    last: str
    timestamp: int | None

    def to_dict(self) -> dict[str, Any]:
        return asdict(self)


class GetQrlPrice:
    """Fetch QRL/USDT price using the dedicated REST client."""

    def __init__(self, rest_client: QrlRestClient):
        self._client = rest_client

    async def execute(self) -> QrlPriceSnapshot:
        async with self._client as client:
            ticker = await client.ticker_24h()
        bid = ticker.get("bidPrice") or ticker.get("bid")
        ask = ticker.get("askPrice") or ticker.get("ask")
        last = ticker.get("lastPrice") or ticker.get("last")
        if last is None:
            raise ValueError("QRL price unavailable")
        price_vo = QrlPrice(last)
        timestamp = (
            ticker.get("time")
            or ticker.get("timestamp")
            or ticker.get("closeTime")
            or ticker.get("t")  # some SDKs return shorthand
        )
        return QrlPriceSnapshot(
            bid=str(bid) if bid is not None else None,
            ask=str(ask) if ask is not None else None,
            last=str(price_vo.value),
            timestamp=timestamp,
        )
</file>

<file path="src/app/application/trading/dtos.py">
from dataclasses import asdict, dataclass


@dataclass(frozen=True)
class OrderDTO:
    order_id: str
    symbol: str
    side: str
    type: str
    status: str
    price: str | None
    quantity: str
    executed_quantity: str | None
    cumulative_quote_quantity: str | None
    client_order_id: str | None
    created_at: str
    updated_at: str | None
    time_in_force: str | None = None

    def to_dict(self) -> dict:
        return asdict(self)


@dataclass(frozen=True)
class TradeDTO:
    trade_id: str
    order_id: str
    symbol: str
    side: str
    price: str
    quantity: str
    fee: str | None
    fee_asset: str | None
    timestamp: str

    def to_dict(self) -> dict:
        return asdict(self)
</file>

<file path="src/app/domain/aggregates/__init__.py">
"""Domain aggregates for the QRL/USDT trading context."""

from src.app.domain.aggregates.account_state import AccountState
from src.app.domain.aggregates.market_snapshot import MarketSnapshot
from src.app.domain.aggregates.trading_session import TradingSession

__all__ = ["AccountState", "MarketSnapshot", "TradingSession"]
</file>

<file path="src/app/domain/aggregates/account_state.py">
from dataclasses import dataclass, field

from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class AccountState:
    """Aggregate for account balances and outstanding orders."""

    symbol: Symbol
    account: Account
    open_orders: list[Order] = field(default_factory=list)
    updated_at: Timestamp | None = None
</file>

<file path="src/app/domain/aggregates/market_snapshot.py">
from dataclasses import dataclass, field

from src.app.domain.entities.order_book_level import OrderBookLevel
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class MarketSnapshot:
    """Combined market view for depth, trades, and ticker."""

    symbol: Symbol
    bids: list[OrderBookLevel] = field(default_factory=list)
    asks: list[OrderBookLevel] = field(default_factory=list)
    trades: list[Trade] = field(default_factory=list)
    ticker: Ticker | None = None
    updated_at: Timestamp | None = None
</file>

<file path="src/app/domain/aggregates/trading_session.py">
from dataclasses import dataclass, field

from src.app.domain.entities.order import Order
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class TradingSession:
    """Session-level aggregate for managing open and historical activity."""

    symbol: Symbol
    open_orders: list[Order] = field(default_factory=list)
    trades: list[Trade] = field(default_factory=list)
    started_at: Timestamp | None = None
    last_activity_at: Timestamp | None = None
</file>

<file path="src/app/domain/entities/__init__.py">
"""Domain entities for QRL/USDT spot trading."""

from src.app.domain.entities.account import Account
from src.app.domain.entities.kline import Kline
from src.app.domain.entities.order import Order
from src.app.domain.entities.order_book_level import OrderBookLevel
from src.app.domain.entities.trade import Trade

__all__ = ["Account", "Kline", "Order", "OrderBookLevel", "Trade"]
</file>

<file path="src/app/domain/entities/kline.py">
from dataclasses import dataclass
from decimal import Decimal

from src.app.domain.value_objects.kline_interval import KlineInterval
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class Kline:
    """Kline entity for QRL/USDT spot."""

    symbol: Symbol
    interval: KlineInterval
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    open_time: Timestamp
    close_time: Timestamp | None = None
</file>

<file path="src/app/domain/entities/order_book_level.py">
from dataclasses import dataclass
from decimal import Decimal

from src.app.domain.value_objects.order_side import OrderSide


@dataclass
class OrderBookLevel:
    """Single depth level for the QRL/USDT order book."""

    price: Decimal
    quantity: Decimal
    side: OrderSide
</file>

<file path="src/app/domain/entities/order.py">
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal

from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.qrl_price import QrlPrice


@dataclass
class Order:
    """Order entity limited to QRL/USDT spot."""

    order_id: OrderId
    symbol: Symbol
    side: Side
    order_type: OrderType
    status: OrderStatus
    price: QrlPrice | None
    quantity: Quantity
    created_at: Timestamp
    time_in_force: TimeInForce | None = None
    client_order_id: str | None = None
    executed_quantity: Decimal | None = None
    cumulative_quote_quantity: Decimal | None = None
    updated_at: Timestamp | None = None
</file>

<file path="src/app/domain/entities/trade.py">
from dataclasses import dataclass
from decimal import Decimal

from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId
from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.quantity import Quantity


@dataclass
class Trade:
    """Trade fill record."""

    trade_id: TradeId
    order_id: OrderId
    symbol: Symbol
    side: Side
    price: QrlPrice
    quantity: Quantity
    fee: Decimal | None
    fee_asset: str | None
    timestamp: Timestamp
</file>

<file path="src/app/domain/events/__init__.py">
from .balance_event import BalanceEvent
from .market_depth_event import MarketDepthEvent
from .order_event import OrderEvent
from .trade_event import TradeEvent

__all__ = [
    "BalanceEvent",
    "MarketDepthEvent",
    "OrderEvent",
    "TradeEvent",
]
</file>

<file path="src/app/domain/factories/aggregates.py">
from __future__ import annotations

from datetime import datetime, timezone
from typing import Iterable

from src.app.domain.aggregates.account_state import AccountState
from src.app.domain.aggregates.market_snapshot import MarketSnapshot
from src.app.domain.aggregates.trading_session import TradingSession
from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.entities.order_book_level import OrderBookLevel
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker
from src.app.domain.value_objects.timestamp import Timestamp


def _ts_now() -> Timestamp:
    return Timestamp(datetime.now(timezone.utc))


def build_account_state(
    *, symbol: Symbol, account: Account, open_orders: Iterable[Order] = ()
) -> AccountState:
    return AccountState(
        symbol=symbol,
        account=account,
        open_orders=list(open_orders),
        updated_at=_ts_now(),
    )


def build_trading_session(
    *, symbol: Symbol, orders: Iterable[Order] = (), trades: Iterable[Trade] = ()
) -> TradingSession:
    now = _ts_now()
    return TradingSession(
        symbol=symbol,
        open_orders=list(orders),
        trades=list(trades),
        started_at=now,
        last_activity_at=now,
    )


def build_market_snapshot(
    *,
    symbol: Symbol,
    bids: Iterable[OrderBookLevel] = (),
    asks: Iterable[OrderBookLevel] = (),
    trades: Iterable[Trade] = (),
    ticker: Ticker | None = None,
) -> MarketSnapshot:
    return MarketSnapshot(
        symbol=symbol,
        bids=list(bids),
        asks=list(asks),
        trades=list(trades),
        ticker=ticker,
        updated_at=_ts_now(),
    )
</file>

<file path="src/app/domain/services/__init__.py">
"""Domain services for allocation and depth analysis."""
</file>

<file path="src/app/domain/services/valuation_service.py">
from decimal import Decimal


class ValuationService:
    """Compute position values given a quantity and a unit price."""

    @staticmethod
    def value(quantity: Decimal, unit_price: Decimal) -> Decimal:
        if quantity < 0:
            raise ValueError("Quantity cannot be negative")
        if unit_price <= 0:
            raise ValueError("Unit price must be positive")
        return quantity * unit_price
</file>

<file path="src/app/domain/value_objects/__init__.py">
"""Domain Value Objects for QRL/USDT scope."""

from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.kline_interval import KlineInterval
from src.app.domain.value_objects.order_side import OrderSide
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId
from src.app.domain.value_objects.kline import KLine
from src.app.domain.value_objects.sub_account_id import SubAccountId

__all__ = [
    "OrderId",
    "OrderStatus",
    "OrderSide",
    "KlineInterval",
    "Price",
    "KLine",
    "Quantity",
    "Side",
    "Symbol",
    "Ticker",
    "Timestamp",
    "TradeId",
    "SubAccountId",
]
</file>

<file path="src/app/domain/value_objects/balance_comparison_result.py">
from dataclasses import dataclass
from decimal import Decimal

from src.app.domain.value_objects.side import Side


@dataclass(frozen=True)
class BalanceComparisonResult:
    """Outcome of balance comparison deciding whether to trade."""

    qrl_free: Decimal
    usdt_free: Decimal
    diff: Decimal
    action: str
    preferred_side: Side | None
    reason: str | None = None
</file>

<file path="src/app/domain/value_objects/kline_interval.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class KlineInterval:
    """Supported MEXC spot kline intervals for QRL/USDT."""

    value: str

    _allowed = {
        "1m",
        "5m",
        "15m",
        "30m",
        "1h",
        "4h",
        "1d",
    }

    def __post_init__(self):
        if self.value not in self._allowed:
            raise ValueError(f"KlineInterval must be one of {sorted(self._allowed)}")
</file>

<file path="src/app/domain/value_objects/normalized_balances.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class NormalizedBalances:
    """Normalized balances for QRL and USDT with non-negative constraints."""

    qrl_free: Decimal
    usdt_free: Decimal

    def __post_init__(self) -> None:
        if self.qrl_free < 0 or self.usdt_free < 0:
            raise ValueError("Balances cannot be negative")
</file>

<file path="src/app/domain/value_objects/order_command.py">
from dataclasses import dataclass

from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce


@dataclass(frozen=True)
class OrderCommand:
    """Order parameters selected after allocation analysis."""

    symbol: Symbol
    side: Side
    quantity: Quantity
    price: Price
    time_in_force: TimeInForce
</file>

<file path="src/app/domain/value_objects/order_side.py">
from src.app.domain.value_objects.side import Side


class OrderSide(Side):
    """Alias for Side specific to order semantics."""
</file>

<file path="src/app/domain/value_objects/slippage.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class SlippageAssessment:
    """Result of pre-trade slippage analysis."""

    expected_fill: Decimal
    slippage_pct: Decimal
    is_acceptable: bool
    reason: str | None = None
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/qrl_rest_client.py">
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.rest_client import MexcRestClient
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class QrlRestClient:
    """Wrapper to freeze symbol to QRL/USDT for all REST calls."""

    def __init__(self, settings: MexcSettings):
        self._settings = settings
        self._client = MexcRestClient(settings)

    async def __aenter__(self) -> "QrlRestClient":
        await self._client.__aenter__()
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self._client.__aexit__(exc_type, exc, tb)

    async def ticker_24h(self) -> dict:
        return await self._client.ticker_24h(symbol=QrlUsdtPair.symbol())

    async def klines(self, *, interval: str, limit: int) -> list:
        return await self._client.klines(symbol=QrlUsdtPair.symbol(), interval=interval, limit=limit)

    async def depth(self, *, limit: int = 50) -> dict:
        return await self._client.depth(symbol=QrlUsdtPair.symbol(), limit=limit)

    async def market_trades(self, *, limit: int = 50) -> list:
        return await self._client.trades(symbol=QrlUsdtPair.symbol(), limit=limit)

    async def create_order(
        self,
        *,
        side: str,
        order_type: str,
        quantity: str,
        price: str | None,
        time_in_force: str | None,
        client_order_id: str | None,
    ) -> dict:
        return await self._client.create_order(
            symbol=QrlUsdtPair.symbol(),
            side=side,
            order_type=order_type,
            quantity=quantity,
            price=price,
            time_in_force=time_in_force,
            client_order_id=client_order_id,
        )

    async def get_order(self, *, order_id: str | None, client_order_id: str | None) -> dict:
        return await self._client.get_order(
            symbol=QrlUsdtPair.symbol(), order_id=order_id, client_order_id=client_order_id
        )

    async def cancel_order(self, *, order_id: str | None, client_order_id: str | None) -> dict:
        return await self._client.cancel_order(
            symbol=QrlUsdtPair.symbol(), order_id=order_id, client_order_id=client_order_id
        )
</file>

<file path="src/app/interfaces/http/api/market_routes.py">
from fastapi import APIRouter, Query

from src.app.application.market.use_cases.get_depth import GetDepthUseCase
from src.app.application.market.use_cases.get_kline import GetKlineUseCase
from src.app.application.market.use_cases.get_market_trades import GetMarketTradesInput, GetMarketTradesUseCase
from src.app.application.market.use_cases.get_stats24h import GetStats24hUseCase
from src.app.application.market.use_cases.get_ticker import GetTickerUseCase

router = APIRouter()


@router.get("/depth")
async def get_depth(limit: int = Query(default=50, ge=5, le=1000)):
    """Get order book depth for QRL/USDT."""
    usecase = GetDepthUseCase()
    from src.app.application.market.use_cases.get_depth import GetDepthInput

    return await usecase.execute(data=GetDepthInput(limit=limit))


@router.get("/ticker")
async def get_ticker():
    """Get ticker for QRL/USDT."""
    usecase = GetTickerUseCase()
    return await usecase.execute()


@router.get("/kline")
async def get_kline(interval: str = Query(default="1m"), limit: int = Query(default=50, ge=1, le=500)):
    """Get kline data for QRL/USDT."""
    usecase = GetKlineUseCase()
    from src.app.application.market.use_cases.get_kline import GetKlineInput

    return await usecase.execute(data=GetKlineInput(interval=interval, limit=limit))


@router.get("/stats24h")
async def get_stats_24h():
    """Get 24h statistics for QRL/USDT."""
    usecase = GetStats24hUseCase()
    return await usecase.execute()


@router.get("/trades")
async def get_market_trades(limit: int = Query(default=50, ge=1, le=500)):
    """Get recent public trades for QRL/USDT."""
    usecase = GetMarketTradesUseCase()
    return await usecase.execute(data=GetMarketTradesInput(limit=limit))
</file>

<file path="src/app/interfaces/http/api/qrl_routes.py">
import asyncio
from decimal import Decimal

from fastapi import APIRouter, HTTPException, Query

from src.app.application.market.qrl.get_qrl_depth import GetQrlDepth
from src.app.application.market.qrl.get_qrl_kline import GetQrlKline
from src.app.application.market.qrl.get_qrl_price import GetQrlPrice
from src.app.application.market.use_cases.get_market_trades import GetMarketTradesUseCase
from src.app.application.trading.qrl.cancel_qrl_order import CancelQrlOrder
from src.app.application.trading.qrl.get_qrl_order import GetQrlOrder
from src.app.application.trading.qrl.place_qrl_order import PlaceQrlOrder
from src.app.application.account.use_cases.get_balance import GetBalanceUseCase
from src.app.application.trading.use_cases.list_orders import ListOrdersUseCase
from src.app.application.trading.use_cases.list_trades import ListTradesUseCase
from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.qrl_quantity import QrlQuantity
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings
from src.app.interfaces.http.schemas import PlaceOrderRequest

router = APIRouter()


def _client() -> QrlRestClient:
    return QrlRestClient(QrlSettings())


@router.get("/price")
async def qrl_price():
    usecase = GetQrlPrice(_client())
    try:
        snapshot = await usecase.execute()
        return snapshot.to_dict()
    except Exception as exc:
        raise HTTPException(status_code=502, detail=f"Failed to fetch QRL price: {exc}") from exc


@router.get("/kline")
async def qrl_kline(interval: str = Query(default="1m"), limit: int = Query(default=50, ge=1, le=500)):
    usecase = GetQrlKline(_client(), interval=interval, limit=limit)
    try:
        raw = await usecase.execute()
        normalized = [
            {"timestamp": item[0], "open": item[1], "high": item[2], "low": item[3], "close": item[4], "volume": item[5]}
            for item in raw
        ]
        return normalized
    except Exception as exc:
        raise HTTPException(status_code=502, detail=f"Failed to fetch QRL klines: {exc}") from exc


@router.get("/depth")
async def qrl_depth(limit: int = Query(default=50, ge=5, le=1000)):
    usecase = GetQrlDepth(_client(), limit=limit)
    try:
        return await usecase.execute()
    except Exception as exc:
        raise HTTPException(status_code=502, detail=f"Failed to fetch QRL depth: {exc}") from exc


@router.post("/orders")
async def qrl_place_order(request: PlaceOrderRequest):
    usecase = PlaceQrlOrder(_client())
    price_vo = QrlPrice(request.price) if request.price is not None else None
    qty_vo = QrlQuantity(request.quantity)
    return await usecase.execute(
        side=request.side,
        order_type=request.order_type,
        price=price_vo,
        quantity=qty_vo,
        time_in_force=request.time_in_force,
        client_order_id=request.client_order_id,
    )


@router.post("/orders/{order_id}/cancel")
async def qrl_cancel_order(order_id: str):
    usecase = CancelQrlOrder(_client())
    return await usecase.execute(order_id=order_id, client_order_id=None)


@router.get("/orders/{order_id}")
async def qrl_get_order(order_id: str):
    usecase = GetQrlOrder(_client())
    return await usecase.execute(order_id=order_id, client_order_id=None)


@router.get("/summary")
async def qrl_summary(
    interval: str = Query(default="1m"),
    kline_limit: int = Query(default=50, ge=1, le=500),
    depth_limit: int = Query(default=50, ge=5, le=1000),
    trades_limit: int = Query(default=50, ge=1, le=500),
):
    """Aggregate price, kline, depth, and balance for dashboard consumption."""
    price_uc = GetQrlPrice(_client())
    kline_uc = GetQrlKline(_client(), interval=interval, limit=kline_limit)
    depth_uc = GetQrlDepth(_client(), limit=depth_limit)
    balance_uc = GetBalanceUseCase()
    orders_uc = ListOrdersUseCase()
    trades_uc = ListTradesUseCase()
    market_trades_uc = GetMarketTradesUseCase()

    price_result, kline_result, depth_result, balance_result, orders, trades, market_trades = await asyncio.gather(
        price_uc.execute(),
        kline_uc.execute(),
        depth_uc.execute(),
        balance_uc.execute(),
        orders_uc.execute(symbol="QRLUSDT"),
        trades_uc.execute("QRLUSDT"),
        market_trades_uc.execute(),
    )

    normalized_klines = [
        {"timestamp": item[0], "open": item[1], "high": item[2], "low": item[3], "close": item[4], "volume": item[5]}
        for item in kline_result
    ]
    return {
        "price": price_result.to_dict(),
        "klines": normalized_klines,
        "depth": depth_result,
        "balance": balance_result,
        "orders": orders,
        "trades": trades,
        "market_trades": market_trades[:trades_limit],
    }
</file>

<file path="src/app/interfaces/http/pages/dashboard_routes.py">
from pathlib import Path
from typing import Any

from fastapi import APIRouter, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

router = APIRouter()
templates = Jinja2Templates(directory=str(Path(__file__).parent / "templates"))


def _dashboard_config() -> dict[str, Any]:
    return {
        "price_url": "/api/qrl/price",
        "kline_url": "/api/qrl/kline?interval=1m&limit=50",
        "order_url": "/api/qrl/orders",
        "balance_url": "/api/account/balance",
        "depth_url": "/api/market/depth?limit=20",
        "trades_url": "/api/market/trades?limit=50",
        "orders_url": "/api/trading/orders",
        "refresh_ms": 10_000,
    }


@router.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request) -> HTMLResponse:
    """Serve the trading dashboard page."""
    return templates.TemplateResponse(
        "dashboard/index.html",
        {"request": request, "dashboard_config": _dashboard_config()},
    )
</file>

<file path="src/app/interfaces/http/pages/static/js/application/dashboard.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/core/chart.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/core/dom.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/core/http.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/domain/depth.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/domain/price.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/domain/trade.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/pages/dashboard-config.js">
(() => {
  const el = document.getElementById("dashboard-config");
  let data = {};
  if (el) {
    try {
      data = JSON.parse(el.textContent || "{}");
    } catch (err) {
      console.error("Invalid dashboard config", err);
    }
  }

  window.dashboardConfig = {
    priceUrl: data.price_url || "/api/qrl/price",
    klineUrl: data.kline_url || "/api/qrl/kline?interval=1m&limit=50",
    orderUrl: data.order_url || "/api/qrl/orders",
    balanceUrl: data.balance_url || "/api/account/balance",
    depthUrl: data.depth_url || "/api/market/depth?limit=20",
    tradesUrl: data.trades_url || "/api/market/trades?limit=50",
    ordersUrl: data.orders_url || "/api/trading/orders",
    refreshMs: data.refresh_ms || 10000,
  };
})();
</file>

<file path="main.py">
"""Entrypoint module for the FastAPI application."""

import asyncio
import os
import sys
from pathlib import Path

try:
    from dotenv import load_dotenv
except ModuleNotFoundError:  # pragma: no cover - optional in production images
    def load_dotenv() -> None:  # type: ignore
        return None

from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
import uvicorn

# Ensure src is on sys.path when running `python main.py` directly (e.g., Cloud Run, local)
ROOT = Path(__file__).parent
SRC = ROOT / "src"
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))
if SRC.exists() and str(SRC) not in sys.path:
    sys.path.append(str(SRC))

from src.app.interfaces.http.api import account_routes, market_routes, system_routes, tasks_routes, trading_routes, ws_routes
from src.app.interfaces.http.api import qrl_routes, trading_api
from src.app.interfaces.http.pages import dashboard_routes
from src.app.application.exchange.mexc_service import MexcService
from src.app.infrastructure.exchange.mexc.rest_client import MexcRestClient
from src.app.infrastructure.exchange.mexc.settings import MexcSettings

load_dotenv()


def create_app() -> FastAPI:
    """Create and configure the FastAPI application."""
    app = FastAPI(
        title="QRL/USDT Trading Bot",
        version="0.1.0",
    )

    static_dir = Path(__file__).parent / "src" / "app" / "interfaces" / "http" / "pages" / "static"
    if static_dir.exists():
        app.mount("/static", StaticFiles(directory=static_dir), name="static")

    app.include_router(account_routes.router, prefix="/api/account", tags=["account"])
    app.include_router(market_routes.router, prefix="/api/market", tags=["market"])
    app.include_router(system_routes.router, prefix="/api/system", tags=["system"])
    app.include_router(trading_routes.router, prefix="/api/trading", tags=["trading"])
    app.include_router(qrl_routes.router, prefix="/api/qrl", tags=["qrl"])
    app.include_router(trading_api.router, tags=["price"])
    app.include_router(ws_routes.router, prefix="/ws", tags=["ws"])
    app.include_router(tasks_routes.router, prefix="/tasks", tags=["tasks"])
    app.include_router(tasks_routes.api_router, prefix="/api/tasks", tags=["tasks"])
    app.include_router(dashboard_routes.router, tags=["pages"])
    app.get("/", response_class=dashboard_routes.HTMLResponse)(dashboard_routes.dashboard)

    @app.get("/health", tags=["system"])
    async def health() -> dict[str, str]:
        """Health check endpoint used by deployment probes."""
        return {"status": "ok"}

    return app


app = create_app()


async def _demo_mexc_usage() -> None:
    """Demonstrate how to initialize the MexcService and call a simple API."""
    try:
        settings = MexcSettings()
    except Exception as exc:  # pragma: no cover - demonstration only
        print(f"[demo] Unable to load MEXC credentials: {exc}")
        return

    async with MexcService(MexcRestClient(settings)) as service:
        server_time = await service.get_server_time()
        print(f"[demo] MEXC server time: {server_time.value.isoformat()}")


def _should_run_demo() -> bool:
    """Gate demo execution behind an opt-in flag."""
    return os.getenv("RUN_MEXC_DEMO", "0") == "1"


def _run_server() -> None:
    """Start the uvicorn server using environment configuration."""
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "8080"))
    uvicorn.run(app, host=host, port=port, reload=False)


if __name__ == "__main__":
    if _should_run_demo():
        asyncio.run(_demo_mexc_usage())
    _run_server()

__all__ = ["app"]
</file>

<file path="src/app/application/trading/use_cases/list_trades.py">
"""Trading use case: list trades for QRL/USDT."""

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.application.trading.dtos import TradeDTO
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _serialize_trade(trade: Trade) -> dict:
    dto = TradeDTO(
        trade_id=trade.trade_id.value,
        order_id=trade.order_id.value,
        symbol=trade.symbol.value,
        side=trade.side.value,
        price=str(trade.price.value),
        quantity=str(trade.quantity.value),
        fee=str(trade.fee) if trade.fee is not None else None,
        fee_asset=trade.fee_asset,
        timestamp=trade.timestamp.value.isoformat(),
    )
    return dto.to_dict()


class ListTradesUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, symbol: str) -> list[dict]:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            trades = await svc.list_trades(Symbol(symbol))
        return [_serialize_trade(trade) for trade in trades]
</file>

<file path="src/app/application/trading/use_cases/place_order.py">
"""Trading use case: place order for QRL/USDT."""

from dataclasses import dataclass
from decimal import Decimal

from src.app.application.exchange.mexc_service import MexcService, PlaceOrderRequest, build_mexc_service
from src.app.application.trading.dtos import OrderDTO
from src.app.domain.entities.order import Order
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _serialize_order(order: Order) -> dict:
    dto = OrderDTO(
        order_id=order.order_id.value,
        symbol=order.symbol.value,
        side=order.side.value,
        type=order.order_type.value,
        status=order.status.value,
        price=str(order.price.value) if order.price else None,
        quantity=str(order.quantity.value),
        executed_quantity=str(order.executed_quantity) if order.executed_quantity else None,
        cumulative_quote_quantity=str(order.cumulative_quote_quantity)
        if order.cumulative_quote_quantity
        else None,
        client_order_id=order.client_order_id,
        created_at=order.created_at.value.isoformat(),
        updated_at=order.updated_at.value.isoformat() if order.updated_at else None,
        time_in_force=order.time_in_force.value if order.time_in_force else None,
    )
    return dto.to_dict()


@dataclass
class PlaceOrderInput:
    symbol: str
    side: str
    quantity: Decimal
    price: Decimal | None
    order_type: str = "LIMIT"
    time_in_force: str = "GTC"
    client_order_id: str | None = None


class PlaceOrderUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, data: PlaceOrderInput) -> dict:
        request = PlaceOrderRequest(
            symbol=Symbol(data.symbol),
            side=Side(data.side),
            order_type=OrderType(data.order_type),
            quantity=Quantity(data.quantity),
            price=Price.from_single(data.price) if data.price is not None else None,
            time_in_force=TimeInForce(data.time_in_force) if data.time_in_force else None,
            client_order_id=data.client_order_id,
        )
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            order = await svc.place_order(request)
        return _serialize_order(order)
</file>

<file path="src/app/domain/services/balance_comparison_rule.py">
from decimal import Decimal

from src.app.domain.value_objects.balance_comparison_result import BalanceComparisonResult
from src.app.domain.value_objects.normalized_balances import NormalizedBalances
from src.app.domain.value_objects.side import Side


class BalanceComparisonRule:
    """Decide whether to trade based on QRL vs USDT free balances."""

    def __init__(self, tolerance: Decimal = Decimal("0.01")):
        self._tolerance = tolerance

    def evaluate(self, balances: NormalizedBalances) -> BalanceComparisonResult:
        diff = balances.qrl_free - balances.usdt_free
        if abs(diff) <= self._tolerance:
            return BalanceComparisonResult(
                qrl_free=balances.qrl_free,
                usdt_free=balances.usdt_free,
                diff=diff,
                action="skip",
                preferred_side=None,
                reason="Balances within tolerance",
            )

        preferred_side = Side("SELL") if diff > 0 else Side("BUY")
        return BalanceComparisonResult(
            qrl_free=balances.qrl_free,
            usdt_free=balances.usdt_free,
            diff=diff,
            action="trade",
            preferred_side=preferred_side,
            reason=None,
        )
</file>

<file path="src/app/domain/services/depth_calculator.py">
from decimal import Decimal

from src.app.domain.value_objects.order_book import OrderBook
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side


class DepthCalculator:
    """Compute executable depth and weighted price for a side and target quantity."""

    def compute(self, book: OrderBook, side: Side, target: Quantity) -> tuple[Decimal, Decimal]:
        if side.value == "BUY":
            sorted_levels = sorted(book.asks, key=lambda lvl: lvl.price)
        else:
            sorted_levels = sorted(book.bids, key=lambda lvl: lvl.price, reverse=True)

        remaining = target.value
        total = Decimal("0")
        filled = Decimal("0")

        for level in sorted_levels:
            if remaining <= 0:
                break
            take = min(level.quantity, remaining)
            total += take * level.price
            filled += take
            remaining -= take

        weighted_price = total / filled if filled > 0 else Decimal("0")
        return filled, weighted_price
</file>

<file path="src/app/domain/services/slippage_analyzer.py">
from decimal import Decimal

from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.slippage import SlippageAssessment


class SlippageAnalyzer:
    """Evaluate slippage against a threshold for the chosen side."""

    def __init__(self, threshold_pct: Decimal):
        if threshold_pct < 0:
            raise ValueError("Slippage threshold must be non-negative")
        self._threshold_pct = threshold_pct

    def assess(
        self,
        *,
        side: Side,
        desired_price: Decimal,
        target_quantity: Quantity,
        fill_quantity: Decimal,
        weighted_price: Decimal,
    ) -> SlippageAssessment:
        if desired_price <= 0:
            raise ValueError("Desired price must be positive")

        if fill_quantity <= 0:
            return SlippageAssessment(
                expected_fill=Decimal("0"),
                slippage_pct=Decimal("0"),
                is_acceptable=False,
                reason="No executable depth",
            )

        if fill_quantity < target_quantity.value:
            return SlippageAssessment(
                expected_fill=fill_quantity,
                slippage_pct=Decimal("0"),
                is_acceptable=False,
                reason="Insufficient depth for target quantity",
            )

        if side.value == "BUY":
            delta = weighted_price - desired_price
        else:
            delta = desired_price - weighted_price
        slippage_pct = (delta / desired_price) * Decimal("100")

        if delta <= 0:
            return SlippageAssessment(
                expected_fill=fill_quantity,
                slippage_pct=slippage_pct,
                is_acceptable=True,
                reason=None,
            )

        is_acceptable = slippage_pct <= self._threshold_pct
        reason = None if is_acceptable else "Slippage exceeds threshold"
        return SlippageAssessment(
            expected_fill=fill_quantity,
            slippage_pct=slippage_pct,
            is_acceptable=is_acceptable,
            reason=reason,
        )
</file>

<file path="src/app/domain/value_objects/order_book.py">
from dataclasses import dataclass, field
from decimal import Decimal


@dataclass(frozen=True)
class DepthLevel:
    """Single price level within an order book side."""

    price: Decimal
    quantity: Decimal

    def __post_init__(self) -> None:
        if self.price <= Decimal("0") or self.quantity <= Decimal("0"):
            raise ValueError("DepthLevel price and quantity must be positive")


@dataclass(frozen=True)
class OrderBookSide:
    """Side indicator for order book traversal."""

    value: str

    def __post_init__(self) -> None:
        if self.value not in ("BID", "ASK"):
            raise ValueError("OrderBookSide must be BID or ASK")


@dataclass(frozen=True)
class OrderBook:
    """Aggregated order book snapshot with bids and asks."""

    bids: list[DepthLevel] = field(default_factory=list)
    asks: list[DepthLevel] = field(default_factory=list)
</file>

<file path="src/app/infrastructure/exchange/mexc/rest_client.py">
import hashlib
import hmac
import time
from typing import Any
from urllib.parse import urlencode

import httpx

from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class MexcRestClient:
    """Async REST client for MEXC spot API v3."""

    def __init__(self, settings: MexcSettings):
        self._settings = settings
        self._client: httpx.AsyncClient | None = None

    async def __aenter__(self) -> "MexcRestClient":
        limits = httpx.Limits(
            max_connections=self._settings.max_connections,
            max_keepalive_connections=self._settings.max_keepalive_connections,
            keepalive_expiry=self._settings.keepalive_expiry,
        )
        self._client = httpx.AsyncClient(
            base_url=self._settings.base_url,
            timeout=httpx.Timeout(self._settings.timeout),
            limits=limits,
        )
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        if self._client:
            await self._client.aclose()
            self._client = None

    def _assert_client(self) -> httpx.AsyncClient:
        if self._client is None:
            raise RuntimeError("MexcRestClient context has not been entered")
        return self._client

    def _signed_params(self, params: dict[str, Any]) -> dict[str, Any]:
        payload = {k: v for k, v in params.items() if v is not None}
        if self._settings.sub_account_mode == "BROKER":
            if self._settings.sub_account_name is not None:
                payload.setdefault("subAccount", self._settings.sub_account_name)
        elif self._settings.sub_account_id is not None:
            payload.setdefault("subAccountId", self._settings.sub_account_id)
        payload.setdefault("timestamp", int(time.time() * 1000))
        payload.setdefault("recvWindow", self._settings.recv_window)
        query = urlencode(payload, doseq=True)
        signature = hmac.new(
            self._settings.api_secret.encode("utf-8"),
            query.encode("utf-8"),
            hashlib.sha256,
        ).hexdigest()
        payload["signature"] = signature
        return payload

    async def _request(
        self, method: str, path: str, params: dict[str, Any] | None = None, signed: bool = False
    ) -> dict[str, Any]:
        client = self._assert_client()
        request_params = self._signed_params(params or {}) if signed else params or {}
        headers = {"X-MEXC-APIKEY": self._settings.api_key} if signed else None
        response = await client.request(method, path, params=request_params, headers=headers)
        response.raise_for_status()
        return response.json()

    async def ping(self) -> dict[str, Any]:
        return await self._request("GET", "/api/v3/ping")

    async def get_server_time(self) -> dict[str, Any]:
        return await self._request("GET", "/api/v3/time")

    async def get_account(self) -> dict[str, Any]:
        return await self._request("GET", "/api/v3/account", signed=True)

    async def create_order(
        self,
        *,
        symbol: str,
        side: str,
        order_type: str,
        quantity: str | None = None,
        price: str | None = None,
        time_in_force: str | None = None,
        client_order_id: str | None = None,
    ) -> dict[str, Any]:
        params: dict[str, Any] = {
            "symbol": symbol,
            "side": side,
            "type": order_type,
            "quantity": quantity,
            "price": price,
            "timeInForce": time_in_force,
            "newClientOrderId": client_order_id,
        }
        return await self._request("POST", "/api/v3/order", params=params, signed=True)

    async def get_order(
        self, *, symbol: str, order_id: str | None = None, client_order_id: str | None = None
    ) -> dict[str, Any]:
        params: dict[str, Any] = {
            "symbol": symbol,
            "orderId": order_id,
            "origClientOrderId": client_order_id,
        }
        return await self._request("GET", "/api/v3/order", params=params, signed=True)

    async def cancel_order(
        self, *, symbol: str, order_id: str | None = None, client_order_id: str | None = None
    ) -> dict[str, Any]:
        params: dict[str, Any] = {
            "symbol": symbol,
            "orderId": order_id,
            "origClientOrderId": client_order_id,
        }
        return await self._request("DELETE", "/api/v3/order", params=params, signed=True)

    async def list_open_orders(self, *, symbol: str | None = None) -> list[dict[str, Any]]:
        params: dict[str, Any] = {"symbol": symbol} if symbol else {}
        result = await self._request("GET", "/api/v3/openOrders", params=params, signed=True)
        if isinstance(result, list):
            return result
        return []

    async def list_trades(self, *, symbol: str, limit: int = 50) -> list[dict[str, Any]]:
        params: dict[str, Any] = {"symbol": symbol, "limit": limit}
        result = await self._request("GET", "/api/v3/myTrades", params=params, signed=True)
        if isinstance(result, list):
            return result
        return []

    async def ticker_24h(self, *, symbol: str) -> dict[str, Any]:
        params = {"symbol": symbol}
        return await self._request("GET", "/api/v3/ticker/24hr", params=params)

    async def klines(self, *, symbol: str, interval: str, limit: int = 100) -> list[list[Any]]:
        params = {"symbol": symbol, "interval": interval, "limit": limit}
        result = await self._request("GET", "/api/v3/klines", params=params)
        if isinstance(result, list):
            return result
        return []

    async def trades(self, *, symbol: str, limit: int = 50) -> list[dict[str, Any]]:
        """Public recent trades."""
        params = {"symbol": symbol, "limit": limit}
        result = await self._request("GET", "/api/v3/trades", params=params)
        if isinstance(result, list):
            return result
        return []

    async def depth(self, *, symbol: str, limit: int = 50) -> dict[str, Any]:
        params: dict[str, Any] = {"symbol": symbol, "limit": limit}
        return await self._request("GET", "/api/v3/depth", params=params)
</file>

<file path="src/app/infrastructure/exchange/mexc/settings.py">
from typing import Literal

from pydantic import Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class MexcSettings(BaseSettings):
    """Configuration for MEXC REST client."""

    api_key: str = Field(alias="MEXC_API_KEY")
    api_secret: str = Field(alias="MEXC_SECRET_KEY")
    base_url: str = Field(default="https://api.mexc.com", alias="MEXC_BASE_URL")
    recv_window: int = Field(default=5000, alias="MEXC_RECV_WINDOW")
    timeout: int = Field(default=10, alias="MEXC_TIMEOUT")
    max_connections: int = Field(default=20, alias="MEXC_MAX_CONNECTIONS", gt=0)
    max_keepalive_connections: int = Field(default=10, alias="MEXC_MAX_KEEPALIVE", gt=0)
    keepalive_expiry: float = Field(default=15.0, alias="MEXC_KEEPALIVE_EXPIRY", gt=0)
    sub_account_mode: Literal["SPOT", "BROKER"] = Field(default="SPOT", alias="SUB_ACCOUNT_MODE")
    sub_account_id: int | str | None = Field(default=None, alias="SUB_ACCOUNT_ID")
    sub_account_name: str | None = Field(default=None, alias="SUB_ACCOUNT_NAME")

    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

    @field_validator("sub_account_mode")
    @classmethod
    def _uppercase_mode(cls, value: str) -> str:
        return value.upper()

    @field_validator("sub_account_id", "sub_account_name")
    @classmethod
    def _empty_to_none(cls, value: str | int | None) -> str | int | None:
        if isinstance(value, str) and value.strip() == "":
            return None
        return value

    @field_validator("api_key", "api_secret")
    @classmethod
    def _strip_whitespace(cls, value: str) -> str:
        cleaned = value.strip()
        if "\n" in cleaned or "\r" in cleaned:
            cleaned = cleaned.replace("\n", "").replace("\r", "")
        return cleaned
</file>

<file path="src/app/interfaces/http/pages/static/js/domain/order.js">
(() => {
  const cancelOrder = async (cfg, orderId) => {
    if (!orderId) throw new Error("orderId required");
    const url = `${cfg.cancelOrderBase || "/api/trading/orders"}/${orderId}/cancel`;
    const resp = await fetch(url, { method: "POST" });
    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) {
      const detail = data.detail || JSON.stringify(data);
      throw new Error(detail);
    }
    return data;
  };

  window.orderDomain = { cancelOrder };
})();
</file>

<file path="src/app/infrastructure/exchange/mexc/factories.py">
"""
Factories to translate MEXC REST/WebSocket DTOs into domain aggregates.

These implementations are intentionally lightweight placeholders. They ensure
that aggregate construction paths are present and wired, while allowing the
future work to enrich the mapping with full business rules.
"""

from datetime import datetime, timezone
from decimal import Decimal
from typing import Iterable, Optional

from src.app.domain.aggregates.account_state import AccountState
from src.app.domain.aggregates.market_snapshot import MarketSnapshot
from src.app.domain.aggregates.trading_session import TradingSession
from src.app.domain.factories.aggregates import (
    build_account_state,
    build_market_snapshot,
    build_trading_session,
)
from src.app.domain.entities.account import Account
from src.app.domain.entities.kline import Kline
from src.app.domain.entities.order import Order
from src.app.domain.entities.order_book_level import OrderBookLevel
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.kline_interval import KlineInterval
from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_side import OrderSide
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId
from src.app.infrastructure.exchange.mexc.generated import (
    PrivateAccountV3Api_pb2,
    PrivateOrdersV3Api_pb2,
    PublicAggreDepthsV3Api_pb2,
    PublicAggreDealsV3Api_pb2,
    PublicBookTickerV3Api_pb2,
    PublicSpotKlineV3Api_pb2,
)


def _default_timestamp() -> Timestamp:
    return Timestamp(datetime.now(timezone.utc))


def _levels_from_depth(
    depth: Optional[PublicAggreDepthsV3Api_pb2.PublicAggreDepthsV3Api],
) -> tuple[list[OrderBookLevel], list[OrderBookLevel]]:
    if depth is None:
        return [], []

    bids = [
        OrderBookLevel(
            price=Decimal(str(item.price)),
            quantity=Decimal(str(item.quantity)),
            side=OrderSide("BUY"),
        )
        for item in getattr(depth, "bids", [])  # type: ignore[attr-defined]
    ]
    asks = [
        OrderBookLevel(
            price=Decimal(str(item.price)),
            quantity=Decimal(str(item.quantity)),
            side=OrderSide("SELL"),
        )
        for item in getattr(depth, "asks", [])  # type: ignore[attr-defined]
    ]
    return bids, asks


def market_snapshot_from_sources(
    symbol: Symbol,
    depth_proto: Optional[PublicAggreDepthsV3Api_pb2.PublicAggreDepthsV3Api] = None,
    trades: Optional[Iterable[Trade]] = None,
    ticker_proto: Optional[PublicBookTickerV3Api_pb2.PublicBookTickerV3Api] = None,
) -> MarketSnapshot:
    """
    Build a MarketSnapshot aggregate from available feed DTOs.

    The function accepts partial data (depth only, depth + trades, etc.) so
    the callers can incrementally enrich the snapshot.
    """

    bids, asks = _levels_from_depth(depth_proto)
    ticker: Ticker | None = None
    if ticker_proto is not None:
        bid = Decimal(str(getattr(ticker_proto, "bidPrice", 0)))
        ask = Decimal(str(getattr(ticker_proto, "askPrice", 0)))
        last = Decimal(str(getattr(ticker_proto, "lastPrice", 0)))
        if bid > 0 and ask > 0 and last > 0:
            ticker = Ticker(
                symbol=symbol,
                last_price=last,
                bid_price=bid,
                ask_price=ask,
                ts=_default_timestamp().value,
            )

    return build_market_snapshot(
        symbol=symbol,
        bids=bids,
        asks=asks,
        trades=list(trades or []),
        ticker=ticker,
    )


def account_state_from_proto(
    symbol: Symbol, account_proto: PrivateAccountV3Api_pb2.PrivateAccountV3Api
) -> AccountState:
    """
    Translate private account snapshot DTO into AccountState aggregate.

    Balance parsing is intentionally minimal; further normalization can be
    implemented when business rules are ready.
    """

    balances: list[Balance] = []
    for item in getattr(account_proto, "balances", []):  # type: ignore[attr-defined]
        balances.append(
            Balance(
                asset=getattr(item, "asset", ""),
                free=Decimal(str(getattr(item, "free", 0))),
                locked=Decimal(str(getattr(item, "locked", 0))),
            )
        )

    account = Account(
        can_trade=bool(getattr(account_proto, "canTrade", True)),
        update_time=_default_timestamp(),
        balances=balances,
    )
    return build_account_state(symbol=symbol, account=account, open_orders=[])


def trading_session_from_orders(
    symbol: Symbol, orders: Optional[Iterable[Order]] = None, trades: Optional[Iterable[Trade]] = None
) -> TradingSession:
    """Create a TradingSession aggregate from existing order/trade records."""

    return build_trading_session(symbol=symbol, orders=orders or [], trades=trades or [])


def trades_from_public_proto(
    symbol: Symbol, deals_proto: Optional[PublicAggreDealsV3Api_pb2.PublicAggreDealsV3Api] = None
) -> list[Trade]:
    """Convert public trades DTO to domain trades (skeleton mapping)."""

    if deals_proto is None:
        return []

    trades: list[Trade] = []
    for item in getattr(deals_proto, "deals", []):  # type: ignore[attr-defined]
        trade_id_str = str(getattr(item, "tradeId", "0"))
        order_id_str = str(getattr(item, "orderId", "0"))
        trades.append(
            Trade(
                trade_id=TradeId(trade_id_str),
                order_id=OrderId(order_id_str),
                symbol=symbol,
                side=OrderSide("BUY") if bool(getattr(item, "isBuyerMaker", False)) else OrderSide("SELL"),
                price=Decimal(str(getattr(item, "price", 0))),
                quantity=Decimal(str(getattr(item, "quantity", 0))),
                fee=None,
                fee_asset=None,
                timestamp=_default_timestamp(),
            )
        )
    return trades


def klines_from_proto(
    symbol: Symbol, kline_proto: Optional[PublicSpotKlineV3Api_pb2.PublicSpotKlineV3Api] = None
) -> list[Kline]:
    """Convert spot kline DTOs to domain klines (skeleton mapping)."""

    if kline_proto is None:
        return []

    klines: list[Kline] = []
    interval = KlineInterval(str(getattr(kline_proto, "interval", "1m")))
    for item in getattr(kline_proto, "klineList", []):  # type: ignore[attr-defined]
        open_time_ms = int(getattr(item, "openTime", 0))
        close_time_ms = int(getattr(item, "closeTime", 0))
        klines.append(
            Kline(
                symbol=symbol,
                interval=interval,
                open=Decimal(str(getattr(item, "open", 0))),
                high=Decimal(str(getattr(item, "high", 0))),
                low=Decimal(str(getattr(item, "low", 0))),
                close=Decimal(str(getattr(item, "close", 0))),
                volume=Decimal(str(getattr(item, "volume", 0))),
                open_time=Timestamp(datetime.fromtimestamp(open_time_ms / 1000, tz=timezone.utc)),
                close_time=Timestamp(datetime.fromtimestamp(close_time_ms / 1000, tz=timezone.utc)),
            )
        )
    return klines


def orders_from_private_proto(
    symbol: Symbol, orders_proto: Optional[PrivateOrdersV3Api_pb2.PrivateOrdersV3Api] = None
) -> list[Order]:
    """Convert private orders DTO to domain orders (skeleton mapping)."""

    if orders_proto is None:
        return []

    orders: list[Order] = []
    for item in getattr(orders_proto, "orders", []):  # type: ignore[attr-defined]
        orders.append(
            Order(
                order_id=OrderId(str(getattr(item, "orderId", ""))),
                symbol=symbol,
                side=OrderSide(str(getattr(item, "side", "BUY"))),
                order_type=OrderType(str(getattr(item, "type", "LIMIT"))),
                status=OrderStatus(str(getattr(item, "status", "NEW"))),
                price=Decimal(str(getattr(item, "price", 0))),
                quantity=Quantity(Decimal(str(getattr(item, "origQty", 0)))),
                created_at=_default_timestamp(),
                time_in_force=None,
                client_order_id=str(getattr(item, "clientOrderId", "")) if getattr(item, "clientOrderId", None) else None,
                executed_quantity=Decimal(str(getattr(item, "executedQty", 0))),
                cumulative_quote_quantity=Decimal(str(getattr(item, "cummulativeQuoteQty", 0))),
                updated_at=_default_timestamp(),
            )
        )
    return orders
</file>

<file path="src/app/infrastructure/exchange/mexc/mappers.py">
"""Mapping helpers between MEXC API payloads and domain objects."""

from datetime import datetime, timezone
from decimal import Decimal, InvalidOperation
from typing import Any

from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.order_book import DepthLevel, OrderBook
from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId
from src.app.domain.value_objects.qrl_price import QrlPrice


def _to_decimal(value: Any) -> Decimal:
    return Decimal(str(value))


def _to_timestamp_from_ms(value: int | float | str) -> Timestamp:
    if value in (None, "", 0):
        ms_value = 0
    else:
        try:
            ms_value = int(value)
        except (TypeError, ValueError):
            ms_value = 0
    dt = datetime.fromtimestamp(ms_value / 1000, tz=timezone.utc)
    return Timestamp(dt)


def server_time_to_timestamp(payload: dict[str, Any]) -> Timestamp:
    return _to_timestamp_from_ms(payload.get("serverTime", 0))


def account_from_api(payload: dict[str, Any]) -> Account:
    balances = [
        Balance(asset=item["asset"], free=_to_decimal(item["free"]), locked=_to_decimal(item["locked"]))
        for item in payload.get("balances", [])
    ]
    return Account(
        can_trade=bool(payload.get("canTrade", True)),
        update_time=_to_timestamp_from_ms(payload.get("updateTime", 0)),
        balances=balances,
    )


def order_from_api(payload: dict[str, Any]) -> Order:
    order_id_value = payload.get("orderId")
    if order_id_value is None:
        raise ValueError("orderId is required in MEXC response")
    price_raw = payload.get("price", payload.get("origPrice"))
    price_vo: QrlPrice | None = None
    if price_raw not in (None, "", 0, "0"):
        try:
            price_vo = QrlPrice(_to_decimal(price_raw))
        except (InvalidOperation, ValueError):
            price_vo = None
    return Order(
        order_id=OrderId(str(order_id_value)),
        symbol=Symbol(payload.get("symbol", "QRLUSDT")),
        side=Side(payload.get("side", "BUY")),
        order_type=OrderType(payload.get("type", "LIMIT")),
        status=OrderStatus(payload.get("status", "NEW")),
        price=price_vo,
        quantity=Quantity(_to_decimal(payload.get("origQty", payload.get("quantity", "0.00000001")))),
        time_in_force=TimeInForce(payload["timeInForce"]) if payload.get("timeInForce") else None,
        created_at=_to_timestamp_from_ms(payload.get("transactTime", payload.get("createTime", 0))),
        client_order_id=payload.get("clientOrderId") or payload.get("origClientOrderId"),
        executed_quantity=_to_decimal(payload.get("executedQty", "0"))
        if payload.get("executedQty") is not None
        else None,
        cumulative_quote_quantity=_to_decimal(payload.get("cummulativeQuoteQty", "0"))
        if payload.get("cummulativeQuoteQty") is not None
        else None,
        updated_at=_to_timestamp_from_ms(payload["updateTime"]) if payload.get("updateTime") else None,
    )


def trade_from_api(payload: dict[str, Any]) -> Trade:
    return Trade(
        trade_id=TradeId(str(payload.get("id"))),
        order_id=OrderId(str(payload.get("orderId"))),
        symbol=Symbol(payload.get("symbol", "QRLUSDT")),
        side=Side("BUY" if payload.get("isBuyer") else "SELL"),
        price=QrlPrice(_to_decimal(payload.get("price", "0"))),
        quantity=Quantity(_to_decimal(payload.get("qty", payload.get("quantity", "0")))),
        fee=_to_decimal(payload["commission"]) if payload.get("commission") else None,
        fee_asset=payload.get("commissionAsset"),
        timestamp=_to_timestamp_from_ms(payload.get("time", 0)),
    )


def _parse_levels(raw: Any) -> list[DepthLevel]:
    levels: list[DepthLevel] = []
    if not isinstance(raw, list):
        return levels
    for item in raw:
        if not isinstance(item, (list, tuple)) or len(item) < 2:
            continue
        try:
            price = _to_decimal(item[0])
            quantity = _to_decimal(item[1])
            level = DepthLevel(price=price, quantity=quantity)
        except (InvalidOperation, TypeError, ValueError):
            continue
        levels.append(level)
    return levels


def order_book_from_api(payload: dict[str, Any]) -> OrderBook:
    """Map depth payload to an OrderBook VO."""

    bids = _parse_levels(payload.get("bids", []))
    asks = _parse_levels(payload.get("asks", []))
    return OrderBook(bids=bids, asks=asks)
</file>

<file path="src/app/interfaces/http/pages/static/js/pages/dashboard-renderers.js">
(() => {
  const $ = (id) => document.getElementById(id);
  const setText = (id, v = "") => {
    const el = $(id);
    if (el) el.textContent = v;
  };

  const chartEl = $("klineChart");
  const chart =
    window.Chart && chartEl
      ? new Chart(chartEl.getContext("2d"), {
          type: "line",
          data: { labels: [], datasets: [{ data: [], borderColor: "#2196f3", fill: false, tension: 0.2 }] },
        })
      : { data: { labels: [], datasets: [{ data: [] }] }, update() {} };

  const setPrice = (d) => {
    setText("price-error", "");
    setText("bid", d?.bid ?? "--");
    setText("ask", d?.ask ?? "--");
    setText("last", d?.last ?? "--");
    const raw = d?.timestamp;
    const parsed = typeof raw === "number" || typeof raw === "string" ? new Date(raw) : new Date();
    setText("timestamp", parsed.toISOString());
  };

  const setKlines = (items = []) => {
    chart.data.labels = items.map((k) => new Date(k.timestamp).toLocaleTimeString());
    chart.data.datasets[0].data = items.map((k) => Number(k.close));
    chart.update();
  };

  const setBalances = (payload = {}) => {
    setText("balance-error", "");
    const balances = payload.balances || [];
    const byAsset = (asset) => balances.find((b) => b.asset === asset) || { free: "--", locked: "--" };
    const qrl = byAsset("QRL");
    const usdt = byAsset("USDT");
    setText("bal-qrl-free", qrl.free);
    setText("bal-qrl-locked", qrl.locked);
    setText("bal-usdt-free", usdt.free);
    setText("bal-usdt-locked", usdt.locked);
  };

  const normalizeDepth = (item) => (Array.isArray(item) ? { price: item[0], qty: item[1] } : { price: item?.price ?? item?.p ?? "--", qty: item?.quantity ?? item?.q ?? "--" });

  const setDepth = (payload = {}) => {
    setText("depth-error", "");
    const bidsEl = $("depth-bids");
    const asksEl = $("depth-asks");
    const build = (items = []) =>
      items
        .slice(0, 10)
        .map((entry) => {
          const { price, qty } = normalizeDepth(entry);
          return `<li><span class="price">${price}</span><span class="qty">${qty}</span></li>`;
        })
        .join("");
    if (bidsEl) bidsEl.innerHTML = build(payload.bids);
    if (asksEl) asksEl.innerHTML = build(payload.asks);
  };

  const normalizeTrade = (t = {}) => {
    const side = t.side ?? (t.isBuyerMaker === true ? "SELL" : t.isBuyerMaker === false ? "BUY" : "--");
    const tsRaw = t.timestamp ?? t.time ?? Date.now();
    return { price: t.price ?? t.p ?? "--", qty: t.quantity ?? t.q ?? "--", side, ts: typeof tsRaw === "string" ? tsRaw : new Date(tsRaw).toISOString() };
  };

  const setTrades = (payload = []) => {
    setText("trades-error", "");
    const el = $("trades-list");
    if (!el) return;
    el.innerHTML = payload
      .slice(0, 20)
      .map((t) => {
        const n = normalizeTrade(t);
        return `<li><span class="side ${n.side === "BUY" ? "buy" : "sell"}">${n.side}</span><span class="price">${n.price}</span><span class="qty">${n.qty}</span><span class="ts">${n.ts}</span></li>`;
      })
      .join("");
  };

  const formatAmount = (price, qty, quote) => {
    if (quote !== undefined && quote !== null) return quote;
    const p = Number(price);
    const q = Number(qty);
    return Number.isFinite(p) && Number.isFinite(q) ? (p * q).toFixed(4) : "--";
  };

  const normalizeOrder = (o = {}) => {
    const status = (o.status ?? "--").toString().toUpperCase();
    const price = o.price ?? o.limit_price ?? o.avg_price ?? "--";
    const qty = o.quantity ?? o.orig_qty ?? "--";
    const quote =
      o.cumulative_quote_quantity ??
      o.cum_quote_quantity ??
      o.cumulative_quote_qty ??
      o.cummulativeQuoteQty ??
      undefined;
    return {
      side: o.side ?? "--",
      status,
      price,
      qty,
      amount: formatAmount(price, qty, quote),
      id: o.order_id ?? o.orderId ?? "--",
      canCancel: !["CANCELED", "FILLED", "REJECTED", "EXPIRED"].includes(status),
    };
  };

  const setOrders = (payload = []) => {
    setText("orders-error", "");
    const el = $("orders-list");
    if (!el) return;
    const header =
      '<li class="orders-header"><span class="id">訂單ID</span><span class="side">方向</span><span class="price">價格</span><span class="qty">數量</span><span class="amount">金額</span><span class="status">狀態</span><span class="action">操作</span></li>';
    el.innerHTML =
      header +
      payload
        .slice(0, 20)
        .map((o) => {
          const n = normalizeOrder(o);
          const action = n.canCancel
            ? `<button class="order-cancel" data-order-id="${n.id}" aria-label="取消訂單 ${n.id}">取消</button>`
            : `<span class="status-label">${n.status}</span>`;
          return `<li data-order-id="${n.id}"><span class="id">${n.id}</span><span class="side ${n.side === "BUY" ? "buy" : "sell"}">${n.side}</span><span class="price">${n.price}</span><span class="qty">${n.qty}</span><span class="amount">${n.amount}</span><span class="status">${n.status}</span><span class="action">${action}</span></li>`;
        })
        .join("");
  };

  window.dashboardUI = { setText, setPrice, setKlines, setBalances, setDepth, setTrades, setOrders };
})();
</file>

<file path="src/app/interfaces/http/schemas.py">
"""Pydantic schemas for interface layer requests/responses."""

from datetime import datetime
from decimal import Decimal
from typing import Literal

from pydantic import BaseModel, ConfigDict, Field


class PlaceOrderRequest(BaseModel):
    symbol: str = Field(default="QRLUSDT", description="Trading symbol")
    side: Literal["BUY", "SELL"]
    order_type: Literal["LIMIT", "MARKET"] = Field(default="LIMIT", alias="type")
    quantity: Decimal
    price: Decimal | None = None
    time_in_force: Literal["GTC", "IOC", "FOK"] | None = Field(default="GTC", alias="timeInForce")
    client_order_id: str | None = Field(default=None, alias="clientOrderId")


class CancelOrderRequest(BaseModel):
    symbol: str = Field(default="QRLUSDT", description="Trading symbol")
    order_id: str | None = Field(default=None, alias="orderId")
    client_order_id: str | None = Field(default=None, alias="clientOrderId")


class GetOrderRequest(BaseModel):
    symbol: str = Field(default="QRLUSDT", description="Trading symbol")
    order_id: str | None = Field(default=None, alias="orderId")
    client_order_id: str | None = Field(default=None, alias="clientOrderId")


class ListTradesRequest(BaseModel):
    symbol: str = Field(default="QRLUSDT", description="Trading symbol")


class AllocationResponse(BaseModel):
    """Response returned when the allocation task is triggered."""

    model_config = ConfigDict(from_attributes=True)

    request_id: str = Field(description="Identifier for the allocation trigger")
    status: str = Field(description="Execution status for the allocation task")
    executed_at: datetime = Field(description="UTC timestamp when the task executed")
    action: str = Field(description="Trade action executed (BUY, SELL, SKIP, REJECTED)")
    order_id: str | None = Field(default=None, description="Order identifier returned by the exchange")
    reason: str | None = Field(default=None, description="Reason when action is skipped or rejected")
    slippage_pct: Decimal | None = Field(
        default=None, description="Calculated slippage percentage for the planned order"
    )
    expected_fill: Decimal | None = Field(
        default=None, description="Expected fill quantity based on current depth"
    )
</file>

<file path="src/app/interfaces/tasks/entrypoints.py">
"""HTTP/Scheduler entrypoints for background tasks."""

import asyncio
import os

from src.app.application.system.use_cases.allocation import AllocationResult, AllocationUseCase


def _allocation_timeout_seconds() -> float:
    """Read the scheduler task timeout from the environment."""
    raw: str | None = os.getenv("TASK_TIMEOUT_SECONDS", "20")
    try:
        return float(raw)
    except ValueError:
        return 20.0


async def run_allocation(timeout_seconds: float | None = None) -> AllocationResult:
    """Trigger the allocation use case for Cloud Scheduler with a bounded runtime."""
    usecase = AllocationUseCase()
    timeout = timeout_seconds or _allocation_timeout_seconds()
    return await asyncio.wait_for(usecase.execute(), timeout=timeout)
</file>

<file path="src/app/interfaces/http/pages/static/js/pages/dashboard.js">
(() => {
  const cfg = window.dashboardConfig || {};
  const ui = window.dashboardUI || {};
  if (!ui.setPrice || !ui.setText) return;

  const load = async (url) => {
    const resp = await fetch(url);
    let data = {};
    try {
      data = await resp.json();
    } catch (_err) {
      data = {};
    }
    return { ok: resp.ok, data };
  };

  const err = (id, detail, fallback) => ui.setText(id, detail || fallback);

  async function refresh() {
    try {
      const [price, kline, bal, depth, trades, orders] = await Promise.all([
        load(cfg.priceUrl),
        load(cfg.klineUrl),
        load(cfg.balanceUrl),
        load(cfg.depthUrl),
        load(cfg.tradesUrl),
        load(cfg.ordersUrl),
      ]);
      price.ok ? ui.setPrice(price.data) : err("price-error", price.data.detail, "價格取得失敗");
      kline.ok && ui.setKlines(kline.data);
      bal.ok ? ui.setBalances(bal.data) : err("balance-error", bal.data.detail, "餘額取得失敗");
      depth.ok ? ui.setDepth(depth.data) : err("depth-error", depth.data.detail, "Depth 取得失敗");
      trades.ok ? ui.setTrades(trades.data) : err("trades-error", trades.data.detail, "Trades 取得失敗");
      orders.ok ? ui.setOrders(orders.data) : err("orders-error", orders.data.detail, "Orders 取得失敗");
    } catch (ex) {
      ["price", "balance", "depth", "trades", "orders"].forEach((key) => err(`${key}-error`, null, "連線錯誤"));
      console.error(ex);
    }
  }

  const wireSideToggle = () => {
    document.querySelectorAll(".side-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".side-btn").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        const sideInput = document.querySelector('input[name="side"]');
        if (sideInput) sideInput.value = btn.dataset.side;
      });
    });
  };

  const wireOrderForm = () => {
    const form = document.getElementById("orderForm");
    const resultEl = document.getElementById("orderResult");
    if (!form || !resultEl) return;
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const payload = {
        symbol: "QRLUSDT",
        side: form.side.value,
        order_type: form.order_type.value,
        quantity: form.quantity.value,
        price: form.price.value || null,
        time_in_force: form.time_in_force.value,
      };
      resultEl.textContent = "送出中...";
      try {
        const resp = await fetch(cfg.orderUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const data = await resp.json().catch(() => ({}));
        resultEl.textContent = resp.ok
          ? `成功: orderId=${data.order_id || data.orderId || "N/A"}`
          : `失敗: ${data.detail || JSON.stringify(data)}`;
      } catch (ex) {
        resultEl.textContent = `錯誤: ${ex}`;
      }
    });
  };

  const cancelOrder = async (orderId, button) => {
    if (!orderId || !cfg.ordersUrl) return;
    const url = `${cfg.ordersUrl}/${encodeURIComponent(orderId)}/cancel`;
    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = "取消中...";
    try {
      const resp = await fetch(url, { method: "POST" });
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok) {
        err("orders-error", data.detail, "取消失敗");
      } else {
        ui.setText("orders-error", "");
        refresh();
      }
    } catch (ex) {
      err("orders-error", String(ex), "取消失敗");
    } finally {
      button.disabled = false;
      button.textContent = originalText || "取消";
    }
  };

  const wireOrderActions = () => {
    const list = document.getElementById("orders-list");
    if (!list) return;
    list.addEventListener("click", (event) => {
      const button = event.target.closest(".order-cancel");
      if (!button) return;
      const orderId = button.dataset.orderId;
      cancelOrder(orderId, button);
    });
  };

  document.addEventListener("DOMContentLoaded", () => {
    wireSideToggle();
    wireOrderForm();
    wireOrderActions();
    refresh();
    setInterval(refresh, cfg.refreshMs || 10000);
  });
})();
</file>

<file path="src/app/interfaces/http/api/tasks_routes.py">
import asyncio
import logging

from fastapi import APIRouter, HTTPException
import httpx
from pydantic import ValidationError

from src.app.interfaces.http.schemas import AllocationResponse
from src.app.interfaces.tasks import entrypoints

router = APIRouter()
api_router = APIRouter()
logger = logging.getLogger(__name__)


async def _trigger_allocation() -> AllocationResponse:
    """Run the allocation task and normalize the response."""
    try:
        result = await entrypoints.run_allocation()
    except asyncio.TimeoutError:
        raise HTTPException(status_code=504, detail="Allocation task exceeded timeout")
    except (ValidationError, httpx.HTTPError) as exc:
        logger.exception("Allocation failed due to configuration or upstream API error")
        raise HTTPException(status_code=502, detail=str(exc))
    except Exception:
        logger.exception("Unexpected allocation failure")
        raise HTTPException(status_code=500, detail="Allocation task failed")
    return AllocationResponse.model_validate(result)


@router.api_route(
    "/allocation",
    methods=["POST", "GET"],
    response_model=AllocationResponse,
    tags=["tasks"],
    name="tasks_allocation_trigger",
)
async def trigger_allocation() -> AllocationResponse:
    """Endpoint for Cloud Scheduler to trigger an allocation run."""
    return await _trigger_allocation()


@api_router.api_route(
    "/allocation",
    methods=["POST", "GET"],
    response_model=AllocationResponse,
    tags=["tasks"],
    name="api_tasks_allocation_trigger",
)
async def trigger_allocation_api() -> AllocationResponse:
    """API-aligned alias to trigger allocation under the /api/tasks namespace."""
    return await _trigger_allocation()
</file>

<file path="src/app/application/system/use_cases/allocation.py">
"""System use case to expose an allocation trigger for schedulers."""

from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal
from typing import Callable
from uuid import uuid4

from src.app.application.exchange.mexc_service import MexcService, PlaceOrderRequest, build_mexc_service
from src.app.domain.entities.account import Account
from src.app.domain.services.balance_comparison_rule import BalanceComparisonRule
from src.app.domain.services.depth_calculator import DepthCalculator
from src.app.domain.services.slippage_analyzer import SlippageAnalyzer
from src.app.domain.services.valuation_service import ValuationService
from src.app.domain.value_objects.balance_comparison_result import BalanceComparisonResult
from src.app.domain.value_objects.normalized_balances import NormalizedBalances
from src.app.domain.value_objects.order_command import OrderCommand
from src.app.domain.value_objects.order_book import OrderBook
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.slippage import SlippageAssessment
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class AllocationConfig:
    """Default configuration values for the allocation flow."""

    SYMBOL = Symbol("QRLUSDT")
    TIME_IN_FORCE = TimeInForce("GTC")
    LIMIT_PRICE = Decimal("1")
    TARGET_QUANTITY = Quantity(Decimal("1"))
    DEPTH_LIMIT = 20
    SLIPPAGE_THRESHOLD_PCT = Decimal("5")
    PRICE_BUFFER_PCT = Decimal("0.001")  # 0.1%


@dataclass(frozen=True)
class AllocationResult:
    """Outcome returned when an allocation task is triggered."""

    request_id: str
    status: str
    executed_at: datetime
    action: str
    order_id: str | None
    reason: str | None = None
    slippage_pct: Decimal | None = None
    expected_fill: Decimal | None = None


class AllocationUseCase:
    """Check QRL:USDT balance ratio and place a limit order when slippage is acceptable."""

    def __init__(
        self,
        service_factory: Callable[[], MexcService] | None = None,
        *,
        depth_limit: int = AllocationConfig.DEPTH_LIMIT,
        slippage_threshold_pct: Decimal = AllocationConfig.SLIPPAGE_THRESHOLD_PCT,
        target_quantity: Quantity | None = None,
        limit_price: Decimal = AllocationConfig.LIMIT_PRICE,
    ):
        self._service_factory = service_factory or (lambda: build_mexc_service(MexcSettings()))
        self._comparison_rule = BalanceComparisonRule()
        self._depth_calculator = DepthCalculator()
        self._slippage_analyzer = SlippageAnalyzer(slippage_threshold_pct)
        self._valuation_service = ValuationService()
        self._depth_limit = depth_limit
        self._target_quantity = target_quantity or AllocationConfig.TARGET_QUANTITY
        self._limit_price = Decimal(limit_price)

    async def execute(self) -> AllocationResult:
        """Compare balances, evaluate depth/slippage, and submit a balancing order."""
        request_id = str(uuid4())
        executed_at = datetime.now(timezone.utc)
        async with self._service_factory() as svc:
            account = await svc.get_account()
            try:
                quote = await svc.get_price(AllocationConfig.SYMBOL)
                mid_price = (quote.bid + quote.ask) / Decimal("2")
            except Exception:
                return _result_from_price_error(request_id, executed_at)

            balances = _normalize_balances(account, mid_price, self._valuation_service)
            comparison = self._comparison_rule.evaluate(balances)
            if comparison.action == "skip" or comparison.preferred_side is None:
                return _result_from_skip(request_id, executed_at, comparison)

            order_book = await svc.get_depth(AllocationConfig.SYMBOL, limit=self._depth_limit)
            filled, weighted_price = self._depth_calculator.compute(
                order_book, comparison.preferred_side, self._target_quantity
            )
            best_bid = _best_bid(order_book)
            best_ask = _best_ask(order_book)
            top_price = _best_price(order_book, comparison.preferred_side)
            if top_price <= 0 or best_bid <= 0 or best_ask <= 0:
                return _result_from_slippage(
                    request_id, executed_at, SlippageAssessment(Decimal("0"), Decimal("0"), False, "No executable depth")
                )
            slippage = self._slippage_analyzer.assess(
                side=comparison.preferred_side,
                desired_price=top_price,
                target_quantity=self._target_quantity,
                fill_quantity=filled,
                weighted_price=weighted_price,
            )
            if not slippage.is_acceptable:
                return _result_from_slippage(request_id, executed_at, slippage)

            limit_price = _compute_limit_price(
                side=comparison.preferred_side,
                best_bid=best_bid,
                best_ask=best_ask,
                buffer_pct=AllocationConfig.PRICE_BUFFER_PCT,
            )
            if limit_price is None:
                return _result_from_slippage(
                    request_id,
                    executed_at,
                    SlippageAssessment(Decimal("0"), Decimal("0"), False, "Cannot place maker limit"),
                )
            command = _build_order_command(
                side=comparison.preferred_side, quantity=self._target_quantity, limit_price=limit_price
            )
            order = await svc.place_order(
                PlaceOrderRequest(
                    symbol=command.symbol,
                    side=command.side,
                    order_type=OrderType("LIMIT"),
                    quantity=command.quantity,
                    price=command.price,
                    time_in_force=command.time_in_force,
                )
            )

        return _result_from_success(
            request_id=request_id,
            executed_at=executed_at,
            slippage=slippage,
            side=command.side,
            order_id=order.order_id.value,
        )


def _normalize_balances(account: Account, mid_price: Decimal, valuation: ValuationService) -> NormalizedBalances:
    """Return normalized balances using total (free + locked) holdings."""
    qrl_total = Decimal("0")
    usdt_total = Decimal("0")
    for bal in account.balances:
        asset = bal.asset.upper()
        if asset == "QRL":
            qrl_total += bal.free + bal.locked
        if asset == "USDT":
            usdt_total += bal.free + bal.locked
    qrl_value = valuation.value(qrl_total, mid_price)
    return NormalizedBalances(qrl_free=qrl_value, usdt_free=usdt_total)


def _build_order_command(*, side: Side, quantity: Quantity, limit_price: Decimal) -> OrderCommand:
    return OrderCommand(
        symbol=AllocationConfig.SYMBOL,
        side=side,
        quantity=quantity,
        price=Price.from_single(limit_price),
        time_in_force=AllocationConfig.TIME_IN_FORCE,
    )


def _best_price(book: OrderBook, side: Side) -> Decimal:
    prices = [level.price for level in (book.asks if side.value == "BUY" else book.bids)]
    if not prices:
        return Decimal("0")
    return min(prices) if side.value == "BUY" else max(prices)


def _best_bid(book: OrderBook) -> Decimal:
    bids = [level.price for level in book.bids]
    return max(bids) if bids else Decimal("0")


def _best_ask(book: OrderBook) -> Decimal:
    asks = [level.price for level in book.asks]
    return min(asks) if asks else Decimal("0")


def _compute_limit_price(*, side: Side, best_bid: Decimal, best_ask: Decimal, buffer_pct: Decimal) -> Decimal | None:
    """Return a maker-style limit price that does not cross the spread."""
    if best_bid <= 0 or best_ask <= 0 or best_bid >= best_ask:
        return None
    if side.value == "BUY":
        candidate = best_bid * (Decimal("1") - buffer_pct)
        if candidate >= best_ask:
            return None
        return candidate
    candidate = best_ask * (Decimal("1") + buffer_pct)
    if candidate <= best_bid:
        return None
    return candidate


def _result_from_skip(
    request_id: str, executed_at: datetime, comparison: BalanceComparisonResult
) -> AllocationResult:
    return AllocationResult(
        request_id=request_id,
        status="skipped",
        executed_at=executed_at,
        action="SKIP",
        order_id=None,
        reason=comparison.reason,
        slippage_pct=None,
        expected_fill=None,
    )


def _result_from_slippage(
    request_id: str, executed_at: datetime, slippage: SlippageAssessment
) -> AllocationResult:
    return AllocationResult(
        request_id=request_id,
        status="rejected",
        executed_at=executed_at,
        action="REJECTED",
        order_id=None,
        reason=slippage.reason,
        slippage_pct=slippage.slippage_pct,
        expected_fill=slippage.expected_fill,
    )


def _result_from_price_error(request_id: str, executed_at: datetime) -> AllocationResult:
    return AllocationResult(
        request_id=request_id,
        status="rejected",
        executed_at=executed_at,
        action="REJECTED",
        order_id=None,
        reason="Price unavailable",
        slippage_pct=None,
        expected_fill=None,
    )


def _result_from_success(
    *,
    request_id: str,
    executed_at: datetime,
    slippage: SlippageAssessment,
    side: Side,
    order_id: str,
) -> AllocationResult:
    return AllocationResult(
        request_id=request_id,
        status="ok",
        executed_at=executed_at,
        action=side.value,
        order_id=order_id,
        reason=None,
        slippage_pct=slippage.slippage_pct,
        expected_fill=slippage.expected_fill,
    )
</file>

<file path="src/app/interfaces/http/pages/templates/dashboard/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>QRL/USDT Dashboard</title>
<link rel="stylesheet" href="/static/css/dashboard.css" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<a href="#maincontent" class="skip-link">Skip to content</a>
<main id="maincontent" class="dashboard-grid">
<div class="card price-card">
<div class="price-row"><span class="label">買價</span><span id="bid" class="value">--</span></div>
<div class="price-row"><span class="label">賣價</span><span id="ask" class="value">--</span></div>
<div class="price-row"><span class="label">最新價</span><span id="last" class="value">--</span></div>
<div class="price-row"><span class="label">更新時間</span><span id="timestamp" class="value">--</span></div>
<div class="price-row error" id="price-error" aria-live="polite"></div>
</div>
<div class="card kline-card">
<canvas id="klineChart" height="240"></canvas>
</div>
<div class="card depth-card">
<h2>深度</h2>
<div class="vertical-stack">
<div class="label">賣盤</div>
<ul id="depth-asks" class="depth-list"></ul>
<div class="label">買盤</div>
<ul id="depth-bids" class="depth-list"></ul>
</div>
<div class="price-row error" id="depth-error" aria-live="polite"></div>
</div>
<div class="card trades-card">
<h2>近期成交</h2>
<ul id="trades-list" class="trades-list"></ul>
<div class="price-row error" id="trades-error" aria-live="polite"></div>
</div>
<div class="card orders-card">
<h2>我的訂單</h2>
<ul id="orders-list" class="orders-list"></ul>
<div class="price-row error" id="orders-error" aria-live="polite"></div>
</div>
<div class="card balance-card">
<h2>餘額</h2>
<div class="price-row"><span class="label">QRL 可用</span><span id="bal-qrl-free" class="value">--</span></div>
<div class="price-row"><span class="label">QRL 凍結</span><span id="bal-qrl-locked" class="value">--</span></div>
<div class="price-row"><span class="label">USDT 可用</span><span id="bal-usdt-free" class="value">--</span></div>
<div class="price-row"><span class="label">USDT 凍結</span><span id="bal-usdt-locked" class="value">--</span></div>
<div class="price-row error" id="balance-error" aria-live="polite"></div>
</div>
<div class="card order-card">
<h2>下單</h2>
<form id="orderForm">
<div class="form-row">
<label>方向</label>
<div class="side-toggle" role="group" aria-label="Side">
<button type="button" data-side="BUY" class="side-btn active">買入</button>
<button type="button" data-side="SELL" class="side-btn">賣出</button>
</div>
<input type="hidden" name="side" value="BUY" />
</div>
<div class="form-row">
<label>類型</label>
<select name="order_type">
<option value="LIMIT">LIMIT</option>
<option value="MARKET">MARKET</option>
</select>
</div>
<div class="form-row">
<label>數量</label>
<input name="quantity" type="number" step="0.0001" required />
</div>
<div class="form-row">
<label>價格</label>
<input name="price" type="number" step="0.0001" />
</div>
<div class="form-row">
<label>有效期限</label>
<select name="time_in_force">
<option value="GTC">GTC</option>
<option value="IOC">IOC</option>
<option value="FOK">FOK</option>
</select>
</div>
<button type="submit">送出</button>
<div id="orderResult" class="order-result"></div>
</form>
</div>
</main>
<script id="dashboard-config" type="application/json">{{ dashboard_config | tojson }}</script>
<script src="/static/js/pages/dashboard-config.js" defer></script>
<script src="/static/js/domain/order.js" defer></script>
<script src="/static/js/pages/dashboard-renderers.js" defer></script>
<script src="/static/js/pages/dashboard.js" defer></script>
</body>
</html>
</file>

<file path="tests/test_allocation_use_case.py">
from datetime import datetime, timezone
from decimal import Decimal
import pytest

from src.app.application.exchange.mexc_service import PlaceOrderRequest
from src.app.application.system.use_cases.allocation import AllocationUseCase
from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.order_book import DepthLevel, OrderBook
from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.domain.value_objects.timestamp import Timestamp


class FakeService:
    def __init__(
        self,
        qrl_free: str,
        usdt_free: str,
        *,
        qrl_locked: str = "0",
        usdt_locked: str = "0",
        bids: list[DepthLevel] | None = None,
        asks: list[DepthLevel] | None = None,
        price_bid: str = "1",
        price_ask: str = "1",
    ):
        self._qrl_free = Decimal(qrl_free)
        self._usdt_free = Decimal(usdt_free)
        self._qrl_locked = Decimal(qrl_locked)
        self._usdt_locked = Decimal(usdt_locked)
        self._book = OrderBook(bids=bids or [], asks=asks or [])
        self._price = Price(
            bid=Decimal(price_bid),
            ask=Decimal(price_ask),
            last=Decimal(price_bid),
            timestamp=Timestamp(datetime.now(timezone.utc)),
        )
        self.last_order_request: PlaceOrderRequest | None = None

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        return None

    async def get_account(self) -> Account:
        return Account(
            can_trade=True,
            update_time=Timestamp(datetime.now(timezone.utc)),
            balances=[
                Balance(asset="QRL", free=self._qrl_free, locked=self._qrl_locked),
                Balance(asset="USDT", free=self._usdt_free, locked=self._usdt_locked),
            ],
        )

    async def get_depth(self, symbol: Symbol, limit: int = 50) -> OrderBook:
        return self._book

    async def get_price(self, symbol: Symbol) -> Price:
        return self._price

    async def place_order(self, request: PlaceOrderRequest) -> Order:
        self.last_order_request = request
        return Order(
            order_id=OrderId("test-order"),
            symbol=request.symbol,
            side=request.side,
            order_type=request.order_type,
            status=OrderStatus("NEW"),
            price=request.price.last if request.price else Decimal("0"),
            quantity=request.quantity,
            created_at=Timestamp(datetime.now(timezone.utc)),
            time_in_force=request.time_in_force,
        )


@pytest.mark.asyncio
async def test_allocation_skips_when_balances_even():
    service = FakeService(qrl_free="1", usdt_free="1")
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "skipped"
    assert result.action == "SKIP"
    assert result.order_id is None
    assert service.last_order_request is None


@pytest.mark.asyncio
async def test_allocation_uses_locked_balances_for_ratio():
    service = FakeService(qrl_free="0.2", qrl_locked="0.8", usdt_free="1")
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "skipped"
    assert result.action == "SKIP"
    assert service.last_order_request is None


@pytest.mark.asyncio
async def test_allocation_rejects_on_slippage():
    service = FakeService(
        qrl_free="0.1",
        usdt_free="5",
        asks=[
            DepthLevel(price=Decimal("1"), quantity=Decimal("0.1")),
            DepthLevel(price=Decimal("2.5"), quantity=Decimal("1")),
        ],
    )
    usecase = AllocationUseCase(service_factory=lambda: service, slippage_threshold_pct=Decimal("5"))

    result = await usecase.execute()

    assert result.status == "rejected"
    assert result.action == "REJECTED"
    assert result.order_id is None
    assert result.reason is not None
    assert service.last_order_request is None


@pytest.mark.asyncio
async def test_allocation_places_order_when_slippage_ok():
    service = FakeService(
        qrl_free="2",
        usdt_free="1",
        bids=[DepthLevel(price=Decimal("1.01"), quantity=Decimal("1.5"))],
        asks=[DepthLevel(price=Decimal("1.02"), quantity=Decimal("1.0"))],
    )
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "ok"
    assert result.action == "SELL"
    assert result.order_id == "test-order"
    assert result.expected_fill == Decimal("1")
    assert service.last_order_request is not None
    assert service.last_order_request.side.value == "SELL"
    assert service.last_order_request.price is not None
    assert service.last_order_request.price.last == Decimal("1.02102")
    assert service.last_order_request.quantity.value == Decimal("1")
    assert service.last_order_request.time_in_force == TimeInForce("GTC")


@pytest.mark.asyncio
async def test_allocation_skips_when_value_balanced_but_qty_not():
    # QRL qty > USDT qty, but price=0.5 makes values equal (1 USDT vs 1 USDT)
    service = FakeService(qrl_free="2", usdt_free="1", price_bid="0.5", price_ask="0.5")
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "skipped"
    assert service.last_order_request is None


@pytest.mark.asyncio
async def test_allocation_rejects_when_price_unavailable(monkeypatch):
    service = FakeService(qrl_free="0.5", usdt_free="1")

    async def raise_price(symbol: Symbol):
        raise RuntimeError("price failed")

    service.get_price = raise_price  # type: ignore
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "rejected"
    assert result.reason == "Price unavailable"
    assert service.last_order_request is None
</file>

</files>
