This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cloudbuild.yaml
Dockerfile
main.py
src/__init__.py
src/app/__init__.py
src/app/application/__init__.py
src/app/application/account/__init__.py
src/app/application/account/use_cases/__init__.py
src/app/application/account/use_cases/get_balance.py
src/app/application/events/__init__.py
src/app/application/events/event_bus.py
src/app/application/exchange/mexc_service.py
src/app/application/market/__init__.py
src/app/application/market/mappers/__init__.py
src/app/application/market/mappers/mexc.py
src/app/application/market/qrl/__init__.py
src/app/application/market/qrl/get_qrl_depth.py
src/app/application/market/qrl/get_qrl_kline.py
src/app/application/market/qrl/get_qrl_price.py
src/app/application/market/use_cases/__init__.py
src/app/application/market/use_cases/get_depth.py
src/app/application/market/use_cases/get_kline.py
src/app/application/market/use_cases/get_market_trades.py
src/app/application/market/use_cases/get_stats24h.py
src/app/application/market/use_cases/get_ticker.py
src/app/application/ports/__init__.py
src/app/application/ports/exchange_gateway.py
src/app/application/system/__init__.py
src/app/application/system/use_cases/__init__.py
src/app/application/system/use_cases/allocation.py
src/app/application/system/use_cases/get_server_time.py
src/app/application/system/use_cases/ping.py
src/app/application/trading/__init__.py
src/app/application/trading/dto/__init__.py
src/app/application/trading/mappers/__init__.py
src/app/application/trading/mappers/mexc.py
src/app/application/trading/qrl/__init__.py
src/app/application/trading/qrl/cancel_qrl_order.py
src/app/application/trading/qrl/get_qrl_order.py
src/app/application/trading/qrl/guards/__init__.py
src/app/application/trading/qrl/guards/qrl_balance_guard.py
src/app/application/trading/qrl/guards/qrl_duplicate_guard.py
src/app/application/trading/qrl/guards/qrl_price_guard.py
src/app/application/trading/qrl/guards/qrl_rate_limit_guard.py
src/app/application/trading/qrl/place_qrl_order.py
src/app/application/trading/use_cases/__init__.py
src/app/application/trading/use_cases/cancel_order.py
src/app/application/trading/use_cases/get_kline.py
src/app/application/trading/use_cases/get_order.py
src/app/application/trading/use_cases/get_price.py
src/app/application/trading/use_cases/list_orders.py
src/app/application/trading/use_cases/list_trades.py
src/app/application/trading/use_cases/place_order.py
src/app/domain/__init__.py
src/app/domain/aggregates/__init__.py
src/app/domain/aggregates/account_state.py
src/app/domain/aggregates/market_snapshot.py
src/app/domain/aggregates/trading_session.py
src/app/domain/entities/__init__.py
src/app/domain/entities/account.py
src/app/domain/entities/kline.py
src/app/domain/entities/order_book_level.py
src/app/domain/entities/order.py
src/app/domain/entities/trade.py
src/app/domain/entities/trading_pair.py
src/app/domain/events/__init__.py
src/app/domain/events/balance_event.py
src/app/domain/events/kline_updated_event.py
src/app/domain/events/market_depth_event.py
src/app/domain/events/order_event.py
src/app/domain/events/price_updated_event.py
src/app/domain/events/trade_event.py
src/app/domain/services/__init__.py
src/app/domain/services/balance_comparison_rule.py
src/app/domain/services/depth_calculator.py
src/app/domain/services/slippage_analyzer.py
src/app/domain/services/valuation_service.py
src/app/domain/value_objects/__init__.py
src/app/domain/value_objects/api_key.py
src/app/domain/value_objects/api_secret.py
src/app/domain/value_objects/balance_comparison_result.py
src/app/domain/value_objects/balance.py
src/app/domain/value_objects/client_order_id.py
src/app/domain/value_objects/kline_interval.py
src/app/domain/value_objects/kline.py
src/app/domain/value_objects/normalized_balances.py
src/app/domain/value_objects/order_book.py
src/app/domain/value_objects/order_command.py
src/app/domain/value_objects/order_id.py
src/app/domain/value_objects/order_side.py
src/app/domain/value_objects/order_status.py
src/app/domain/value_objects/order_type.py
src/app/domain/value_objects/price.py
src/app/domain/value_objects/qrl_price.py
src/app/domain/value_objects/qrl_quantity.py
src/app/domain/value_objects/qrl_usdt_pair.py
src/app/domain/value_objects/quantity.py
src/app/domain/value_objects/side.py
src/app/domain/value_objects/slippage.py
src/app/domain/value_objects/sub_account_id.py
src/app/domain/value_objects/symbol.py
src/app/domain/value_objects/ticker.py
src/app/domain/value_objects/time_in_force.py
src/app/domain/value_objects/timestamp.py
src/app/domain/value_objects/trade_id.py
src/app/infrastructure/__init__.py
src/app/infrastructure/config.py
src/app/infrastructure/event_bus/__init__.py
src/app/infrastructure/event_bus/in_memory_event_bus.py
src/app/infrastructure/exchange/__init__.py
src/app/infrastructure/exchange/mexc_api_client.py
src/app/infrastructure/exchange/mexc/__init__.py
src/app/infrastructure/exchange/mexc/adapters/__init__.py
src/app/infrastructure/exchange/mexc/adapters/balance_mapper.py
src/app/infrastructure/exchange/mexc/adapters/depth_mapper.py
src/app/infrastructure/exchange/mexc/adapters/market_event_adapter.py
src/app/infrastructure/exchange/mexc/adapters/order_mapper.py
src/app/infrastructure/exchange/mexc/adapters/trade_mapper.py
src/app/infrastructure/exchange/mexc/factories.py
src/app/infrastructure/exchange/mexc/generated/__init__.py
src/app/infrastructure/exchange/mexc/generated/PrivateAccountV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PrivateDealsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PrivateOrdersV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicAggreBookTickerV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicAggreDealsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicAggreDepthsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicBookTickerBatchV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicBookTickerV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicDealsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicIncreaseDepthsBatchV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicIncreaseDepthsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicLimitDepthsV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicMiniTickersV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicMiniTickerV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PublicSpotKlineV3Api_pb2.py
src/app/infrastructure/exchange/mexc/generated/PushDataV3ApiWrapper_pb2.py
src/app/infrastructure/exchange/mexc/mappers.py
src/app/infrastructure/exchange/mexc/proto/__init__.py
src/app/infrastructure/exchange/mexc/proto/LICENSE
src/app/infrastructure/exchange/mexc/proto/PrivateAccountV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PrivateDealsV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PrivateOrdersV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicAggreBookTickerV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicAggreDealsV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicAggreDepthsV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicBookTickerBatchV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicBookTickerV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicDealsV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicIncreaseDepthsBatchV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicIncreaseDepthsV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicLimitDepthsV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicMiniTickersV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicMiniTickerV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PublicSpotKlineV3Api.proto
src/app/infrastructure/exchange/mexc/proto/PushDataV3ApiWrapper.proto
src/app/infrastructure/exchange/mexc/qrl/__init__.py
src/app/infrastructure/exchange/mexc/qrl/qrl_order_mapper.py
src/app/infrastructure/exchange/mexc/qrl/qrl_price_mapper.py
src/app/infrastructure/exchange/mexc/qrl/qrl_rest_client.py
src/app/infrastructure/exchange/mexc/qrl/qrl_settings.py
src/app/infrastructure/exchange/mexc/qrl/qrl_trade_mapper.py
src/app/infrastructure/exchange/mexc/qrl/qrl_ws_client.py
src/app/infrastructure/exchange/mexc/qrl/ws/__init__.py
src/app/infrastructure/exchange/mexc/qrl/ws/qrl_reconnect_policy.py
src/app/infrastructure/exchange/mexc/qrl/ws/qrl_snapshot_loader.py
src/app/infrastructure/exchange/mexc/qrl/ws/qrl_stream_state.py
src/app/infrastructure/exchange/mexc/rest_client.py
src/app/infrastructure/exchange/mexc/settings.py
src/app/infrastructure/exchange/mexc/ws_client.py
src/app/infrastructure/exchange/mexc/ws/__init__.py
src/app/infrastructure/exchange/mexc/ws/mexc_ws_client.py
src/app/infrastructure/external/mexc/__init__.py
src/app/infrastructure/streaming/__init__.py
src/app/infrastructure/streaming/bounded_queue.py
src/app/infrastructure/streaming/ring_buffer.py
src/app/interfaces/__init__.py
src/app/interfaces/http/__init__.py
src/app/interfaces/http/api/__init__.py
src/app/interfaces/http/api/account_routes.py
src/app/interfaces/http/api/market_routes.py
src/app/interfaces/http/api/qrl_routes.py
src/app/interfaces/http/api/system_routes.py
src/app/interfaces/http/api/tasks_routes.py
src/app/interfaces/http/api/trading_api.py
src/app/interfaces/http/api/trading_routes.py
src/app/interfaces/http/api/ws_routes.py
src/app/interfaces/http/dependencies.py
src/app/interfaces/http/pages/__init__.py
src/app/interfaces/http/pages/dashboard_routes.py
src/app/interfaces/http/pages/static/css/.gitkeep
src/app/interfaces/http/pages/static/css/dashboard.css
src/app/interfaces/http/pages/static/js/.gitkeep
src/app/interfaces/http/pages/static/js/application/dashboard.js
src/app/interfaces/http/pages/static/js/core/chart.js
src/app/interfaces/http/pages/static/js/core/dom.js
src/app/interfaces/http/pages/static/js/core/http.js
src/app/interfaces/http/pages/static/js/domain/depth.js
src/app/interfaces/http/pages/static/js/domain/order.js
src/app/interfaces/http/pages/static/js/domain/price.js
src/app/interfaces/http/pages/static/js/domain/trade.js
src/app/interfaces/http/pages/static/js/pages/dashboard-config.js
src/app/interfaces/http/pages/static/js/pages/dashboard-renderers.js
src/app/interfaces/http/pages/static/js/pages/dashboard.js
src/app/interfaces/http/pages/templates/dashboard/index.html
src/app/interfaces/http/schemas.py
src/app/interfaces/tasks/__init__.py
src/app/interfaces/tasks/entrypoints.py
src/app/interfaces/tasks/market_tasks.py
src/app/interfaces/tasks/system_tasks.py
src/app/interfaces/tasks/trading_tasks.py
tests/conftest.py
tests/test_allocation_domain_services.py
tests/test_allocation_use_case.py
tests/test_get_balance_use_case.py
tests/test_mexc_settings.py
tests/test_tasks_allocation_route.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cloudbuild.yaml">
# cloudbuild.yaml
# Minimal Cloud Build for qrl-api
# Build Docker image, push to Artifact Registry, deploy to Cloud Run

substitutions:
  _IMAGE_URI: "asia-southeast1-docker.pkg.dev/qrl-api/qrl-trading-api/qrl-trading-api:latest"

steps:
  # 1️⃣ Build Docker image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'build'
      - '-t'
      - '${_IMAGE_URI}'
      - '.'

  # 2️⃣ Push Docker image
  - name: 'gcr.io/cloud-builders/docker'
    args:
      - 'push'
      - '${_IMAGE_URI}'

  # 3️⃣ Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'gcloud'
    args:
      - 'run'
      - 'deploy'
      - 'qrl-trading-api'
      - '--image=${_IMAGE_URI}'
      - '--region=asia-southeast1'
      - '--platform=managed'
      - '--allow-unauthenticated'
      # Resource limits
      - '--memory=512Mi'
      - '--cpu=1'
      - '--min-instances=0'
      - '--max-instances=10'
      - '--concurrency=80'
      - '--timeout=300s'
      # Startup configuration - enable CPU boost for faster cold starts
      - '--cpu-boost'
      # Environment variables from Secret Manager
      - '--set-secrets=MEXC_API_KEY=mexc-api-key:latest,MEXC_SECRET_KEY=mexc-secret-key:latest'

# Timeout for the entire build
timeout: 1200s
</file>

<file path="Dockerfile">
# QRL Trading API - Dockerfile
FROM python:3.11-slim

# Set Python environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

WORKDIR /app

# Install system dependencies (curl for healthcheck)
RUN apt-get update && \
    apt-get install -y --no-install-recommends curl && \
    rm -rf /var/lib/apt/lists/*

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code and src directory (includes templates)
COPY *.py ./
COPY src/ ./src/

# Create non-root user
RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "10001" \
    appuser && \
    chown -R appuser:appuser /app

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8080

# Health check - use PORT environment variable
# Reduced start-period to 10s for faster Cloud Run startup detection
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
    CMD curl -f http://localhost:${PORT:-8080}/health || exit 1

# Start the FastAPI app via Python entrypoint
CMD ["python", "main.py"]
</file>

<file path="src/__init__.py">
"""Root package for application code."""
</file>

<file path="src/app/__init__.py">
"""Application package root for MEXC QRL/USDT bot."""
</file>

<file path="src/app/application/__init__.py">
"""Application layer use cases (no infrastructure)."""
</file>

<file path="src/app/application/account/__init__.py">
# Account bounded context.
</file>

<file path="src/app/application/account/use_cases/__init__.py">
# Account use cases.
</file>

<file path="src/app/application/events/__init__.py">
from .event_bus import EventBus, DomainEvent, EventHandler

__all__ = ["EventBus", "DomainEvent", "EventHandler"]
</file>

<file path="src/app/application/events/event_bus.py">
from typing import Any, Awaitable, Callable, Protocol, Type

DomainEvent = Any
EventHandler = Callable[[DomainEvent], Awaitable[None]]


class EventBus(Protocol):
    async def publish(self, event: DomainEvent) -> None: ...

    def subscribe(self, event_type: Type[DomainEvent], handler: EventHandler) -> None:
        ...
</file>

<file path="src/app/application/market/__init__.py">
"""Market use cases."""
</file>

<file path="src/app/application/market/mappers/__init__.py">
"""
Mappers for translating market data payloads into domain market objects.
"""
</file>

<file path="src/app/application/market/mappers/mexc.py">
from decimal import Decimal
from datetime import datetime, timezone

from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker


def map_ws_ticker_event_to_domain(event: dict) -> Ticker:
    """Map MEXC WS ticker event to Ticker VO."""
    return Ticker(
        symbol=Symbol(str(event.get("symbol", "QRLUSDT"))),
        last_price=Decimal(str(event.get("last", "0"))),
        bid_price=Decimal(str(event.get("bidPrice", "0"))),
        ask_price=Decimal(str(event.get("askPrice", "0"))),
        ts=datetime.fromtimestamp(
            int(event.get("ts", 0)) / 1000, tz=timezone.utc
        ),
    )
</file>

<file path="src/app/application/market/qrl/__init__.py">
# QRL market application use cases package
</file>

<file path="src/app/application/market/qrl/get_qrl_depth.py">
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class GetQrlDepth:
    """Fetch QRL/USDT order book snapshot."""

    def __init__(self, rest_client: QrlRestClient, limit: int = 50):
        self._client = rest_client
        self._limit = limit

    async def execute(self) -> dict:
        async with self._client as client:
            return await client.depth(limit=self._limit)
</file>

<file path="src/app/application/market/qrl/get_qrl_kline.py">
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class GetQrlKline:
    """Fetch QRL/USDT kline data."""

    def __init__(self, rest_client: QrlRestClient, interval: str = "1m", limit: int = 100):
        self._client = rest_client
        self._interval = interval
        self._limit = limit

    async def execute(self) -> list:
        async with self._client as client:
            return await client.klines(interval=self._interval, limit=self._limit)
</file>

<file path="src/app/application/market/use_cases/__init__.py">
# Market use cases.
</file>

<file path="src/app/application/ports/__init__.py">
from .exchange_gateway import ExchangeGateway

__all__ = ["ExchangeGateway"]
</file>

<file path="src/app/application/ports/exchange_gateway.py">
from typing import AsyncIterator, Protocol

from app.domain.events.market_depth_event import MarketDepthEvent
from app.domain.events.trade_event import TradeEvent
from app.domain.events.order_event import OrderEvent
from app.domain.events.balance_event import BalanceEvent
from app.domain.value_objects.symbol import Symbol


class ExchangeGateway(Protocol):
    """Application port for streaming market/account data."""

    async def subscribe_market_depth(
        self, symbol: Symbol
    ) -> AsyncIterator[MarketDepthEvent]:
        ...

    async def subscribe_trades(self, symbol: Symbol) -> AsyncIterator[TradeEvent]:
        ...

    async def subscribe_orders(self) -> AsyncIterator[OrderEvent]:
        ...

    async def subscribe_balances(self) -> AsyncIterator[BalanceEvent]:
        ...
</file>

<file path="src/app/application/system/__init__.py">
"""System use cases."""
</file>

<file path="src/app/application/system/use_cases/__init__.py">
# System use cases.
</file>

<file path="src/app/application/system/use_cases/get_server_time.py">
"""
System use case: get server time.
"""

from dataclasses import dataclass
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class GetServerTimeOutput:
    server_time: Timestamp | None = None


class GetServerTimeUseCase:
    def execute(self) -> GetServerTimeOutput:
        # TODO: retrieve via port
        return GetServerTimeOutput()
</file>

<file path="src/app/application/system/use_cases/ping.py">
"""
System use case: ping.
"""


class PingUseCase:
    def execute(self) -> None:
        # TODO: implement system ping orchestration
        return None
</file>

<file path="src/app/application/trading/__init__.py">
"""Trading use cases."""
</file>

<file path="src/app/application/trading/dto/__init__.py">
# DTOs for trading application layer.
</file>

<file path="src/app/application/trading/mappers/__init__.py">
"""
Mappers for translating external MEXC payloads into domain trading objects.
"""
</file>

<file path="src/app/application/trading/mappers/mexc.py">
from decimal import Decimal
from datetime import datetime, timezone

from src.app.domain.entities.order import Order
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId


def map_rest_order_dto_to_domain(dto: dict) -> Order:
    """Map MEXC REST order DTO (primitives) to Order entity."""
    return Order(
        order_id=OrderId(str(dto.get("orderId", ""))),
        symbol=Symbol(str(dto.get("symbol", "QRLUSDT"))),
        side=Side(str(dto.get("side", "")).upper()),
        status=OrderStatus(str(dto.get("status", "")).upper()),
        price=Decimal(str(dto.get("price", "0"))),
        quantity=Quantity(Decimal(str(dto.get("origQty", "0")))),
        created_at=Timestamp(
            datetime.fromtimestamp(int(dto.get("time", 0)) / 1000, tz=timezone.utc)
        ),
        updated_at=Timestamp(
            datetime.fromtimestamp(
                int(dto.get("updateTime", dto.get("time", 0))) / 1000, tz=timezone.utc
            )
        )
        if dto.get("updateTime")
        else None,
    )


def map_rest_trade_dto_to_domain(dto: dict) -> Trade:
    """Map MEXC REST trade DTO to Trade entity."""
    return Trade(
        trade_id=TradeId(str(dto.get("id", ""))),
        order_id=OrderId(str(dto.get("orderId", ""))),
        symbol=Symbol(str(dto.get("symbol", "QRLUSDT"))),
        side=Side(str(dto.get("side", "")).upper()),
        price=Decimal(str(dto.get("price", "0"))),
        quantity=Decimal(str(dto.get("qty", "0"))),
        fee=Decimal(str(dto["commission"])) if dto.get("commission") is not None else None,
        fee_asset=str(dto["commissionAsset"]) if dto.get("commissionAsset") else None,
        timestamp=Timestamp(
            datetime.fromtimestamp(int(dto.get("time", 0)) / 1000, tz=timezone.utc)
        ),
    )
</file>

<file path="src/app/application/trading/qrl/__init__.py">
# QRL trading use cases package
</file>

<file path="src/app/application/trading/qrl/cancel_qrl_order.py">
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class CancelQrlOrder:
    """Cancel QRL/USDT order."""

    def __init__(self, rest_client: QrlRestClient):
        self._client = rest_client

    async def execute(self, *, order_id: str | None = None, client_order_id: str | None = None) -> dict:
        async with self._client as client:
            return await client.cancel_order(order_id=order_id, client_order_id=client_order_id)
</file>

<file path="src/app/application/trading/qrl/get_qrl_order.py">
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class GetQrlOrder:
    """Fetch single QRL/USDT order details."""

    def __init__(self, rest_client: QrlRestClient):
        self._client = rest_client

    async def execute(self, *, order_id: str | None = None, client_order_id: str | None = None) -> dict:
        async with self._client as client:
            return await client.get_order(order_id=order_id, client_order_id=client_order_id)
</file>

<file path="src/app/application/trading/qrl/guards/__init__.py">
# QRL guard utilities
</file>

<file path="src/app/application/trading/qrl/guards/qrl_balance_guard.py">
from decimal import Decimal


def ensure_sufficient_balance(available_usdt: Decimal, cost: Decimal) -> None:
    if cost > available_usdt:
        raise ValueError("Insufficient USDT balance for QRL order")
</file>

<file path="src/app/application/trading/qrl/guards/qrl_duplicate_guard.py">
def prevent_duplicate(client_order_id: str | None, existing_ids: set[str] | None = None) -> None:
    if client_order_id and existing_ids and client_order_id in existing_ids:
        raise ValueError("Duplicate clientOrderId for QRL order")
</file>

<file path="src/app/application/trading/qrl/guards/qrl_price_guard.py">
from src.app.domain.value_objects.qrl_price import QrlPrice


def ensure_price_range(price: QrlPrice, min_allowed: QrlPrice | None = None, max_allowed: QrlPrice | None = None) -> None:
    if min_allowed and price.value < min_allowed.value:
        raise ValueError("Price below allowed threshold")
    if max_allowed and price.value > max_allowed.value:
        raise ValueError("Price above allowed threshold")
</file>

<file path="src/app/application/trading/qrl/guards/qrl_rate_limit_guard.py">
def enforce_rate_limit(remaining_requests: int) -> None:
    if remaining_requests <= 0:
        raise ValueError("Rate limit reached for QRL operations")
</file>

<file path="src/app/application/trading/qrl/place_qrl_order.py">
from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.qrl_quantity import QrlQuantity
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


class PlaceQrlOrder:
    """Place QRL/USDT order with fixed symbol and validated VOs."""

    def __init__(self, rest_client: QrlRestClient):
        self._client = rest_client

    async def execute(
        self,
        *,
        side: str,
        order_type: str,
        price: QrlPrice | None,
        quantity: QrlQuantity,
        time_in_force: str | None = "GTC",
        client_order_id: str | None = None,
    ) -> dict:
        async with self._client as client:
            return await client.create_order(
                side=side,
                order_type=order_type,
                price=str(price.value) if price else None,
                quantity=str(quantity.value),
                time_in_force=time_in_force,
                client_order_id=client_order_id,
            )
</file>

<file path="src/app/application/trading/use_cases/__init__.py">
# Trading use cases.
</file>

<file path="src/app/application/trading/use_cases/cancel_order.py">
"""Trading use case: cancel existing order for QRL/USDT."""

from dataclasses import dataclass

from src.app.application.exchange.mexc_service import CancelOrderRequest, MexcService, build_mexc_service
from src.app.application.trading.use_cases.place_order import _serialize_order
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


@dataclass
class CancelOrderInput:
    symbol: str
    order_id: str | None = None
    client_order_id: str | None = None


class CancelOrderUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, data: CancelOrderInput) -> dict:
        request = CancelOrderRequest(
            symbol=Symbol(data.symbol),
            order_id=data.order_id,
            client_order_id=data.client_order_id,
        )
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            order = await svc.cancel_order(request)
        return _serialize_order(order)
</file>

<file path="src/app/application/trading/use_cases/get_kline.py">
from dataclasses import dataclass
from typing import List

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.domain.value_objects.kline import KLine
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _serialize_kline(k: KLine) -> dict:
    return {
        "open": str(k.open),
        "high": str(k.high),
        "low": str(k.low),
        "close": str(k.close),
        "volume": str(k.volume),
        "interval": k.interval,
        "timestamp": k.timestamp.value.isoformat(),
    }


@dataclass
class GetKlineUseCase:
    settings: MexcSettings | None = None

    async def execute(self, symbol: str, interval: str, limit: int = 100) -> List[dict]:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            klines = await svc.get_kline(Symbol(symbol), interval=interval, limit=limit)
        return [_serialize_kline(k) for k in klines]
</file>

<file path="src/app/application/trading/use_cases/get_order.py">
"""Trading use case: get single order."""

from dataclasses import dataclass

from src.app.application.exchange.mexc_service import GetOrderRequest, MexcService, build_mexc_service
from src.app.application.trading.use_cases.place_order import _serialize_order
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


@dataclass
class GetOrderInput:
    symbol: str
    order_id: str | None = None
    client_order_id: str | None = None


class GetOrderUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, data: GetOrderInput) -> dict:
        request = GetOrderRequest(
            symbol=Symbol(data.symbol),
            order_id=data.order_id,
            client_order_id=data.client_order_id,
        )
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            order = await svc.get_order(request)
        return _serialize_order(order)
</file>

<file path="src/app/application/trading/use_cases/get_price.py">
from dataclasses import dataclass

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _serialize_price(price: Price) -> dict:
    return {
        "bid": str(price.bid),
        "ask": str(price.ask),
        "last": str(price.last),
        "timestamp": price.timestamp.value.isoformat(),
    }


@dataclass
class GetPriceUseCase:
    settings: MexcSettings | None = None

    async def execute(self, symbol: str) -> dict:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            price = await svc.get_price(Symbol(symbol))
        return _serialize_price(price)
</file>

<file path="src/app/application/trading/use_cases/list_orders.py">
"""Trading use case: list open/closed orders."""

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.application.trading.use_cases.place_order import _serialize_order
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class ListOrdersUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, symbol: str | None = None) -> list[dict]:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            orders = await svc.list_open_orders(Symbol(symbol) if symbol else None)
        return [_serialize_order(order) for order in orders]
</file>

<file path="src/app/application/trading/use_cases/list_trades.py">
"""Trading use case: list trades for QRL/USDT."""

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _serialize_trade(trade: Trade) -> dict:
    return {
        "trade_id": trade.trade_id.value,
        "order_id": trade.order_id.value,
        "symbol": trade.symbol.value,
        "side": trade.side.value,
        "price": str(trade.price),
        "quantity": str(trade.quantity),
        "fee": str(trade.fee) if trade.fee is not None else None,
        "fee_asset": trade.fee_asset,
        "timestamp": trade.timestamp.value.isoformat(),
    }


class ListTradesUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, symbol: str) -> list[dict]:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            trades = await svc.list_trades(Symbol(symbol))
        return [_serialize_trade(trade) for trade in trades]
</file>

<file path="src/app/application/trading/use_cases/place_order.py">
"""Trading use case: place order for QRL/USDT."""

from dataclasses import dataclass
from decimal import Decimal

from src.app.application.exchange.mexc_service import MexcService, PlaceOrderRequest, build_mexc_service
from src.app.domain.entities.order import Order
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _serialize_order(order: Order) -> dict:
    return {
        "order_id": order.order_id.value,
        "symbol": order.symbol.value,
        "side": order.side.value,
        "type": order.order_type.value,
        "status": order.status.value,
        "price": str(order.price),
        "quantity": str(order.quantity.value),
        "executed_quantity": str(order.executed_quantity) if order.executed_quantity else None,
        "cumulative_quote_quantity": str(order.cumulative_quote_quantity)
        if order.cumulative_quote_quantity
        else None,
        "time_in_force": order.time_in_force.value if order.time_in_force else None,
        "client_order_id": order.client_order_id,
        "created_at": order.created_at.value.isoformat(),
        "updated_at": order.updated_at.value.isoformat() if order.updated_at else None,
    }


@dataclass
class PlaceOrderInput:
    symbol: str
    side: str
    quantity: Decimal
    price: Decimal | None
    order_type: str = "LIMIT"
    time_in_force: str = "GTC"
    client_order_id: str | None = None


class PlaceOrderUseCase:
    settings: MexcSettings | None = None

    def __init__(self, settings: MexcSettings | None = None):
        self.settings = settings

    async def execute(self, data: PlaceOrderInput) -> dict:
        request = PlaceOrderRequest(
            symbol=Symbol(data.symbol),
            side=Side(data.side),
            order_type=OrderType(data.order_type),
            quantity=Quantity(data.quantity),
            price=Price.from_single(data.price) if data.price is not None else None,
            time_in_force=TimeInForce(data.time_in_force) if data.time_in_force else None,
            client_order_id=data.client_order_id,
        )
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            order = await svc.place_order(request)
        return _serialize_order(order)
</file>

<file path="src/app/domain/__init__.py">
"""Domain layer root."""
</file>

<file path="src/app/domain/entities/account.py">
from dataclasses import dataclass
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class Account:
    """Spot account snapshot."""

    can_trade: bool
    update_time: Timestamp
    balances: list[Balance]
</file>

<file path="src/app/domain/entities/order.py">
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal

from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class Order:
    """Order entity limited to QRL/USDT spot."""

    order_id: OrderId
    symbol: Symbol
    side: Side
    order_type: OrderType
    status: OrderStatus
    price: Decimal
    quantity: Quantity
    created_at: Timestamp
    time_in_force: TimeInForce | None = None
    client_order_id: str | None = None
    executed_quantity: Decimal | None = None
    cumulative_quote_quantity: Decimal | None = None
    updated_at: Timestamp | None = None
</file>

<file path="src/app/domain/entities/trade.py">
from dataclasses import dataclass
from decimal import Decimal

from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId


@dataclass
class Trade:
    """Trade fill record."""

    trade_id: TradeId
    order_id: OrderId
    symbol: Symbol
    side: Side
    price: Decimal
    quantity: Decimal
    fee: Decimal | None
    fee_asset: str | None
    timestamp: Timestamp
</file>

<file path="src/app/domain/entities/trading_pair.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class TradingPair:
    """Represents a trading pair such as QRL/USDT."""

    base_currency: str
    quote_currency: str

    @property
    def symbol(self) -> str:
        return f"{self.base_currency}{self.quote_currency}".upper()
</file>

<file path="src/app/domain/events/__init__.py">
from .balance_event import BalanceEvent
from .kline_updated_event import KLineUpdatedEvent
from .market_depth_event import MarketDepthEvent
from .order_event import OrderEvent
from .price_updated_event import PriceUpdatedEvent
from .trade_event import TradeEvent

__all__ = [
    "BalanceEvent",
    "KLineUpdatedEvent",
    "MarketDepthEvent",
    "OrderEvent",
    "PriceUpdatedEvent",
    "TradeEvent",
]
</file>

<file path="src/app/domain/events/balance_event.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class BalanceEvent:
    """Account balance snapshot/update."""

    asset: str
    free: Decimal
    locked: Decimal
    timestamp: int
</file>

<file path="src/app/domain/events/kline_updated_event.py">
from dataclasses import dataclass
from typing import Iterable

from src.app.domain.entities.trading_pair import TradingPair
from src.app.domain.value_objects.kline import KLine


@dataclass(frozen=True)
class KLineUpdatedEvent:
    trading_pair: TradingPair
    klines: Iterable[KLine]
</file>

<file path="src/app/domain/events/market_depth_event.py">
from dataclasses import dataclass
from typing import List, Tuple

from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol


@dataclass(frozen=True)
class MarketDepthEvent:
    """
    Order book depth snapshot/update at a point in time.

    Notes:
        - Bids/asks are sorted by price on the exchange side.
        - Versions allow consumers to detect gaps and request replay.
    """

    symbol: Symbol
    bids: List[Tuple[Price, Quantity]]
    asks: List[Tuple[Price, Quantity]]
    event_type: str | None
    from_version: str | None
    to_version: str | None
</file>

<file path="src/app/domain/events/order_event.py">
from dataclasses import dataclass

from app.domain.value_objects.order_id import OrderId
from app.domain.value_objects.order_status import OrderStatus
from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol


@dataclass(frozen=True)
class OrderEvent:
    """Private order update event."""

    order_id: OrderId
    symbol: Symbol
    price: Price
    quantity: Quantity
    status: OrderStatus
    timestamp: int
</file>

<file path="src/app/domain/events/price_updated_event.py">
from dataclasses import dataclass
from src.app.domain.entities.trading_pair import TradingPair
from src.app.domain.value_objects.price import Price


@dataclass(frozen=True)
class PriceUpdatedEvent:
    trading_pair: TradingPair
    price: Price
</file>

<file path="src/app/domain/events/trade_event.py">
from dataclasses import dataclass

from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol
from app.domain.value_objects.trade_id import TradeId


@dataclass(frozen=True)
class TradeEvent:
    """Public trade tick."""

    trade_id: TradeId
    symbol: Symbol
    price: Price
    quantity: Quantity
    is_buyer_maker: bool
    timestamp: int
</file>

<file path="src/app/domain/value_objects/api_key.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class ApiKey:
    """API key used for authenticated MEXC requests."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("API key cannot be empty")
</file>

<file path="src/app/domain/value_objects/api_secret.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class ApiSecret:
    """API secret used to sign requests."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("API secret cannot be empty")
</file>

<file path="src/app/domain/value_objects/balance.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class Balance:
    """Asset balance with free and locked amounts."""

    asset: str
    free: Decimal
    locked: Decimal

    def __post_init__(self):
        if not self.asset:
            raise ValueError("Asset symbol cannot be empty")
        if self.free < 0 or self.locked < 0:
            raise ValueError("Balance amounts cannot be negative")
</file>

<file path="src/app/domain/value_objects/client_order_id.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class ClientOrderId:
    """Client-supplied idempotency key for orders."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("Client order id cannot be empty")
        if len(self.value) > 32:
            raise ValueError("Client order id must be 32 characters or fewer")
</file>

<file path="src/app/domain/value_objects/kline.py">
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal

from src.app.domain.value_objects.timestamp import Timestamp


@dataclass(frozen=True)
class KLine:
    """Single candlestick for a trading pair."""

    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    interval: str
    timestamp: Timestamp

    def __post_init__(self):
        if min(self.open, self.high, self.low, self.close) < 0:
            raise ValueError("KLine prices cannot be negative")
        if self.volume < 0:
            raise ValueError("KLine volume cannot be negative")
        if not self.interval:
            raise ValueError("KLine interval is required")

    @classmethod
    def from_raw(
        cls,
        open_price: Decimal,
        high: Decimal,
        low: Decimal,
        close: Decimal,
        volume: Decimal,
        interval: str,
        timestamp_ms: int,
    ) -> "KLine":
        ts = Timestamp(datetime.fromtimestamp(timestamp_ms / 1000, tz=timezone.utc))
        return cls(open=open_price, high=high, low=low, close=close, volume=volume, interval=interval, timestamp=ts)
</file>

<file path="src/app/domain/value_objects/order_id.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class OrderId:
    """Order identifier returned by MEXC."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("OrderId cannot be empty")
</file>

<file path="src/app/domain/value_objects/order_status.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class OrderStatus:
    """Order status with a minimal allowed set."""

    value: str

    _allowed = {
        "NEW",
        "PARTIALLY_FILLED",
        "FILLED",
        "CANCELED",
        "REJECTED",
    }

    def __post_init__(self):
        if self.value not in self._allowed:
            raise ValueError(f"OrderStatus must be one of {sorted(self._allowed)}")
</file>

<file path="src/app/domain/value_objects/order_type.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class OrderType:
    """Supported MEXC order types."""

    value: str

    _allowed = {"LIMIT", "MARKET"}

    def __post_init__(self):
        if self.value not in self._allowed:
            raise ValueError(f"OrderType must be one of {sorted(self._allowed)}")
</file>

<file path="src/app/domain/value_objects/price.py">
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal

from src.app.domain.value_objects.timestamp import Timestamp


@dataclass(frozen=True)
class Price:
    """Quote for a trading pair with bid/ask/last and timestamp."""

    bid: Decimal
    ask: Decimal
    last: Decimal
    timestamp: Timestamp

    def __post_init__(self):
        if self.bid <= 0 or self.ask <= 0 or self.last <= 0:
            raise ValueError("Price values must be positive")

    @classmethod
    def from_single(cls, value: Decimal, ts: datetime | None = None) -> "Price":
        """Construct a Price when only a single quote is available."""
        stamp = Timestamp(ts or datetime.now(timezone.utc))
        return cls(bid=value, ask=value, last=value, timestamp=stamp)
</file>

<file path="src/app/domain/value_objects/qrl_price.py">
from __future__ import annotations

from decimal import Decimal, ROUND_DOWN, getcontext
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from src.app.domain.value_objects.qrl_quantity import QrlQuantity

getcontext().prec = 28


class QrlPrice:
    """
    QRL/USDT 專用價格 Value Object
    - 不可變
    - 強制 tick size
    """

    TICK_SIZE = Decimal("0.0001")
    MIN_PRICE = TICK_SIZE

    def __init__(self, value: Decimal | str | float):
        self._value = self._normalize(Decimal(str(value)))

    @staticmethod
    def _normalize(value: Decimal) -> Decimal:
        if value <= 0:
            raise ValueError("QRL price must be > 0")

        normalized = (value // QrlPrice.TICK_SIZE) * QrlPrice.TICK_SIZE

        if normalized < QrlPrice.MIN_PRICE:
            raise ValueError("QRL price below minimum tick size")

        return normalized.quantize(QrlPrice.TICK_SIZE, rounding=ROUND_DOWN)

    @property
    def value(self) -> Decimal:
        return self._value

    def __str__(self) -> str:
        return format(self._value, "f")

    def __repr__(self) -> str:
        return f"QrlPrice({self._value})"

    def multiply(self, quantity: "QrlQuantity") -> Decimal:
        return (self._value * quantity.value).quantize(
            Decimal("0.00000001"), rounding=ROUND_DOWN
        )
</file>

<file path="src/app/domain/value_objects/qrl_quantity.py">
from __future__ import annotations

from decimal import Decimal, ROUND_DOWN, getcontext

getcontext().prec = 28


class QrlQuantity:
    """
    QRL 專用數量 Value Object
    - 不可變
    - 防 fat finger
    """

    STEP_SIZE = Decimal("1")
    MIN_QTY = Decimal("1")
    MAX_QTY = Decimal("1000000")

    def __init__(self, value: Decimal | str | int | float):
        self._value = self._normalize(Decimal(str(value)))

    @staticmethod
    def _normalize(value: Decimal) -> Decimal:
        if value <= 0:
            raise ValueError("QRL quantity must be > 0")

        normalized = (value // QrlQuantity.STEP_SIZE) * QrlQuantity.STEP_SIZE

        if normalized < QrlQuantity.MIN_QTY:
            raise ValueError("QRL quantity below minimum")

        if normalized > QrlQuantity.MAX_QTY:
            raise ValueError("QRL quantity exceeds safety limit")

        return normalized.quantize(QrlQuantity.STEP_SIZE, rounding=ROUND_DOWN)

    @property
    def value(self) -> Decimal:
        return self._value

    def __str__(self) -> str:
        return format(self._value, "f")

    def __repr__(self) -> str:
        return f"QrlQuantity({self._value})"
</file>

<file path="src/app/domain/value_objects/qrl_usdt_pair.py">
class QrlUsdtPair:
    """QRL/USDT 專用交易對，不允許動態建構."""

    SYMBOL = "QRLUSDT"
    BASE = "QRL"
    QUOTE = "USDT"

    @classmethod
    def symbol(cls) -> str:
        return cls.SYMBOL

    @classmethod
    def base(cls) -> str:
        return cls.BASE

    @classmethod
    def quote(cls) -> str:
        return cls.QUOTE
</file>

<file path="src/app/domain/value_objects/quantity.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class Quantity:
    """Positive trade quantity."""

    value: Decimal

    def __post_init__(self):
        if self.value <= 0:
            raise ValueError("Quantity must be positive")
</file>

<file path="src/app/domain/value_objects/side.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class Side:
    """Order side constrained to BUY/SELL."""

    value: str

    def __post_init__(self):
        if self.value not in ("BUY", "SELL"):
            raise ValueError("Side must be BUY or SELL")
</file>

<file path="src/app/domain/value_objects/sub_account_id.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class SubAccountId:
    """Numeric sub-account identifier used by MEXC spot API."""

    value: int

    def __post_init__(self):
        if self.value <= 0:
            raise ValueError("SubAccountId must be a positive integer")
</file>

<file path="src/app/domain/value_objects/symbol.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class Symbol:
    """Trading symbol constrained to QRL/USDT scope."""

    value: str

    def __post_init__(self):
        normalized = self.value.replace("/", "").upper()
        if normalized != "QRLUSDT":
            raise ValueError("Symbol must be QRL/USDT")
</file>

<file path="src/app/domain/value_objects/ticker.py">
from dataclasses import dataclass
from decimal import Decimal
from datetime import datetime, timezone

from src.app.domain.value_objects.symbol import Symbol


@dataclass(frozen=True)
class Ticker:
    """Minimal ticker snapshot for QRL/USDT."""

    symbol: Symbol
    last_price: Decimal
    bid_price: Decimal
    ask_price: Decimal
    ts: datetime

    def __post_init__(self):
        if self.last_price <= 0 or self.bid_price <= 0 or self.ask_price <= 0:
            raise ValueError("Ticker prices must be positive")
        if self.bid_price > self.ask_price:
            raise ValueError("Bid price cannot exceed ask price")
        if self.ts.tzinfo is None:
            object.__setattr__(self, "ts", self.ts.replace(tzinfo=timezone.utc))
</file>

<file path="src/app/domain/value_objects/time_in_force.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class TimeInForce:
    """Time in force constraints for limit orders."""

    value: str

    _allowed = {"GTC", "IOC", "FOK"}

    def __post_init__(self):
        if self.value not in self._allowed:
            raise ValueError(f"TimeInForce must be one of {sorted(self._allowed)}")
</file>

<file path="src/app/domain/value_objects/timestamp.py">
from dataclasses import dataclass
from datetime import datetime, timezone


@dataclass(frozen=True)
class Timestamp:
    """UTC timestamp wrapper."""

    value: datetime

    def __post_init__(self):
        if self.value.tzinfo is None:
            object.__setattr__(self, "value", self.value.replace(tzinfo=timezone.utc))
</file>

<file path="src/app/domain/value_objects/trade_id.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class TradeId:
    """Trade identifier returned by MEXC."""

    value: str

    def __post_init__(self):
        if not self.value:
            raise ValueError("TradeId cannot be empty")
</file>

<file path="src/app/infrastructure/__init__.py">
"""Infrastructure layer placeholder (no implementations yet)."""
</file>

<file path="src/app/infrastructure/config.py">
class Config:
    """Placeholder config for skeleton build."""

    LOG_LEVEL = "INFO"
    LOG_FORMAT = "text"
    PORT = 8000
    HOST = "0.0.0.0"
    DEBUG = False


config = Config()
</file>

<file path="src/app/infrastructure/event_bus/__init__.py">
from .in_memory_event_bus import InMemoryEventBus

__all__ = ["InMemoryEventBus"]
</file>

<file path="src/app/infrastructure/event_bus/in_memory_event_bus.py">
from collections import defaultdict
from typing import Dict, List, Type

from app.application.events.event_bus import DomainEvent, EventBus, EventHandler


class InMemoryEventBus(EventBus):
    """
    Minimal in-memory event bus for wiring domain events to handlers.

    Infrastructure concern; replaceable with Redis/Kafka later.
    """

    def __init__(self):
        self._handlers: Dict[Type, List[EventHandler]] = defaultdict(list)

    def subscribe(self, event_type: Type, handler: EventHandler) -> None:
        self._handlers[event_type].append(handler)

    async def publish(self, event: DomainEvent) -> None:
        for handler in self._handlers.get(type(event), []):
            await handler(event)
</file>

<file path="src/app/infrastructure/exchange/__init__.py">
# Technical exchange integrations live here.
</file>

<file path="src/app/infrastructure/exchange/mexc_api_client.py">
from datetime import datetime, timezone
from decimal import Decimal
from typing import Any, Iterable

from src.app.domain.entities.trading_pair import TradingPair
from src.app.domain.value_objects.kline import KLine
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.infrastructure.exchange.mexc.rest_client import MexcRestClient


class MexcApiClient:
    """High-level client that maps REST responses to domain value objects."""

    def __init__(self, rest_client: MexcRestClient):
        self._rest_client = rest_client

    async def __aenter__(self) -> "MexcApiClient":
        await self._rest_client.__aenter__()
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self._rest_client.__aexit__(exc_type, exc, tb)

    async def get_price(self, pair: TradingPair) -> Price:
        payload = await self._rest_client.ticker_24h(symbol=pair.symbol)
        bid = Decimal(payload.get("bidPrice", "0"))
        ask = Decimal(payload.get("askPrice", "0"))
        last = Decimal(payload.get("lastPrice", payload.get("last", "0")))
        ts_value = payload.get("closeTime") or payload.get("close_time") or int(datetime.now(tz=timezone.utc).timestamp() * 1000)
        timestamp = Timestamp(datetime.fromtimestamp(int(ts_value) / 1000, tz=timezone.utc))
        return Price(bid=bid, ask=ask, last=last, timestamp=timestamp)

    async def get_klines(self, pair: TradingPair, interval: str, limit: int = 100) -> list[KLine]:
        raw_list = await self._rest_client.klines(symbol=pair.symbol, interval=interval, limit=limit)
        klines: list[KLine] = []
        for item in raw_list:
            if not isinstance(item, Iterable):
                continue
            open_time = int(item[0])
            open_price = Decimal(item[1])
            high = Decimal(item[2])
            low = Decimal(item[3])
            close = Decimal(item[4])
            volume = Decimal(item[5])
            klines.append(KLine.from_raw(open_price, high, low, close, volume, interval, open_time))
        return klines
</file>

<file path="src/app/infrastructure/exchange/mexc/__init__.py">
# MEXC exchange integration namespace.
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/__init__.py">
from .balance_mapper import balance_proto_to_domain
from .depth_mapper import depth_proto_to_domain
from .market_event_adapter import MexcExchangeGateway
from .order_mapper import order_proto_to_domain
from .trade_mapper import trade_proto_to_domain

__all__ = [
    "MexcExchangeGateway",
    "balance_proto_to_domain",
    "depth_proto_to_domain",
    "order_proto_to_domain",
    "trade_proto_to_domain",
]
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/balance_mapper.py">
from decimal import Decimal

from app.domain.events.balance_event import BalanceEvent
from app.infrastructure.exchange.mexc.generated import PrivateAccountV3Api_pb2


def balance_proto_to_domain(
    proto: PrivateAccountV3Api_pb2.PrivateAccountV3ApiBalance,
) -> BalanceEvent:
    return BalanceEvent(
        asset=proto.asset,
        free=Decimal(proto.free),
        locked=Decimal(proto.locked),
        timestamp=proto.timestamp,
    )
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/depth_mapper.py">
from app.domain.events.market_depth_event import MarketDepthEvent
from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol
from app.infrastructure.exchange.mexc.generated import PublicAggreDepthsV3Api_pb2


def depth_proto_to_domain(
    symbol: Symbol, proto: PublicAggreDepthsV3Api_pb2.PublicAggreDepthsV3Api
) -> MarketDepthEvent:
    bids = [
        (Price(float(item.price)), Quantity(float(item.quantity))) for item in proto.bids
    ]
    asks = [
        (Price(float(item.price)), Quantity(float(item.quantity))) for item in proto.asks
    ]

    return MarketDepthEvent(
        symbol=symbol,
        bids=bids,
        asks=asks,
        event_type=proto.eventType if hasattr(proto, "eventType") else None,
        from_version=proto.fromVersion if hasattr(proto, "fromVersion") else None,
        to_version=proto.toVersion if hasattr(proto, "toVersion") else None,
    )
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/market_event_adapter.py">
from typing import AsyncIterator

from app.application.ports.exchange_gateway import ExchangeGateway
from app.domain.events.balance_event import BalanceEvent
from app.domain.events.market_depth_event import MarketDepthEvent
from app.domain.events.order_event import OrderEvent
from app.domain.events.trade_event import TradeEvent
from app.domain.value_objects.symbol import Symbol
from app.infrastructure.exchange.mexc.generated import (
    PrivateAccountV3Api_pb2,
    PrivateOrdersV3Api_pb2,
    PublicAggreDepthsV3Api_pb2,
    PublicDealsV3Api_pb2,
)
from app.infrastructure.exchange.mexc.ws.mexc_ws_client import MexcWebSocketClient
from .balance_mapper import balance_proto_to_domain
from .order_mapper import order_proto_to_domain
from .trade_mapper import trade_proto_to_domain
from .depth_mapper import depth_proto_to_domain


class MexcExchangeGateway(ExchangeGateway):
    """Infrastructure adapter that translates MEXC WS protobuf into domain events."""

    def __init__(self, ws_client: MexcWebSocketClient):
        self._ws = ws_client

    async def subscribe_market_depth(
        self, symbol: Symbol
    ) -> AsyncIterator[MarketDepthEvent]:
        async for proto in self._ws.subscribe("depth", symbol.value):
            if isinstance(proto, PublicAggreDepthsV3Api_pb2.PublicAggreDepthsV3Api):
                yield depth_proto_to_domain(symbol, proto)

    async def subscribe_trades(self, symbol: Symbol) -> AsyncIterator[TradeEvent]:
        async for proto in self._ws.subscribe("deals", symbol.value):
            if isinstance(proto, PublicDealsV3Api_pb2.PublicDealsV3Api):
                for item in proto.deals:
                    yield trade_proto_to_domain(symbol, item)

    async def subscribe_orders(self) -> AsyncIterator[OrderEvent]:
        async for proto in self._ws.subscribe("orders"):
            if isinstance(proto, PrivateOrdersV3Api_pb2.PrivateOrdersV3Api):
                yield order_proto_to_domain(proto)

    async def subscribe_balances(self) -> AsyncIterator[BalanceEvent]:
        async for proto in self._ws.subscribe("balances"):
            if isinstance(proto, PrivateAccountV3Api_pb2.PrivateAccountV3Api):
                yield balance_proto_to_domain(proto)
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/order_mapper.py">
from app.domain.events.order_event import OrderEvent
from app.domain.value_objects.order_id import OrderId
from app.domain.value_objects.order_status import OrderStatus
from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol
from app.infrastructure.exchange.mexc.generated import PrivateOrdersV3Api_pb2


def order_proto_to_domain(proto: PrivateOrdersV3Api_pb2.PrivateOrdersV3Api) -> OrderEvent:
    # MEXC push includes status as int; default to NEW when unmapped
    status_value = "NEW"
    try:
        status_value = str(proto.status).upper()
    except Exception:
        status_value = "NEW"

    try:
        status = OrderStatus(status_value)
    except ValueError:
        status = OrderStatus("NEW")

    return OrderEvent(
        order_id=OrderId(proto.id),
        symbol=Symbol("QRLUSDT"),
        price=Price(float(proto.price)),
        quantity=Quantity(float(proto.quantity)),
        status=status,
        timestamp=proto.createTime,
    )
</file>

<file path="src/app/infrastructure/exchange/mexc/adapters/trade_mapper.py">
from app.domain.events.trade_event import TradeEvent
from app.domain.value_objects.price import Price
from app.domain.value_objects.quantity import Quantity
from app.domain.value_objects.symbol import Symbol
from app.domain.value_objects.trade_id import TradeId
from app.infrastructure.exchange.mexc.generated import PublicDealsV3Api_pb2


def trade_proto_to_domain(
    symbol: Symbol, proto: PublicDealsV3Api_pb2.PublicDealsV3ApiItem
) -> TradeEvent:
    # tradeType: 1=buy, 2=sell in MEXC WS push; treat 2 as maker sell
    is_buyer_maker = proto.tradeType == 2
    return TradeEvent(
        trade_id=TradeId(str(proto.time)),
        symbol=symbol,
        price=Price(float(proto.price)),
        quantity=Quantity(float(proto.quantity)),
        is_buyer_maker=is_buyer_maker,
        timestamp=proto.time,
    )
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/__init__.py">
"""Generated protobuf modules for MEXC WebSocket V3 APIs."""
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PrivateAccountV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PrivateAccountV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PrivateAccountV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x19PrivateAccountV3Api.proto\"\xba\x01\n\x13PrivateAccountV3Api\x12\x11\n\tvcoinName\x18\x01 \x01(\t\x12\x0e\n\x06\x63oinId\x18\x02 \x01(\t\x12\x15\n\rbalanceAmount\x18\x03 \x01(\t\x12\x1b\n\x13\x62\x61lanceAmountChange\x18\x04 \x01(\t\x12\x14\n\x0c\x66rozenAmount\x18\x05 \x01(\t\x12\x1a\n\x12\x66rozenAmountChange\x18\x06 \x01(\t\x12\x0c\n\x04type\x18\x07 \x01(\t\x12\x0c\n\x04time\x18\x08 \x01(\x03\x42<\n\x1c\x63om.mxc.push.common.protobufB\x18PrivateAccountV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PrivateAccountV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\030PrivateAccountV3ApiProtoH\001P\001'
  _globals['_PRIVATEACCOUNTV3API']._serialized_start=30
  _globals['_PRIVATEACCOUNTV3API']._serialized_end=216
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PrivateDealsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PrivateDealsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PrivateDealsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x17PrivateDealsV3Api.proto\"\xec\x01\n\x11PrivateDealsV3Api\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\t\x12\x0e\n\x06\x61mount\x18\x03 \x01(\t\x12\x11\n\ttradeType\x18\x04 \x01(\x05\x12\x0f\n\x07isMaker\x18\x05 \x01(\x08\x12\x13\n\x0bisSelfTrade\x18\x06 \x01(\x08\x12\x0f\n\x07tradeId\x18\x07 \x01(\t\x12\x15\n\rclientOrderId\x18\x08 \x01(\t\x12\x0f\n\x07orderId\x18\t \x01(\t\x12\x11\n\tfeeAmount\x18\n \x01(\t\x12\x13\n\x0b\x66\x65\x65\x43urrency\x18\x0b \x01(\t\x12\x0c\n\x04time\x18\x0c \x01(\x03\x42:\n\x1c\x63om.mxc.push.common.protobufB\x16PrivateDealsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PrivateDealsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\026PrivateDealsV3ApiProtoH\001P\001'
  _globals['_PRIVATEDEALSV3API']._serialized_start=28
  _globals['_PRIVATEDEALSV3API']._serialized_end=264
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PrivateOrdersV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PrivateOrdersV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PrivateOrdersV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x18PrivateOrdersV3Api.proto\"\xe8\x05\n\x12PrivateOrdersV3Api\x12\n\n\x02id\x18\x01 \x01(\t\x12\x10\n\x08\x63lientId\x18\x02 \x01(\t\x12\r\n\x05price\x18\x03 \x01(\t\x12\x10\n\x08quantity\x18\x04 \x01(\t\x12\x0e\n\x06\x61mount\x18\x05 \x01(\t\x12\x10\n\x08\x61vgPrice\x18\x06 \x01(\t\x12\x11\n\torderType\x18\x07 \x01(\x05\x12\x11\n\ttradeType\x18\x08 \x01(\x05\x12\x0f\n\x07isMaker\x18\t \x01(\x08\x12\x14\n\x0cremainAmount\x18\n \x01(\t\x12\x16\n\x0eremainQuantity\x18\x0b \x01(\t\x12\x1d\n\x10lastDealQuantity\x18\x0c \x01(\tH\x00\x88\x01\x01\x12\x1a\n\x12\x63umulativeQuantity\x18\r \x01(\t\x12\x18\n\x10\x63umulativeAmount\x18\x0e \x01(\t\x12\x0e\n\x06status\x18\x0f \x01(\x05\x12\x12\n\ncreateTime\x18\x10 \x01(\x03\x12\x13\n\x06market\x18\x11 \x01(\tH\x01\x88\x01\x01\x12\x18\n\x0btriggerType\x18\x12 \x01(\x05H\x02\x88\x01\x01\x12\x19\n\x0ctriggerPrice\x18\x13 \x01(\tH\x03\x88\x01\x01\x12\x12\n\x05state\x18\x14 \x01(\x05H\x04\x88\x01\x01\x12\x12\n\x05ocoId\x18\x15 \x01(\tH\x05\x88\x01\x01\x12\x18\n\x0brouteFactor\x18\x16 \x01(\tH\x06\x88\x01\x01\x12\x15\n\x08symbolId\x18\x17 \x01(\tH\x07\x88\x01\x01\x12\x15\n\x08marketId\x18\x18 \x01(\tH\x08\x88\x01\x01\x12\x1d\n\x10marketCurrencyId\x18\x19 \x01(\tH\t\x88\x01\x01\x12\x17\n\ncurrencyId\x18\x1a \x01(\tH\n\x88\x01\x01\x42\x13\n\x11_lastDealQuantityB\t\n\x07_marketB\x0e\n\x0c_triggerTypeB\x0f\n\r_triggerPriceB\x08\n\x06_stateB\x08\n\x06_ocoIdB\x0e\n\x0c_routeFactorB\x0b\n\t_symbolIdB\x0b\n\t_marketIdB\x13\n\x11_marketCurrencyIdB\r\n\x0b_currencyIdB;\n\x1c\x63om.mxc.push.common.protobufB\x17PrivateOrdersV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PrivateOrdersV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\027PrivateOrdersV3ApiProtoH\001P\001'
  _globals['_PRIVATEORDERSV3API']._serialized_start=29
  _globals['_PRIVATEORDERSV3API']._serialized_end=773
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicAggreBookTickerV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicAggreBookTickerV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicAggreBookTickerV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n PublicAggreBookTickerV3Api.proto\"j\n\x1aPublicAggreBookTickerV3Api\x12\x10\n\x08\x62idPrice\x18\x01 \x01(\t\x12\x13\n\x0b\x62idQuantity\x18\x02 \x01(\t\x12\x10\n\x08\x61skPrice\x18\x03 \x01(\t\x12\x13\n\x0b\x61skQuantity\x18\x04 \x01(\tBC\n\x1c\x63om.mxc.push.common.protobufB\x1fPublicAggreBookTickerV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicAggreBookTickerV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\037PublicAggreBookTickerV3ApiProtoH\001P\001'
  _globals['_PUBLICAGGREBOOKTICKERV3API']._serialized_start=36
  _globals['_PUBLICAGGREBOOKTICKERV3API']._serialized_end=142
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicAggreDealsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicAggreDealsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicAggreDealsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1bPublicAggreDealsV3Api.proto\"U\n\x15PublicAggreDealsV3Api\x12)\n\x05\x64\x65\x61ls\x18\x01 \x03(\x0b\x32\x1a.PublicAggreDealsV3ApiItem\x12\x11\n\teventType\x18\x02 \x01(\t\"]\n\x19PublicAggreDealsV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\t\x12\x11\n\ttradeType\x18\x03 \x01(\x05\x12\x0c\n\x04time\x18\x04 \x01(\x03\x42>\n\x1c\x63om.mxc.push.common.protobufB\x1aPublicAggreDealsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicAggreDealsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\032PublicAggreDealsV3ApiProtoH\001P\001'
  _globals['_PUBLICAGGREDEALSV3API']._serialized_start=31
  _globals['_PUBLICAGGREDEALSV3API']._serialized_end=116
  _globals['_PUBLICAGGREDEALSV3APIITEM']._serialized_start=118
  _globals['_PUBLICAGGREDEALSV3APIITEM']._serialized_end=211
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicAggreDepthsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicAggreDepthsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicAggreDepthsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1cPublicAggreDepthsV3Api.proto\"\xa7\x01\n\x16PublicAggreDepthsV3Api\x12(\n\x04\x61sks\x18\x01 \x03(\x0b\x32\x1a.PublicAggreDepthV3ApiItem\x12(\n\x04\x62ids\x18\x02 \x03(\x0b\x32\x1a.PublicAggreDepthV3ApiItem\x12\x11\n\teventType\x18\x03 \x01(\t\x12\x13\n\x0b\x66romVersion\x18\x04 \x01(\t\x12\x11\n\ttoVersion\x18\x05 \x01(\t\"<\n\x19PublicAggreDepthV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\tB?\n\x1c\x63om.mxc.push.common.protobufB\x1bPublicAggreDepthsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicAggreDepthsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\033PublicAggreDepthsV3ApiProtoH\001P\001'
  _globals['_PUBLICAGGREDEPTHSV3API']._serialized_start=33
  _globals['_PUBLICAGGREDEPTHSV3API']._serialized_end=200
  _globals['_PUBLICAGGREDEPTHV3APIITEM']._serialized_start=202
  _globals['_PUBLICAGGREDEPTHV3APIITEM']._serialized_end=262
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicBookTickerBatchV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicBookTickerBatchV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicBookTickerBatchV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import PublicBookTickerV3Api_pb2 as PublicBookTickerV3Api__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n PublicBookTickerBatchV3Api.proto\x1a\x1bPublicBookTickerV3Api.proto\"C\n\x1aPublicBookTickerBatchV3Api\x12%\n\x05items\x18\x01 \x03(\x0b\x32\x16.PublicBookTickerV3ApiBC\n\x1c\x63om.mxc.push.common.protobufB\x1fPublicBookTickerBatchV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicBookTickerBatchV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\037PublicBookTickerBatchV3ApiProtoH\001P\001'
  _globals['_PUBLICBOOKTICKERBATCHV3API']._serialized_start=65
  _globals['_PUBLICBOOKTICKERBATCHV3API']._serialized_end=132
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicBookTickerV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicBookTickerV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicBookTickerV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1bPublicBookTickerV3Api.proto\"e\n\x15PublicBookTickerV3Api\x12\x10\n\x08\x62idPrice\x18\x01 \x01(\t\x12\x13\n\x0b\x62idQuantity\x18\x02 \x01(\t\x12\x10\n\x08\x61skPrice\x18\x03 \x01(\t\x12\x13\n\x0b\x61skQuantity\x18\x04 \x01(\tB>\n\x1c\x63om.mxc.push.common.protobufB\x1aPublicBookTickerV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicBookTickerV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\032PublicBookTickerV3ApiProtoH\001P\001'
  _globals['_PUBLICBOOKTICKERV3API']._serialized_start=31
  _globals['_PUBLICBOOKTICKERV3API']._serialized_end=132
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicDealsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicDealsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicDealsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x16PublicDealsV3Api.proto\"K\n\x10PublicDealsV3Api\x12$\n\x05\x64\x65\x61ls\x18\x01 \x03(\x0b\x32\x15.PublicDealsV3ApiItem\x12\x11\n\teventType\x18\x02 \x01(\t\"X\n\x14PublicDealsV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\t\x12\x11\n\ttradeType\x18\x03 \x01(\x05\x12\x0c\n\x04time\x18\x04 \x01(\x03\x42\x39\n\x1c\x63om.mxc.push.common.protobufB\x15PublicDealsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicDealsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\025PublicDealsV3ApiProtoH\001P\001'
  _globals['_PUBLICDEALSV3API']._serialized_start=26
  _globals['_PUBLICDEALSV3API']._serialized_end=101
  _globals['_PUBLICDEALSV3APIITEM']._serialized_start=103
  _globals['_PUBLICDEALSV3APIITEM']._serialized_end=191
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicIncreaseDepthsBatchV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicIncreaseDepthsBatchV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicIncreaseDepthsBatchV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import PublicIncreaseDepthsV3Api_pb2 as PublicIncreaseDepthsV3Api__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n$PublicIncreaseDepthsBatchV3Api.proto\x1a\x1fPublicIncreaseDepthsV3Api.proto\"^\n\x1ePublicIncreaseDepthsBatchV3Api\x12)\n\x05items\x18\x01 \x03(\x0b\x32\x1a.PublicIncreaseDepthsV3Api\x12\x11\n\teventType\x18\x02 \x01(\tBG\n\x1c\x63om.mxc.push.common.protobufB#PublicIncreaseDepthsBatchV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicIncreaseDepthsBatchV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB#PublicIncreaseDepthsBatchV3ApiProtoH\001P\001'
  _globals['_PUBLICINCREASEDEPTHSBATCHV3API']._serialized_start=73
  _globals['_PUBLICINCREASEDEPTHSBATCHV3API']._serialized_end=167
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicIncreaseDepthsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicIncreaseDepthsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicIncreaseDepthsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1fPublicIncreaseDepthsV3Api.proto\"\x99\x01\n\x19PublicIncreaseDepthsV3Api\x12+\n\x04\x61sks\x18\x01 \x03(\x0b\x32\x1d.PublicIncreaseDepthV3ApiItem\x12+\n\x04\x62ids\x18\x02 \x03(\x0b\x32\x1d.PublicIncreaseDepthV3ApiItem\x12\x11\n\teventType\x18\x03 \x01(\t\x12\x0f\n\x07version\x18\x04 \x01(\t\"?\n\x1cPublicIncreaseDepthV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\tBB\n\x1c\x63om.mxc.push.common.protobufB\x1ePublicIncreaseDepthsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicIncreaseDepthsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\036PublicIncreaseDepthsV3ApiProtoH\001P\001'
  _globals['_PUBLICINCREASEDEPTHSV3API']._serialized_start=36
  _globals['_PUBLICINCREASEDEPTHSV3API']._serialized_end=189
  _globals['_PUBLICINCREASEDEPTHV3APIITEM']._serialized_start=191
  _globals['_PUBLICINCREASEDEPTHV3APIITEM']._serialized_end=254
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicLimitDepthsV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicLimitDepthsV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicLimitDepthsV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1cPublicLimitDepthsV3Api.proto\"\x90\x01\n\x16PublicLimitDepthsV3Api\x12(\n\x04\x61sks\x18\x01 \x03(\x0b\x32\x1a.PublicLimitDepthV3ApiItem\x12(\n\x04\x62ids\x18\x02 \x03(\x0b\x32\x1a.PublicLimitDepthV3ApiItem\x12\x11\n\teventType\x18\x03 \x01(\t\x12\x0f\n\x07version\x18\x04 \x01(\t\"<\n\x19PublicLimitDepthV3ApiItem\x12\r\n\x05price\x18\x01 \x01(\t\x12\x10\n\x08quantity\x18\x02 \x01(\tB?\n\x1c\x63om.mxc.push.common.protobufB\x1bPublicLimitDepthsV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicLimitDepthsV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\033PublicLimitDepthsV3ApiProtoH\001P\001'
  _globals['_PUBLICLIMITDEPTHSV3API']._serialized_start=33
  _globals['_PUBLICLIMITDEPTHSV3API']._serialized_end=177
  _globals['_PUBLICLIMITDEPTHV3APIITEM']._serialized_start=179
  _globals['_PUBLICLIMITDEPTHV3APIITEM']._serialized_end=239
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicMiniTickersV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicMiniTickersV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicMiniTickersV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import PublicMiniTickerV3Api_pb2 as PublicMiniTickerV3Api__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1cPublicMiniTickersV3Api.proto\x1a\x1bPublicMiniTickerV3Api.proto\"?\n\x16PublicMiniTickersV3Api\x12%\n\x05items\x18\x01 \x03(\x0b\x32\x16.PublicMiniTickerV3ApiB?\n\x1c\x63om.mxc.push.common.protobufB\x1bPublicMiniTickersV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicMiniTickersV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\033PublicMiniTickersV3ApiProtoH\001P\001'
  _globals['_PUBLICMINITICKERSV3API']._serialized_start=61
  _globals['_PUBLICMINITICKERSV3API']._serialized_end=124
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicMiniTickerV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicMiniTickerV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicMiniTickerV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1bPublicMiniTickerV3Api.proto\"\xf4\x01\n\x15PublicMiniTickerV3Api\x12\x0e\n\x06symbol\x18\x01 \x01(\t\x12\r\n\x05price\x18\x02 \x01(\t\x12\x0c\n\x04rate\x18\x03 \x01(\t\x12\x11\n\tzonedRate\x18\x04 \x01(\t\x12\x0c\n\x04high\x18\x05 \x01(\t\x12\x0b\n\x03low\x18\x06 \x01(\t\x12\x0e\n\x06volume\x18\x07 \x01(\t\x12\x10\n\x08quantity\x18\x08 \x01(\t\x12\x15\n\rlastCloseRate\x18\t \x01(\t\x12\x1a\n\x12lastCloseZonedRate\x18\n \x01(\t\x12\x15\n\rlastCloseHigh\x18\x0b \x01(\t\x12\x14\n\x0clastCloseLow\x18\x0c \x01(\tB>\n\x1c\x63om.mxc.push.common.protobufB\x1aPublicMiniTickerV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicMiniTickerV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\032PublicMiniTickerV3ApiProtoH\001P\001'
  _globals['_PUBLICMINITICKERV3API']._serialized_start=32
  _globals['_PUBLICMINITICKERV3API']._serialized_end=276
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PublicSpotKlineV3Api_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PublicSpotKlineV3Api.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PublicSpotKlineV3Api.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1aPublicSpotKlineV3Api.proto\"\xc7\x01\n\x14PublicSpotKlineV3Api\x12\x10\n\x08interval\x18\x01 \x01(\t\x12\x13\n\x0bwindowStart\x18\x02 \x01(\x03\x12\x14\n\x0copeningPrice\x18\x03 \x01(\t\x12\x14\n\x0c\x63losingPrice\x18\x04 \x01(\t\x12\x14\n\x0chighestPrice\x18\x05 \x01(\t\x12\x13\n\x0blowestPrice\x18\x06 \x01(\t\x12\x0e\n\x06volume\x18\x07 \x01(\t\x12\x0e\n\x06\x61mount\x18\x08 \x01(\t\x12\x11\n\twindowEnd\x18\t \x01(\x03\x42=\n\x1c\x63om.mxc.push.common.protobufB\x19PublicSpotKlineV3ApiProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PublicSpotKlineV3Api_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\031PublicSpotKlineV3ApiProtoH\001P\001'
  _globals['_PUBLICSPOTKLINEV3API']._serialized_start=31
  _globals['_PUBLICSPOTKLINEV3API']._serialized_end=230
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/generated/PushDataV3ApiWrapper_pb2.py">
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: PushDataV3ApiWrapper.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'PushDataV3ApiWrapper.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


import PublicDealsV3Api_pb2 as PublicDealsV3Api__pb2
import PublicIncreaseDepthsV3Api_pb2 as PublicIncreaseDepthsV3Api__pb2
import PublicLimitDepthsV3Api_pb2 as PublicLimitDepthsV3Api__pb2
import PrivateOrdersV3Api_pb2 as PrivateOrdersV3Api__pb2
import PublicBookTickerV3Api_pb2 as PublicBookTickerV3Api__pb2
import PrivateDealsV3Api_pb2 as PrivateDealsV3Api__pb2
import PrivateAccountV3Api_pb2 as PrivateAccountV3Api__pb2
import PublicSpotKlineV3Api_pb2 as PublicSpotKlineV3Api__pb2
import PublicMiniTickerV3Api_pb2 as PublicMiniTickerV3Api__pb2
import PublicMiniTickersV3Api_pb2 as PublicMiniTickersV3Api__pb2
import PublicBookTickerBatchV3Api_pb2 as PublicBookTickerBatchV3Api__pb2
import PublicIncreaseDepthsBatchV3Api_pb2 as PublicIncreaseDepthsBatchV3Api__pb2
import PublicAggreDepthsV3Api_pb2 as PublicAggreDepthsV3Api__pb2
import PublicAggreDealsV3Api_pb2 as PublicAggreDealsV3Api__pb2
import PublicAggreBookTickerV3Api_pb2 as PublicAggreBookTickerV3Api__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x1aPushDataV3ApiWrapper.proto\x1a\x16PublicDealsV3Api.proto\x1a\x1fPublicIncreaseDepthsV3Api.proto\x1a\x1cPublicLimitDepthsV3Api.proto\x1a\x18PrivateOrdersV3Api.proto\x1a\x1bPublicBookTickerV3Api.proto\x1a\x17PrivateDealsV3Api.proto\x1a\x19PrivateAccountV3Api.proto\x1a\x1aPublicSpotKlineV3Api.proto\x1a\x1bPublicMiniTickerV3Api.proto\x1a\x1cPublicMiniTickersV3Api.proto\x1a PublicBookTickerBatchV3Api.proto\x1a$PublicIncreaseDepthsBatchV3Api.proto\x1a\x1cPublicAggreDepthsV3Api.proto\x1a\x1bPublicAggreDealsV3Api.proto\x1a PublicAggreBookTickerV3Api.proto\"\xf0\x07\n\x14PushDataV3ApiWrapper\x12\x0f\n\x07\x63hannel\x18\x01 \x01(\t\x12)\n\x0bpublicDeals\x18\xad\x02 \x01(\x0b\x32\x11.PublicDealsV3ApiH\x00\x12;\n\x14publicIncreaseDepths\x18\xae\x02 \x01(\x0b\x32\x1a.PublicIncreaseDepthsV3ApiH\x00\x12\x35\n\x11publicLimitDepths\x18\xaf\x02 \x01(\x0b\x32\x17.PublicLimitDepthsV3ApiH\x00\x12-\n\rprivateOrders\x18\xb0\x02 \x01(\x0b\x32\x13.PrivateOrdersV3ApiH\x00\x12\x33\n\x10publicBookTicker\x18\xb1\x02 \x01(\x0b\x32\x16.PublicBookTickerV3ApiH\x00\x12+\n\x0cprivateDeals\x18\xb2\x02 \x01(\x0b\x32\x12.PrivateDealsV3ApiH\x00\x12/\n\x0eprivateAccount\x18\xb3\x02 \x01(\x0b\x32\x14.PrivateAccountV3ApiH\x00\x12\x31\n\x0fpublicSpotKline\x18\xb4\x02 \x01(\x0b\x32\x15.PublicSpotKlineV3ApiH\x00\x12\x33\n\x10publicMiniTicker\x18\xb5\x02 \x01(\x0b\x32\x16.PublicMiniTickerV3ApiH\x00\x12\x35\n\x11publicMiniTickers\x18\xb6\x02 \x01(\x0b\x32\x17.PublicMiniTickersV3ApiH\x00\x12=\n\x15publicBookTickerBatch\x18\xb7\x02 \x01(\x0b\x32\x1b.PublicBookTickerBatchV3ApiH\x00\x12\x45\n\x19publicIncreaseDepthsBatch\x18\xb8\x02 \x01(\x0b\x32\x1f.PublicIncreaseDepthsBatchV3ApiH\x00\x12\x35\n\x11publicAggreDepths\x18\xb9\x02 \x01(\x0b\x32\x17.PublicAggreDepthsV3ApiH\x00\x12\x33\n\x10publicAggreDeals\x18\xba\x02 \x01(\x0b\x32\x16.PublicAggreDealsV3ApiH\x00\x12=\n\x15publicAggreBookTicker\x18\xbb\x02 \x01(\x0b\x32\x1b.PublicAggreBookTickerV3ApiH\x00\x12\x13\n\x06symbol\x18\x03 \x01(\tH\x01\x88\x01\x01\x12\x15\n\x08symbolId\x18\x04 \x01(\tH\x02\x88\x01\x01\x12\x17\n\ncreateTime\x18\x05 \x01(\x03H\x03\x88\x01\x01\x12\x15\n\x08sendTime\x18\x06 \x01(\x03H\x04\x88\x01\x01\x42\x06\n\x04\x62odyB\t\n\x07_symbolB\x0b\n\t_symbolIdB\r\n\x0b_createTimeB\x0b\n\t_sendTimeB=\n\x1c\x63om.mxc.push.common.protobufB\x19PushDataV3ApiWrapperProtoH\x01P\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'PushDataV3ApiWrapper_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\034com.mxc.push.common.protobufB\031PushDataV3ApiWrapperProtoH\001P\001'
  _globals['_PUSHDATAV3APIWRAPPER']._serialized_start=477
  _globals['_PUSHDATAV3APIWRAPPER']._serialized_end=1485
# @@protoc_insertion_point(module_scope)
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/__init__.py">
"""Protocol buffer definitions for MEXC WebSocket APIs."""
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PrivateAccountV3Api.proto">
// spot@public.cny.v2.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PrivateAccountV3ApiProto";

message PrivateAccountV3Api {

  string vcoinName = 1;
  string coinId = 2;

  string balanceAmount = 3;
  string balanceAmountChange = 4;
  string frozenAmount = 5;
  string frozenAmountChange = 6;

  string type = 7;

  int64 time = 8;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PrivateDealsV3Api.proto">
// spot@private.deals.v3.api.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PrivateDealsV3ApiProto";

message PrivateDealsV3Api {

  string price = 1;
  string quantity = 2;
  string amount = 3;

  int32 tradeType = 4;
  bool isMaker = 5;
  bool isSelfTrade = 6;

  string tradeId = 7;
  string clientOrderId = 8;
  string orderId = 9;

  string feeAmount = 10;
  string feeCurrency = 11;

  int64 time = 12;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PrivateOrdersV3Api.proto">
// spot@private.orders.v3.api.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PrivateOrdersV3ApiProto";

message PrivateOrdersV3Api {

  string id = 1;
  string clientId = 2;

  string price = 3;
  string quantity = 4;
  string amount = 5;
  string avgPrice = 6;

  int32 orderType = 7;
  int32 tradeType = 8;
  bool isMaker = 9;

  string remainAmount = 10;
  string remainQuantity= 11;
  optional string lastDealQuantity = 12;
  string cumulativeQuantity = 13;
  string cumulativeAmount = 14;

  int32 status = 15;
  int64 createTime = 16;

  optional string market = 17;
  optional int32 triggerType = 18;
  optional string triggerPrice= 19;
  optional int32 state = 20;

  optional string ocoId = 21;
  optional string routeFactor = 22;

  optional string symbolId = 23;
  optional string marketId = 24;

  optional string marketCurrencyId = 25;
  optional string currencyId = 26;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicAggreBookTickerV3Api.proto">
// spot@public.aggre.bookTicker.v3.api.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicAggreBookTickerV3ApiProto";

message PublicAggreBookTickerV3Api {

  string bidPrice = 1;
  string bidQuantity = 2;
  string askPrice = 3;
  string askQuantity = 4;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicAggreDealsV3Api.proto">
// spot@public.aggre.deals.v3.api.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicAggreDealsV3ApiProto";

message PublicAggreDealsV3Api {

  repeated PublicAggreDealsV3ApiItem deals  = 1;
  string eventType = 2;
}

message PublicAggreDealsV3ApiItem {
  string price = 1;
  string quantity = 2;
  int32 tradeType = 3;
  int64 time = 4;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicAggreDepthsV3Api.proto">
// spot@public.aggre.depth.v3.api.pb@aggreType

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicAggreDepthsV3ApiProto";

message PublicAggreDepthsV3Api {

  repeated PublicAggreDepthV3ApiItem asks  = 1;
  repeated PublicAggreDepthV3ApiItem bids  = 2;
  string eventType = 3;
  string fromVersion = 4;
  string toVersion = 5;
}

message PublicAggreDepthV3ApiItem {
  string price = 1;
  string quantity = 2;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicBookTickerBatchV3Api.proto">
// spot@public.bookTicker.v3.api.pb

syntax = "proto3";
import "PublicBookTickerV3Api.proto";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicBookTickerBatchV3ApiProto";

message PublicBookTickerBatchV3Api {
  repeated PublicBookTickerV3Api items  = 1;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicBookTickerV3Api.proto">
// spot@public.bookTicker.v3.api.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicBookTickerV3ApiProto";

message PublicBookTickerV3Api {

  string bidPrice = 1;
  string bidQuantity = 2;
  string askPrice = 3;
  string askQuantity = 4;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicDealsV3Api.proto">
// spot@public.deals.v3.api.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicDealsV3ApiProto";

message PublicDealsV3Api {

  repeated PublicDealsV3ApiItem deals  = 1;
  string eventType = 2;
}

message PublicDealsV3ApiItem {
  string price = 1;
  string quantity = 2;
  int32 tradeType = 3;
  int64 time = 4;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicIncreaseDepthsBatchV3Api.proto">
// spot@public.increase.depth.v3.api.pb

syntax = "proto3";
import "PublicIncreaseDepthsV3Api.proto";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicIncreaseDepthsBatchV3ApiProto";

message PublicIncreaseDepthsBatchV3Api{

  repeated PublicIncreaseDepthsV3Api items  = 1;
  string eventType = 2;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicIncreaseDepthsV3Api.proto">
// spot@public.increase.depth.v3.api.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicIncreaseDepthsV3ApiProto";

message PublicIncreaseDepthsV3Api {

  repeated PublicIncreaseDepthV3ApiItem asks  = 1;
  repeated PublicIncreaseDepthV3ApiItem bids  = 2;
  string eventType = 3;
  string version = 4;
}

message PublicIncreaseDepthV3ApiItem {
  string price = 1;
  string quantity = 2;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicLimitDepthsV3Api.proto">
// spot@public.limit.depth.v3.api.pb

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicLimitDepthsV3ApiProto";

message PublicLimitDepthsV3Api {

  repeated PublicLimitDepthV3ApiItem asks  = 1;
  repeated PublicLimitDepthV3ApiItem bids  = 2;
  string eventType = 3;
  string version = 4;
}

message PublicLimitDepthV3ApiItem {
  string price = 1;
  string quantity = 2;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicMiniTickersV3Api.proto">
// spot@public.miniTickers.v3.api

syntax = "proto3";

import "PublicMiniTickerV3Api.proto";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicMiniTickersV3ApiProto";

message PublicMiniTickersV3Api {

  repeated PublicMiniTickerV3Api items  = 1;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicMiniTickerV3Api.proto">
// spot@public.miniTicker.v3.api

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicMiniTickerV3ApiProto";

message PublicMiniTickerV3Api {

  // 交易对名
  string symbol = 1;
  // 最新价格
  string price = 2;
  // utc+8时区涨跌幅
  string rate = 3;
  // 时区涨跌幅
  string zonedRate = 4;
  // 滚动最高价
  string high = 5;
  // 滚动最低价
  string low = 6;
  // 滚动成交额
  string volume = 7;
  // 滚动成交量
  string quantity = 8;
  // utc+8时区上期收盘价模式涨跌幅
  string lastCloseRate = 9;
  // 上期收盘价模式时区涨跌幅
  string lastCloseZonedRate = 10;
  // 上期收盘价模式滚动最高价
  string lastCloseHigh = 11;
  // 上期收盘价模式滚动最低价
  string lastCloseLow = 12;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PublicSpotKlineV3Api.proto">
// spot@public.kline.v3.api.pb@<symbol>@<interval>

syntax = "proto3";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PublicSpotKlineV3ApiProto";

message PublicSpotKlineV3Api {
  //K线周期(Min1,Min5,Min15,Min30,Min60,Hour4,Hour8,Day1,Week1,Month1)
  string interval = 1;
  // 窗口开始时间戳(秒时间戳)
  int64 windowStart = 2;
  // 开盘价
  string openingPrice = 3;
  // 收盘价
  string closingPrice = 4;
  // 最高价
  string highestPrice = 5;
  // 最低价
  string lowestPrice = 6;
  // 成交量
  string volume = 7;
  // 成交额
  string amount = 8;
  // 窗口结束时间戳(秒时间戳)
  int64 windowEnd = 9;
}
</file>

<file path="src/app/infrastructure/exchange/mexc/proto/PushDataV3ApiWrapper.proto">
syntax = "proto3";

import "PublicDealsV3Api.proto";
import "PublicIncreaseDepthsV3Api.proto";
import "PublicLimitDepthsV3Api.proto";
import "PrivateOrdersV3Api.proto";
import "PublicBookTickerV3Api.proto";
import "PrivateDealsV3Api.proto";
import "PrivateAccountV3Api.proto";
import "PublicSpotKlineV3Api.proto";
import "PublicMiniTickerV3Api.proto";
import "PublicMiniTickersV3Api.proto";
import "PublicBookTickerBatchV3Api.proto";
import "PublicIncreaseDepthsBatchV3Api.proto";
import "PublicAggreDepthsV3Api.proto";
import "PublicAggreDealsV3Api.proto";
import "PublicAggreBookTickerV3Api.proto";

option java_package = "com.mxc.push.common.protobuf";
option optimize_for = SPEED;
option java_multiple_files = true;
option java_outer_classname = "PushDataV3ApiWrapperProto";

message PushDataV3ApiWrapper {


  /**
   * 频道
   */
  string channel = 1;

  /**
   * 数据，NOTE：因为不能重复，所以类型和变量名尽量使用全名
   */
  oneof body {
    PublicDealsV3Api publicDeals = 301;
    PublicIncreaseDepthsV3Api publicIncreaseDepths = 302;
    PublicLimitDepthsV3Api publicLimitDepths = 303;
    PrivateOrdersV3Api privateOrders = 304;
    PublicBookTickerV3Api publicBookTicker = 305;
    PrivateDealsV3Api privateDeals = 306;
    PrivateAccountV3Api privateAccount = 307;
    PublicSpotKlineV3Api publicSpotKline = 308;
    PublicMiniTickerV3Api publicMiniTicker = 309;
    PublicMiniTickersV3Api publicMiniTickers = 310;
    PublicBookTickerBatchV3Api publicBookTickerBatch = 311;
    PublicIncreaseDepthsBatchV3Api publicIncreaseDepthsBatch = 312;
    PublicAggreDepthsV3Api publicAggreDepths = 313;
    PublicAggreDealsV3Api publicAggreDeals = 314;
    PublicAggreBookTickerV3Api publicAggreBookTicker = 315;
  }

  /**
   * 交易对
   */
  optional string symbol = 3;

  /**
   * 交易对ID
   */
  optional string symbolId = 4;

  /**
   * 消息生成时间
   */
  optional int64 createTime = 5;

  /**
   * 消息推送时间
   */
  optional int64 sendTime = 6;

}
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/__init__.py">
# QRL/USDT dedicated infrastructure components
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/qrl_order_mapper.py">
from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.qrl_quantity import QrlQuantity


def map_rest_order(payload: dict) -> dict:
    """Return normalized order fields; caller can wrap to domain entity later."""
    return {
        "id": payload.get("orderId"),
        "client_order_id": payload.get("clientOrderId") or payload.get("origClientOrderId"),
        "price": QrlPrice(payload["price"]) if payload.get("price") else None,
        "quantity": QrlQuantity(payload["origQty"]) if payload.get("origQty") else None,
        "executed_quantity": QrlQuantity(payload["executedQty"]) if payload.get("executedQty") else None,
        "status": payload.get("status"),
        "side": payload.get("side"),
        "type": payload.get("type"),
    }
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/qrl_price_mapper.py">
from decimal import Decimal

from src.app.domain.value_objects.qrl_price import QrlPrice


def map_ticker_to_price(payload: dict) -> QrlPrice:
    price = payload.get("lastPrice") or payload.get("last")
    if price is None:
        raise ValueError("Missing QRL price in payload")
    return QrlPrice(Decimal(str(price)))
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/qrl_settings.py">
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class QrlSettings(MexcSettings):
    """Alias for QRL-only flows; reuses general MEXC credentials."""

    @property
    def symbol(self) -> str:
        return "QRLUSDT"
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/qrl_trade_mapper.py">
from decimal import Decimal

from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.qrl_quantity import QrlQuantity


def map_trade(payload: dict) -> dict:
    return {
        "id": payload.get("id"),
        "price": QrlPrice(payload["price"]) if payload.get("price") else None,
        "quantity": QrlQuantity(payload["qty"]) if payload.get("qty") else None,
        "quote_qty": Decimal(str(payload["quoteQty"])) if payload.get("quoteQty") else None,
        "side": payload.get("isBuyer") and "BUY" or "SELL",
        "time": payload.get("time"),
    }
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/qrl_ws_client.py">
from src.app.infrastructure.exchange.mexc.ws.mexc_ws_client import MexcWsClient
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair


class QrlWsClient(MexcWsClient):
    """QRL/USDT專用 WS client，封裝訂閱 symbol。"""

    def __init__(self, base_ws_url: str):
        super().__init__(base_ws_url)

    async def subscribe_depth(self) -> None:
        await self.subscribe({"op": "sub.limit.depth", "symbol": QrlUsdtPair.symbol()})

    async def subscribe_trades(self) -> None:
        await self.subscribe({"op": "sub.personal.deals.v3", "symbol": QrlUsdtPair.symbol()})

    async def subscribe_orders(self) -> None:
        await self.subscribe({"op": "sub.personal.order.v3", "symbol": QrlUsdtPair.symbol()})
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/ws/__init__.py">
# QRL/USDT WebSocket state helpers
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/ws/qrl_reconnect_policy.py">
class QrlReconnectPolicy:
    """Simple reconnect/backoff helper for QRL WS."""

    def __init__(self, max_retries: int = 5, base_delay: float = 1.0):
        self._max_retries = max_retries
        self._base_delay = base_delay

    def should_retry(self, attempt: int) -> bool:
        return attempt < self._max_retries

    def delay_seconds(self, attempt: int) -> float:
        return self._base_delay * max(1, attempt)
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/ws/qrl_snapshot_loader.py">
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.ws.qrl_stream_state import QrlStreamState


class QrlSnapshotLoader:
    def __init__(self, rest_client: QrlRestClient):
        self._rest_client = rest_client

    async def load(self, state: QrlStreamState, limit: int = 50) -> dict:
        async with self._rest_client as client:
            snapshot = await client.depth(limit=limit)
        state.last_update_id = snapshot.get("lastUpdateId")
        return snapshot
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/ws/qrl_stream_state.py">
from dataclasses import dataclass, field
from typing import Any


@dataclass(slots=True)
class QrlStreamState:
    last_update_id: int | None = None
    backlog: list[dict[str, Any]] = field(default_factory=list)

    def apply_update(self, update_id: int) -> None:
        if self.last_update_id is None or update_id > self.last_update_id:
            self.last_update_id = update_id
</file>

<file path="src/app/infrastructure/exchange/mexc/ws_client.py">
"""
MEXC WebSocket client placeholder.
"""


class MexcWebSocketClient:
    def __init__(self):
        # TODO: inject ws transport and serializer
        pass

    # TODO: methods to subscribe to ticker, depth, trades channels
</file>

<file path="src/app/infrastructure/exchange/mexc/ws/__init__.py">
from .mexc_ws_client import MexcWebSocketClient

__all__ = ["MexcWebSocketClient"]
</file>

<file path="src/app/infrastructure/exchange/mexc/ws/mexc_ws_client.py">
from typing import AsyncIterator, Optional


class MexcWebSocketClient:
    """
    Thin wrapper over MEXC V3 WebSocket transport.

    This class is intentionally minimal; transport details (auth, ping/pong,
    reconnect) can be layered later without leaking into Domain/Application.
    """

    async def subscribe(
        self, channel: str, symbol: Optional[str] = None
    ) -> AsyncIterator[object]:
        """
        Yield raw protobuf messages for the given channel.

        Args:
            channel: MEXC stream channel (e.g., depth, deals, orders).
            symbol: Optional trading pair symbol when required by the stream.
        """
        raise NotImplementedError("WebSocket transport not wired yet.")
</file>

<file path="src/app/infrastructure/external/mexc/__init__.py">
"""MEXC external client placeholders."""
</file>

<file path="src/app/infrastructure/streaming/__init__.py">
from .bounded_queue import BoundedAsyncQueue
from .ring_buffer import RingBuffer

__all__ = ["BoundedAsyncQueue", "RingBuffer"]
</file>

<file path="src/app/infrastructure/streaming/bounded_queue.py">
import asyncio
from typing import Generic, TypeVar

T = TypeVar("T")


class BoundedAsyncQueue(Generic[T]):
    """Async queue with backpressure for WS message ingestion."""

    def __init__(self, max_size: int = 1000):
        self._queue: asyncio.Queue[T] = asyncio.Queue(maxsize=max_size)

    async def push(self, item: T) -> None:
        await self._queue.put(item)

    async def pull(self) -> T:
        return await self._queue.get()
</file>

<file path="src/app/infrastructure/streaming/ring_buffer.py">
from collections import deque
from typing import Deque, Generic, Iterable, TypeVar

T = TypeVar("T")


class RingBuffer(Generic[T]):
    """Fixed-size buffer for lightweight replay/debug."""

    def __init__(self, size: int = 1000):
        self._buffer: Deque[T] = deque(maxlen=size)

    def append(self, item: T) -> None:
        self._buffer.append(item)

    def replay(self) -> Iterable[T]:
        return list(self._buffer)
</file>

<file path="src/app/interfaces/__init__.py">
from fastapi import FastAPI

from src.app.interfaces.http.api import (
    account_routes,
    market_routes,
    system_routes,
    trading_routes,
    ws_routes,
)


def register_all_routers(app: FastAPI) -> None:
    """Register all interface routers. Routes contain no business logic."""
    app.include_router(account_routes.router, prefix="/api/account", tags=["account"])
    app.include_router(trading_routes.router, prefix="/api/trading", tags=["trading"])
    app.include_router(market_routes.router, prefix="/api/market", tags=["market"])
    app.include_router(system_routes.router, prefix="/api/system", tags=["system"])
    app.include_router(ws_routes.router, prefix="/ws", tags=["websocket"])
</file>

<file path="src/app/interfaces/http/__init__.py">
"""HTTP interfaces (controllers only)."""
</file>

<file path="src/app/interfaces/http/api/__init__.py">
"""API routers for JSON endpoints."""
</file>

<file path="src/app/interfaces/http/api/system_routes.py">
from fastapi import APIRouter

from src.app.application.system.use_cases.get_server_time import GetServerTimeUseCase
from src.app.application.system.use_cases.ping import PingUseCase

router = APIRouter()


@router.get("/ping")
async def ping():
    """Ping endpoint."""
    usecase = PingUseCase()
    return await usecase.execute()


@router.get("/time")
async def get_server_time():
    """Get server time."""
    usecase = GetServerTimeUseCase()
    return await usecase.execute()
</file>

<file path="src/app/interfaces/http/api/trading_api.py">
from fastapi import APIRouter, Query

from src.app.application.trading.use_cases.get_kline import GetKlineUseCase
from src.app.application.trading.use_cases.get_price import GetPriceUseCase


router = APIRouter()


@router.get("/api/price/{symbol}")
async def get_price(symbol: str):
    usecase = GetPriceUseCase()
    return await usecase.execute(symbol)


@router.get("/api/kline/{symbol}/{interval}")
async def get_kline(symbol: str, interval: str, limit: int = Query(default=60, ge=1, le=500)):
    usecase = GetKlineUseCase()
    return await usecase.execute(symbol, interval, limit)
</file>

<file path="src/app/interfaces/http/api/trading_routes.py">
from decimal import Decimal

from fastapi import APIRouter, Query
from src.app.application.trading.use_cases.cancel_order import CancelOrderInput, CancelOrderUseCase
from src.app.application.trading.use_cases.get_order import GetOrderInput, GetOrderUseCase
from src.app.application.trading.use_cases.list_orders import ListOrdersUseCase
from src.app.application.trading.use_cases.list_trades import ListTradesUseCase
from src.app.application.trading.use_cases.place_order import PlaceOrderInput, PlaceOrderUseCase
from src.app.interfaces.http.schemas import (
    PlaceOrderRequest,
)


router = APIRouter()


@router.post("/orders")
async def place_order(request: PlaceOrderRequest):
    """Place spot order for QRL/USDT (subaccount)."""
    usecase = PlaceOrderUseCase()
    data = PlaceOrderInput(
        symbol=request.symbol,
        side=request.side,
        quantity=Decimal(request.quantity),
        price=Decimal(request.price) if request.price is not None else None,
        order_type=request.order_type,
        time_in_force=request.time_in_force if request.time_in_force else "GTC",
        client_order_id=request.client_order_id,
    )
    return await usecase.execute(data)


@router.post("/orders/{order_id}/cancel")
async def cancel_order(order_id: str, symbol: str = Query(default="QRLUSDT")):
    """Cancel an existing order."""
    usecase = CancelOrderUseCase()
    data = CancelOrderInput(symbol=symbol, order_id=order_id, client_order_id=None)
    return await usecase.execute(data)


@router.get("/orders/{order_id}")
async def get_order(order_id: str, symbol: str = Query(default="QRLUSDT")):
    """Get order status."""
    usecase = GetOrderUseCase()
    data = GetOrderInput(symbol=symbol, order_id=order_id, client_order_id=None)
    return await usecase.execute(data)


@router.get("/orders")
async def list_orders(symbol: str = Query(default="QRLUSDT")):
    """List recent orders."""
    usecase = ListOrdersUseCase()
    return await usecase.execute(symbol=symbol)


@router.get("/trades")
async def list_trades(symbol: str = Query(default="QRLUSDT")):
    """List recent trades."""
    usecase = ListTradesUseCase()
    return await usecase.execute(symbol)
</file>

<file path="src/app/interfaces/http/api/ws_routes.py">
from fastapi import APIRouter, WebSocket

from src.app.application.market.use_cases.get_ticker import GetTickerUseCase
from src.app.application.trading.use_cases.list_orders import ListOrdersUseCase

router = APIRouter()


@router.websocket("/market/ticker")
async def ticker_stream(websocket: WebSocket):
    """WebSocket ticker stream placeholder."""
    await websocket.accept()
    usecase = GetTickerUseCase()
    await usecase.execute()  # TODO: stream data
    await websocket.close()


@router.websocket("/trading/orders")
async def order_stream(websocket: WebSocket):
    """WebSocket order stream placeholder."""
    await websocket.accept()
    usecase = ListOrdersUseCase()
    await usecase.execute()  # TODO: stream data
    await websocket.close()
</file>

<file path="src/app/interfaces/http/dependencies.py">
"""FastAPI dependencies for interface layer."""

# TODO: add shared dependencies (auth, DB session, exchange client providers)
</file>

<file path="src/app/interfaces/http/pages/__init__.py">
"""HTML page controllers."""
</file>

<file path="src/app/interfaces/http/pages/static/css/.gitkeep">

</file>

<file path="src/app/interfaces/http/pages/static/js/.gitkeep">

</file>

<file path="src/app/interfaces/tasks/__init__.py">
"""Task interfaces placeholder."""
</file>

<file path="src/app/interfaces/tasks/market_tasks.py">
"""Market-related scheduled tasks placeholder."""


async def refresh_ticker():
    """Placeholder for refreshing ticker cache."""
    return None
</file>

<file path="src/app/interfaces/tasks/system_tasks.py">
"""System-related scheduled tasks placeholder."""


async def health_check():
    """Placeholder for system health checks."""
    return None
</file>

<file path="src/app/interfaces/tasks/trading_tasks.py">
"""Trading-related scheduled tasks placeholder."""


async def sync_orders():
    """Placeholder for syncing orders."""
    return None


async def sync_trades():
    """Placeholder for syncing trades."""
    return None
</file>

<file path="src/app/application/account/use_cases/get_balance.py">
"""Account use case: get subaccount balance with valuation."""

from dataclasses import dataclass
from decimal import Decimal

from src.app.application.exchange.mexc_service import MexcService, build_mexc_service
from src.app.domain.entities.account import Account
from src.app.domain.services.valuation_service import ValuationService
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.symbol import Symbol
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _mid(price: Price) -> Decimal:
    return (price.bid + price.ask) / Decimal("2")


def _aggregate_balances(account: Account) -> dict:
    usdt_free = usdt_locked = Decimal("0")
    qrl_free = qrl_locked = Decimal("0")
    for balance in account.balances:
        asset = balance.asset.upper()
        if asset == "USDT":
            usdt_free += balance.free
            usdt_locked += balance.locked
        elif asset == "QRL":
            qrl_free += balance.free
            qrl_locked += balance.locked
    return {
        "usdt_free": usdt_free,
        "usdt_locked": usdt_locked,
        "qrl_free": qrl_free,
        "qrl_locked": qrl_locked,
    }


def _valuation(agg: dict, mid_price: Decimal | None) -> dict:
    usdt_total = agg["usdt_free"] + agg["usdt_locked"]
    if mid_price is None:
        return {
            "price_available": False,
            "price_mid": None,
            "qrl_available_value": None,
            "qrl_locked_value": None,
            "qrl_value_usdt": None,
            "total_value_usdt": None,
            "qrl_pct": None,
            "usdt_pct": None,
        }

    qrl_available_value = ValuationService.value(agg["qrl_free"], mid_price)
    qrl_locked_value = ValuationService.value(agg["qrl_locked"], mid_price)
    qrl_value = qrl_available_value + qrl_locked_value
    total_value = qrl_value + usdt_total

    if total_value > 0:
        qrl_pct = (qrl_value / total_value) * Decimal("100")
        usdt_pct = (usdt_total / total_value) * Decimal("100")
    else:
        qrl_pct = None
        usdt_pct = None

    return {
        "price_available": True,
        "price_mid": str(mid_price),
        "qrl_available_value": str(qrl_available_value),
        "qrl_locked_value": str(qrl_locked_value),
        "qrl_value_usdt": str(qrl_value),
        "total_value_usdt": str(total_value),
        "qrl_pct": str(qrl_pct) if qrl_pct is not None else None,
        "usdt_pct": str(usdt_pct) if usdt_pct is not None else None,
    }


def _serialize_account(account: Account, valuation: dict) -> dict:
    return {
        "can_trade": account.can_trade,
        "update_time": account.update_time.value.isoformat(),
        "balances": [
            {
                "asset": balance.asset,
                "free": str(balance.free),
                "locked": str(balance.locked),
                "free_value_usdt": (
                    valuation["qrl_available_value"] if balance.asset.upper() == "QRL" else None
                ),
                "locked_value_usdt": (
                    valuation["qrl_locked_value"] if balance.asset.upper() == "QRL" else None
                ),
            }
            for balance in account.balances
        ],
        "valuation": valuation,
    }


@dataclass
class GetBalanceUseCase:
    settings: MexcSettings | None = None

    async def execute(self) -> dict:
        service = build_mexc_service(self.settings or MexcSettings())
        async with service as svc:
            account = await svc.get_account()
            try:
                price = await svc.get_price(Symbol("QRLUSDT"))
                mid = _mid(price)
            except Exception:
                price = None
                mid = None

        agg = _aggregate_balances(account)
        valuation = _valuation(agg, mid)
        return _serialize_account(account, valuation)
</file>

<file path="src/app/application/exchange/mexc_service.py">
from dataclasses import dataclass
from decimal import Decimal
from typing import Iterable

from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.order_book import OrderBook
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.infrastructure.exchange.mexc.mappers import (
    account_from_api,
    order_book_from_api,
    order_from_api,
    server_time_to_timestamp,
    trade_from_api,
)
from src.app.infrastructure.exchange.mexc.rest_client import MexcRestClient
from src.app.infrastructure.exchange.mexc_api_client import MexcApiClient
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def _to_str(value: Decimal | None) -> str | None:
    return str(value) if value is not None else None


def _symbol_value(symbol: Symbol) -> str:
    return symbol.value.replace("/", "").upper()


@dataclass
class PlaceOrderRequest:
    symbol: Symbol
    side: Side
    order_type: OrderType
    quantity: Quantity
    price: Price | None = None
    time_in_force: TimeInForce | None = None
    client_order_id: str | None = None


@dataclass
class CancelOrderRequest:
    symbol: Symbol
    order_id: str | None = None
    client_order_id: str | None = None


@dataclass
class GetOrderRequest:
    symbol: Symbol
    order_id: str | None = None
    client_order_id: str | None = None


class MexcService:
    """Application-level service that wraps the MEXC REST client."""

    def __init__(self, rest_client: MexcRestClient):
        self._rest_client = rest_client
        self._api_client = MexcApiClient(rest_client)

    async def __aenter__(self) -> "MexcService":
        await self._api_client.__aenter__()
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self._api_client.__aexit__(exc_type, exc, tb)

    async def get_server_time(self) -> Timestamp:
        payload = await self._rest_client.get_server_time()
        return server_time_to_timestamp(payload)

    async def get_account(self) -> Account:
        payload = await self._rest_client.get_account()
        return account_from_api(payload)

    async def place_order(self, request: PlaceOrderRequest) -> Order:
        if request.order_type.value == "LIMIT" and request.price is None:
            raise ValueError("Limit orders require price")
        payload = {
            "symbol": _symbol_value(request.symbol),
            "side": request.side.value,
            "order_type": request.order_type.value,
            "quantity": _to_str(request.quantity.value),
            "price": _to_str(request.price.last) if request.price else None,
            "time_in_force": request.time_in_force.value if request.time_in_force else None,
            "client_order_id": request.client_order_id,
        }
        response = await self._rest_client.create_order(**payload)
        return order_from_api(response)

    async def cancel_order(self, request: CancelOrderRequest) -> Order:
        response = await self._rest_client.cancel_order(
            symbol=_symbol_value(request.symbol),
            order_id=request.order_id,
            client_order_id=request.client_order_id,
        )
        return order_from_api(response)

    async def get_order(self, request: GetOrderRequest) -> Order:
        response = await self._rest_client.get_order(
            symbol=_symbol_value(request.symbol),
            order_id=request.order_id,
            client_order_id=request.client_order_id,
        )
        return order_from_api(response)

    async def list_open_orders(self, symbol: Symbol | None = None) -> list[Order]:
        response = await self._rest_client.list_open_orders(
            symbol=_symbol_value(symbol) if symbol else None
        )
        return [order_from_api(item) for item in response]

    async def list_trades(self, symbol: Symbol) -> list[Trade]:
        response = await self._rest_client.list_trades(symbol=_symbol_value(symbol))
        return [trade_from_api(item) for item in response]

    async def get_price(self, symbol: Symbol) -> Price:
        from src.app.domain.entities.trading_pair import TradingPair

        base = symbol.value.replace("/", "").upper().removesuffix("USDT")
        tp = TradingPair(base_currency=base, quote_currency="USDT")
        return await self._api_client.get_price(tp)

    async def get_kline(self, symbol: Symbol, interval: str, limit: int = 100) -> list["KLine"]:
        from src.app.domain.entities.trading_pair import TradingPair
        from src.app.domain.value_objects.kline import KLine

        base = symbol.value.replace("/", "").upper().removesuffix("USDT")
        tp = TradingPair(base_currency=base, quote_currency="USDT")
        return await self._api_client.get_klines(tp, interval=interval, limit=limit)

    async def get_depth(self, symbol: Symbol, limit: int = 50) -> OrderBook:
        response = await self._rest_client.depth(symbol=_symbol_value(symbol), limit=limit)
        return order_book_from_api(response)


def build_mexc_service(settings: MexcSettings) -> MexcService:
    """Factory to build a service with shared settings."""
    return MexcService(MexcRestClient(settings))
</file>

<file path="src/app/application/market/qrl/get_qrl_price.py">
from dataclasses import asdict, dataclass
from typing import Any

from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient


@dataclass(frozen=True)
class QrlPriceSnapshot:
    bid: str | None
    ask: str | None
    last: str
    timestamp: int | None

    def to_dict(self) -> dict[str, Any]:
        return asdict(self)


class GetQrlPrice:
    """Fetch QRL/USDT price using the dedicated REST client."""

    def __init__(self, rest_client: QrlRestClient):
        self._client = rest_client

    async def execute(self) -> QrlPriceSnapshot:
        async with self._client as client:
            ticker = await client.ticker_24h()
        bid = ticker.get("bidPrice") or ticker.get("bid")
        ask = ticker.get("askPrice") or ticker.get("ask")
        last = ticker.get("lastPrice") or ticker.get("last")
        if last is None:
            raise ValueError("QRL price unavailable")
        price_vo = QrlPrice(last)
        timestamp = (
            ticker.get("time")
            or ticker.get("timestamp")
            or ticker.get("closeTime")
            or ticker.get("t")  # some SDKs return shorthand
        )
        return QrlPriceSnapshot(
            bid=str(bid) if bid is not None else None,
            ask=str(ask) if ask is not None else None,
            last=str(price_vo.value),
            timestamp=timestamp,
        )
</file>

<file path="src/app/application/market/use_cases/get_depth.py">
"""
Market use case: get order book depth for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetDepthInput:
    limit: int = 50


class GetDepthUseCase:
    """Fetch aggregated depth for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetDepthInput | None = None) -> dict:
        payload = data or GetDepthInput()
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.depth(limit=payload.limit)
</file>

<file path="src/app/application/market/use_cases/get_kline.py">
"""
Market use case: get kline data for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetKlineInput:
    interval: str = "1m"
    limit: int = 50


class GetKlineUseCase:
    """Fetch klines for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetKlineInput | None = None) -> list:
        payload = data or GetKlineInput()
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.klines(interval=payload.interval, limit=payload.limit)
</file>

<file path="src/app/application/market/use_cases/get_market_trades.py">
"""
Market use case: recent public trades for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetMarketTradesInput:
    limit: int = 50


class GetMarketTradesUseCase:
    """Fetch recent public trades for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetMarketTradesInput | None = None) -> list:
        payload = data or GetMarketTradesInput()
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.market_trades(limit=payload.limit)
</file>

<file path="src/app/application/market/use_cases/get_stats24h.py">
"""
Market use case: 24h stats for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetStats24hInput:
    include_timestamp: bool = True


class GetStats24hUseCase:
    """Fetch 24h statistics for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetStats24hInput | None = None) -> dict:
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.ticker_24h()
</file>

<file path="src/app/application/market/use_cases/get_ticker.py">
"""
Market use case: get ticker for QRL/USDT.
"""

from dataclasses import dataclass

from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings


@dataclass
class GetTickerInput:
    include_timestamp: bool = True


class GetTickerUseCase:
    """Fetch 24h ticker for the fixed QRL/USDT symbol."""

    def __init__(self, settings: QrlSettings | None = None):
        self._settings = settings or QrlSettings()

    async def execute(self, data: GetTickerInput | None = None) -> dict:
        client = QrlRestClient(self._settings)
        async with client as cli:
            return await cli.ticker_24h()
</file>

<file path="src/app/domain/aggregates/__init__.py">
"""Domain aggregates for the QRL/USDT trading context."""

from src.app.domain.aggregates.account_state import AccountState
from src.app.domain.aggregates.market_snapshot import MarketSnapshot
from src.app.domain.aggregates.trading_session import TradingSession

__all__ = ["AccountState", "MarketSnapshot", "TradingSession"]
</file>

<file path="src/app/domain/aggregates/account_state.py">
from dataclasses import dataclass, field

from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class AccountState:
    """Aggregate for account balances and outstanding orders."""

    symbol: Symbol
    account: Account
    open_orders: list[Order] = field(default_factory=list)
    updated_at: Timestamp | None = None
</file>

<file path="src/app/domain/aggregates/market_snapshot.py">
from dataclasses import dataclass, field

from src.app.domain.entities.order_book_level import OrderBookLevel
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class MarketSnapshot:
    """Combined market view for depth, trades, and ticker."""

    symbol: Symbol
    bids: list[OrderBookLevel] = field(default_factory=list)
    asks: list[OrderBookLevel] = field(default_factory=list)
    trades: list[Trade] = field(default_factory=list)
    ticker: Ticker | None = None
    updated_at: Timestamp | None = None
</file>

<file path="src/app/domain/aggregates/trading_session.py">
from dataclasses import dataclass, field

from src.app.domain.entities.order import Order
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class TradingSession:
    """Session-level aggregate for managing open and historical activity."""

    symbol: Symbol
    open_orders: list[Order] = field(default_factory=list)
    trades: list[Trade] = field(default_factory=list)
    started_at: Timestamp | None = None
    last_activity_at: Timestamp | None = None
</file>

<file path="src/app/domain/entities/__init__.py">
"""Domain entities for QRL/USDT spot trading."""

from src.app.domain.entities.account import Account
from src.app.domain.entities.kline import Kline
from src.app.domain.entities.order import Order
from src.app.domain.entities.order_book_level import OrderBookLevel
from src.app.domain.entities.trade import Trade

__all__ = ["Account", "Kline", "Order", "OrderBookLevel", "Trade"]
</file>

<file path="src/app/domain/entities/kline.py">
from dataclasses import dataclass
from decimal import Decimal

from src.app.domain.value_objects.kline_interval import KlineInterval
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.timestamp import Timestamp


@dataclass
class Kline:
    """Kline entity for QRL/USDT spot."""

    symbol: Symbol
    interval: KlineInterval
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: Decimal
    open_time: Timestamp
    close_time: Timestamp | None = None
</file>

<file path="src/app/domain/entities/order_book_level.py">
from dataclasses import dataclass
from decimal import Decimal

from src.app.domain.value_objects.order_side import OrderSide


@dataclass
class OrderBookLevel:
    """Single depth level for the QRL/USDT order book."""

    price: Decimal
    quantity: Decimal
    side: OrderSide
</file>

<file path="src/app/domain/services/__init__.py">
"""Domain services for allocation and depth analysis."""
</file>

<file path="src/app/domain/services/valuation_service.py">
from decimal import Decimal


class ValuationService:
    """Compute position values given a quantity and a unit price."""

    @staticmethod
    def value(quantity: Decimal, unit_price: Decimal) -> Decimal:
        if quantity < 0:
            raise ValueError("Quantity cannot be negative")
        if unit_price <= 0:
            raise ValueError("Unit price must be positive")
        return quantity * unit_price
</file>

<file path="src/app/domain/value_objects/__init__.py">
"""Domain Value Objects for QRL/USDT scope."""

from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.kline_interval import KlineInterval
from src.app.domain.value_objects.order_side import OrderSide
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId
from src.app.domain.value_objects.kline import KLine
from src.app.domain.value_objects.sub_account_id import SubAccountId

__all__ = [
    "OrderId",
    "OrderStatus",
    "OrderSide",
    "KlineInterval",
    "Price",
    "KLine",
    "Quantity",
    "Side",
    "Symbol",
    "Ticker",
    "Timestamp",
    "TradeId",
    "SubAccountId",
]
</file>

<file path="src/app/domain/value_objects/balance_comparison_result.py">
from dataclasses import dataclass
from decimal import Decimal

from src.app.domain.value_objects.side import Side


@dataclass(frozen=True)
class BalanceComparisonResult:
    """Outcome of balance comparison deciding whether to trade."""

    qrl_free: Decimal
    usdt_free: Decimal
    diff: Decimal
    action: str
    preferred_side: Side | None
    reason: str | None = None
</file>

<file path="src/app/domain/value_objects/kline_interval.py">
from dataclasses import dataclass


@dataclass(frozen=True)
class KlineInterval:
    """Supported MEXC spot kline intervals for QRL/USDT."""

    value: str

    _allowed = {
        "1m",
        "5m",
        "15m",
        "30m",
        "1h",
        "4h",
        "1d",
    }

    def __post_init__(self):
        if self.value not in self._allowed:
            raise ValueError(f"KlineInterval must be one of {sorted(self._allowed)}")
</file>

<file path="src/app/domain/value_objects/normalized_balances.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class NormalizedBalances:
    """Normalized balances for QRL and USDT with non-negative constraints."""

    qrl_free: Decimal
    usdt_free: Decimal

    def __post_init__(self) -> None:
        if self.qrl_free < 0 or self.usdt_free < 0:
            raise ValueError("Balances cannot be negative")
</file>

<file path="src/app/domain/value_objects/order_command.py">
from dataclasses import dataclass

from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce


@dataclass(frozen=True)
class OrderCommand:
    """Order parameters selected after allocation analysis."""

    symbol: Symbol
    side: Side
    quantity: Quantity
    price: Price
    time_in_force: TimeInForce
</file>

<file path="src/app/domain/value_objects/order_side.py">
from src.app.domain.value_objects.side import Side


class OrderSide(Side):
    """Alias for Side specific to order semantics."""
</file>

<file path="src/app/domain/value_objects/slippage.py">
from dataclasses import dataclass
from decimal import Decimal


@dataclass(frozen=True)
class SlippageAssessment:
    """Result of pre-trade slippage analysis."""

    expected_fill: Decimal
    slippage_pct: Decimal
    is_acceptable: bool
    reason: str | None = None
</file>

<file path="src/app/interfaces/http/api/account_routes.py">
from fastapi import APIRouter, HTTPException

from src.app.application.account.use_cases.get_balance import GetBalanceUseCase

router = APIRouter()


@router.get("/balance")
async def get_balance():
    """Get subaccount balance for QRL/USDT."""
    usecase = GetBalanceUseCase()
    try:
        return await usecase.execute()
    except Exception as exc:
        # Surface a clear error to the dashboard instead of a generic 500
        raise HTTPException(status_code=502, detail=f"Failed to fetch balance: {exc}") from exc
</file>

<file path="src/app/interfaces/http/pages/dashboard_routes.py">
from pathlib import Path
from typing import Any

from fastapi import APIRouter, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

router = APIRouter()
templates = Jinja2Templates(directory=str(Path(__file__).parent / "templates"))


def _dashboard_config() -> dict[str, Any]:
    return {
        "price_url": "/api/qrl/price",
        "kline_url": "/api/qrl/kline?interval=1m&limit=50",
        "order_url": "/api/qrl/orders",
        "balance_url": "/api/account/balance",
        "depth_url": "/api/market/depth?limit=20",
        "trades_url": "/api/market/trades?limit=50",
        "orders_url": "/api/trading/orders",
        "refresh_ms": 10_000,
    }


@router.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request) -> HTMLResponse:
    """Serve the trading dashboard page."""
    return templates.TemplateResponse(
        "dashboard/index.html",
        {"request": request, "dashboard_config": _dashboard_config()},
    )
</file>

<file path="src/app/interfaces/http/pages/static/js/application/dashboard.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/core/chart.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/core/dom.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/core/http.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/domain/depth.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/domain/price.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/domain/trade.js">

</file>

<file path="src/app/interfaces/http/pages/static/js/pages/dashboard-config.js">
(() => {
  const el = document.getElementById("dashboard-config");
  let data = {};
  if (el) {
    try {
      data = JSON.parse(el.textContent || "{}");
    } catch (err) {
      console.error("Invalid dashboard config", err);
    }
  }

  window.dashboardConfig = {
    priceUrl: data.price_url || "/api/qrl/price",
    klineUrl: data.kline_url || "/api/qrl/kline?interval=1m&limit=50",
    orderUrl: data.order_url || "/api/qrl/orders",
    balanceUrl: data.balance_url || "/api/account/balance",
    depthUrl: data.depth_url || "/api/market/depth?limit=20",
    tradesUrl: data.trades_url || "/api/market/trades?limit=50",
    ordersUrl: data.orders_url || "/api/trading/orders",
    refreshMs: data.refresh_ms || 10000,
  };
})();
</file>

<file path="tests/conftest.py">
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))
</file>

<file path="tests/test_allocation_domain_services.py">
from decimal import Decimal

from src.app.domain.services.balance_comparison_rule import BalanceComparisonRule
from src.app.domain.services.slippage_analyzer import SlippageAnalyzer
from src.app.domain.value_objects.normalized_balances import NormalizedBalances
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side


def test_balance_comparison_skips_within_tolerance():
    rule = BalanceComparisonRule(tolerance=Decimal("0.5"))
    balances = NormalizedBalances(qrl_free=Decimal("1.0"), usdt_free=Decimal("1.2"))

    result = rule.evaluate(balances)

    assert result.action == "skip"
    assert result.preferred_side is None
    assert "tolerance" in (result.reason or "").lower()


def test_balance_comparison_prefers_sell_when_qrl_higher():
    rule = BalanceComparisonRule()

    result = rule.evaluate(NormalizedBalances(qrl_free=Decimal("3"), usdt_free=Decimal("1")))

    assert result.action == "trade"
    assert result.preferred_side == Side("SELL")
    assert result.diff > 0


def test_slippage_analyzer_allows_better_price():
    analyzer = SlippageAnalyzer(threshold_pct=Decimal("5"))

    assessment = analyzer.assess(
        side=Side("BUY"),
        desired_price=Decimal("1"),
        target_quantity=Quantity(Decimal("1")),
        fill_quantity=Decimal("1"),
        weighted_price=Decimal("0.9"),
    )

    assert assessment.is_acceptable
    assert assessment.slippage_pct < 0
    assert assessment.reason is None


def test_slippage_analyzer_rejects_insufficient_depth():
    analyzer = SlippageAnalyzer(threshold_pct=Decimal("5"))

    assessment = analyzer.assess(
        side=Side("SELL"),
        desired_price=Decimal("1"),
        target_quantity=Quantity(Decimal("1")),
        fill_quantity=Decimal("0.25"),
        weighted_price=Decimal("1"),
    )

    assert not assessment.is_acceptable
    assert assessment.reason is not None
    assert assessment.expected_fill == Decimal("0.25")
</file>

<file path="tests/test_get_balance_use_case.py">
from datetime import datetime, timezone
from decimal import Decimal

import pytest

from src.app.application.account.use_cases.get_balance import GetBalanceUseCase
from src.app.domain.entities.account import Account
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class _FakeService:
    def __init__(self, account: Account, price: Price | None, raise_on_price: bool = False):
        self._account = account
        self._price = price
        self._raise_on_price = raise_on_price

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        return None

    async def get_account(self) -> Account:
        return self._account

    async def get_price(self, symbol):
        if self._raise_on_price:
            raise RuntimeError("price unavailable")
        return self._price


def _fake_account() -> Account:
    ts = Timestamp(datetime.now(timezone.utc))
    return Account(
        can_trade=True,
        update_time=ts,
        balances=[
            Balance(asset="USDT", free=Decimal("10"), locked=Decimal("5")),
            Balance(asset="QRL", free=Decimal("2"), locked=Decimal("1")),
        ],
    )


def _fake_price() -> Price:
    ts = Timestamp(datetime.now(timezone.utc))
    return Price(bid=Decimal("2"), ask=Decimal("4"), last=Decimal("3"), timestamp=ts)


@pytest.mark.asyncio
async def test_balance_valuation_with_price(monkeypatch):
    account = _fake_account()
    price = _fake_price()
    settings = MexcSettings(MEXC_API_KEY="x", MEXC_SECRET_KEY="y")

    monkeypatch.setattr(
        "src.app.application.account.use_cases.get_balance.build_mexc_service",
        lambda settings: _FakeService(account, price),
    )

    result = await GetBalanceUseCase(settings=settings).execute()

    assert result["valuation"]["price_available"] is True
    assert result["valuation"]["price_mid"] == "3"
    assert result["valuation"]["qrl_value_usdt"] == "9"
    assert result["valuation"]["total_value_usdt"] == "24"
    assert Decimal(result["valuation"]["qrl_pct"]) == Decimal("37.5")
    assert Decimal(result["valuation"]["usdt_pct"]) == Decimal("62.5")

    qrl_balance = next(b for b in result["balances"] if b["asset"] == "QRL")
    assert qrl_balance["free_value_usdt"] == "6"
    assert qrl_balance["locked_value_usdt"] == "3"


@pytest.mark.asyncio
async def test_balance_when_price_unavailable(monkeypatch):
    account = _fake_account()
    settings = MexcSettings(MEXC_API_KEY="x", MEXC_SECRET_KEY="y")

    monkeypatch.setattr(
        "src.app.application.account.use_cases.get_balance.build_mexc_service",
        lambda settings: _FakeService(account, None, raise_on_price=True),
    )

    result = await GetBalanceUseCase(settings=settings).execute()

    assert result["valuation"]["price_available"] is False
    assert result["valuation"]["price_mid"] is None
    assert result["valuation"]["qrl_value_usdt"] is None
    qrl_balance = next(b for b in result["balances"] if b["asset"] == "QRL")
    assert qrl_balance["free_value_usdt"] is None
    assert qrl_balance["locked_value_usdt"] is None
</file>

<file path="tests/test_mexc_settings.py">
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


def test_mexc_settings_strip_whitespace_from_secrets(monkeypatch):
    monkeypatch.setenv("MEXC_API_KEY", "mx0vgluicGPyka9vwO\r\n")
    monkeypatch.setenv("MEXC_SECRET_KEY", "secret-value\n")

    settings = MexcSettings()

    assert settings.api_key == "mx0vgluicGPyka9vwO"
    assert settings.api_secret == "secret-value"
</file>

<file path="main.py">
"""Entrypoint module for the FastAPI application."""

import asyncio
import os
import sys
from pathlib import Path

try:
    from dotenv import load_dotenv
except ModuleNotFoundError:  # pragma: no cover - optional in production images
    def load_dotenv() -> None:  # type: ignore
        return None

from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
import uvicorn

# Ensure src is on sys.path when running `python main.py` directly (e.g., Cloud Run, local)
ROOT = Path(__file__).parent
SRC = ROOT / "src"
if str(ROOT) not in sys.path:
    sys.path.append(str(ROOT))
if SRC.exists() and str(SRC) not in sys.path:
    sys.path.append(str(SRC))

from src.app.interfaces.http.api import account_routes, market_routes, system_routes, tasks_routes, trading_routes, ws_routes
from src.app.interfaces.http.api import qrl_routes, trading_api
from src.app.interfaces.http.pages import dashboard_routes
from src.app.application.exchange.mexc_service import MexcService
from src.app.infrastructure.exchange.mexc.rest_client import MexcRestClient
from src.app.infrastructure.exchange.mexc.settings import MexcSettings

load_dotenv()


def create_app() -> FastAPI:
    """Create and configure the FastAPI application."""
    app = FastAPI(
        title="QRL/USDT Trading Bot",
        version="0.1.0",
    )

    static_dir = Path(__file__).parent / "src" / "app" / "interfaces" / "http" / "pages" / "static"
    if static_dir.exists():
        app.mount("/static", StaticFiles(directory=static_dir), name="static")

    app.include_router(account_routes.router, prefix="/api/account", tags=["account"])
    app.include_router(market_routes.router, prefix="/api/market", tags=["market"])
    app.include_router(system_routes.router, prefix="/api/system", tags=["system"])
    app.include_router(trading_routes.router, prefix="/api/trading", tags=["trading"])
    app.include_router(qrl_routes.router, prefix="/api/qrl", tags=["qrl"])
    app.include_router(trading_api.router, tags=["price"])
    app.include_router(ws_routes.router, prefix="/ws", tags=["ws"])
    app.include_router(tasks_routes.router, prefix="/tasks", tags=["tasks"])
    app.include_router(tasks_routes.api_router, prefix="/api/tasks", tags=["tasks"])
    app.include_router(dashboard_routes.router, tags=["pages"])
    app.get("/", response_class=dashboard_routes.HTMLResponse)(dashboard_routes.dashboard)

    @app.get("/health", tags=["system"])
    async def health() -> dict[str, str]:
        """Health check endpoint used by deployment probes."""
        return {"status": "ok"}

    return app


app = create_app()


async def _demo_mexc_usage() -> None:
    """Demonstrate how to initialize the MexcService and call a simple API."""
    try:
        settings = MexcSettings()
    except Exception as exc:  # pragma: no cover - demonstration only
        print(f"[demo] Unable to load MEXC credentials: {exc}")
        return

    async with MexcService(MexcRestClient(settings)) as service:
        server_time = await service.get_server_time()
        print(f"[demo] MEXC server time: {server_time.value.isoformat()}")


def _should_run_demo() -> bool:
    """Gate demo execution behind an opt-in flag."""
    return os.getenv("RUN_MEXC_DEMO", "0") == "1"


def _run_server() -> None:
    """Start the uvicorn server using environment configuration."""
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "8080"))
    uvicorn.run(app, host=host, port=port, reload=False)


if __name__ == "__main__":
    if _should_run_demo():
        asyncio.run(_demo_mexc_usage())
    _run_server()

__all__ = ["app"]
</file>

<file path="src/app/domain/services/balance_comparison_rule.py">
from decimal import Decimal

from src.app.domain.value_objects.balance_comparison_result import BalanceComparisonResult
from src.app.domain.value_objects.normalized_balances import NormalizedBalances
from src.app.domain.value_objects.side import Side


class BalanceComparisonRule:
    """Decide whether to trade based on QRL vs USDT free balances."""

    def __init__(self, tolerance: Decimal = Decimal("0.01")):
        self._tolerance = tolerance

    def evaluate(self, balances: NormalizedBalances) -> BalanceComparisonResult:
        diff = balances.qrl_free - balances.usdt_free
        if abs(diff) <= self._tolerance:
            return BalanceComparisonResult(
                qrl_free=balances.qrl_free,
                usdt_free=balances.usdt_free,
                diff=diff,
                action="skip",
                preferred_side=None,
                reason="Balances within tolerance",
            )

        preferred_side = Side("SELL") if diff > 0 else Side("BUY")
        return BalanceComparisonResult(
            qrl_free=balances.qrl_free,
            usdt_free=balances.usdt_free,
            diff=diff,
            action="trade",
            preferred_side=preferred_side,
            reason=None,
        )
</file>

<file path="src/app/domain/services/depth_calculator.py">
from decimal import Decimal

from src.app.domain.value_objects.order_book import OrderBook
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side


class DepthCalculator:
    """Compute executable depth and weighted price for a side and target quantity."""

    def compute(self, book: OrderBook, side: Side, target: Quantity) -> tuple[Decimal, Decimal]:
        if side.value == "BUY":
            sorted_levels = sorted(book.asks, key=lambda lvl: lvl.price)
        else:
            sorted_levels = sorted(book.bids, key=lambda lvl: lvl.price, reverse=True)

        remaining = target.value
        total = Decimal("0")
        filled = Decimal("0")

        for level in sorted_levels:
            if remaining <= 0:
                break
            take = min(level.quantity, remaining)
            total += take * level.price
            filled += take
            remaining -= take

        weighted_price = total / filled if filled > 0 else Decimal("0")
        return filled, weighted_price
</file>

<file path="src/app/domain/services/slippage_analyzer.py">
from decimal import Decimal

from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.slippage import SlippageAssessment


class SlippageAnalyzer:
    """Evaluate slippage against a threshold for the chosen side."""

    def __init__(self, threshold_pct: Decimal):
        if threshold_pct < 0:
            raise ValueError("Slippage threshold must be non-negative")
        self._threshold_pct = threshold_pct

    def assess(
        self,
        *,
        side: Side,
        desired_price: Decimal,
        target_quantity: Quantity,
        fill_quantity: Decimal,
        weighted_price: Decimal,
    ) -> SlippageAssessment:
        if desired_price <= 0:
            raise ValueError("Desired price must be positive")

        if fill_quantity <= 0:
            return SlippageAssessment(
                expected_fill=Decimal("0"),
                slippage_pct=Decimal("0"),
                is_acceptable=False,
                reason="No executable depth",
            )

        if fill_quantity < target_quantity.value:
            return SlippageAssessment(
                expected_fill=fill_quantity,
                slippage_pct=Decimal("0"),
                is_acceptable=False,
                reason="Insufficient depth for target quantity",
            )

        if side.value == "BUY":
            delta = weighted_price - desired_price
        else:
            delta = desired_price - weighted_price
        slippage_pct = (delta / desired_price) * Decimal("100")

        if delta <= 0:
            return SlippageAssessment(
                expected_fill=fill_quantity,
                slippage_pct=slippage_pct,
                is_acceptable=True,
                reason=None,
            )

        is_acceptable = slippage_pct <= self._threshold_pct
        reason = None if is_acceptable else "Slippage exceeds threshold"
        return SlippageAssessment(
            expected_fill=fill_quantity,
            slippage_pct=slippage_pct,
            is_acceptable=is_acceptable,
            reason=reason,
        )
</file>

<file path="src/app/domain/value_objects/order_book.py">
from dataclasses import dataclass, field
from decimal import Decimal


@dataclass(frozen=True)
class DepthLevel:
    """Single price level within an order book side."""

    price: Decimal
    quantity: Decimal

    def __post_init__(self) -> None:
        if self.price <= Decimal("0") or self.quantity <= Decimal("0"):
            raise ValueError("DepthLevel price and quantity must be positive")


@dataclass(frozen=True)
class OrderBookSide:
    """Side indicator for order book traversal."""

    value: str

    def __post_init__(self) -> None:
        if self.value not in ("BID", "ASK"):
            raise ValueError("OrderBookSide must be BID or ASK")


@dataclass(frozen=True)
class OrderBook:
    """Aggregated order book snapshot with bids and asks."""

    bids: list[DepthLevel] = field(default_factory=list)
    asks: list[DepthLevel] = field(default_factory=list)
</file>

<file path="src/app/infrastructure/exchange/mexc/factories.py">
"""
Factories to translate MEXC REST/WebSocket DTOs into domain aggregates.

These implementations are intentionally lightweight placeholders. They ensure
that aggregate construction paths are present and wired, while allowing the
future work to enrich the mapping with full business rules.
"""

from datetime import datetime, timezone
from decimal import Decimal
from typing import Iterable, Optional

from src.app.domain.aggregates.account_state import AccountState
from src.app.domain.aggregates.market_snapshot import MarketSnapshot
from src.app.domain.aggregates.trading_session import TradingSession
from src.app.domain.entities.account import Account
from src.app.domain.entities.kline import Kline
from src.app.domain.entities.order import Order
from src.app.domain.entities.order_book_level import OrderBookLevel
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.kline_interval import KlineInterval
from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_side import OrderSide
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.ticker import Ticker
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId
from src.app.infrastructure.exchange.mexc.generated import (
    PrivateAccountV3Api_pb2,
    PrivateOrdersV3Api_pb2,
    PublicAggreDepthsV3Api_pb2,
    PublicAggreDealsV3Api_pb2,
    PublicBookTickerV3Api_pb2,
    PublicSpotKlineV3Api_pb2,
)


def _default_timestamp() -> Timestamp:
    return Timestamp(datetime.now(timezone.utc))


def _levels_from_depth(
    depth: Optional[PublicAggreDepthsV3Api_pb2.PublicAggreDepthsV3Api],
) -> tuple[list[OrderBookLevel], list[OrderBookLevel]]:
    if depth is None:
        return [], []

    bids = [
        OrderBookLevel(
            price=Decimal(str(item.price)),
            quantity=Decimal(str(item.quantity)),
            side=OrderSide("BUY"),
        )
        for item in getattr(depth, "bids", [])  # type: ignore[attr-defined]
    ]
    asks = [
        OrderBookLevel(
            price=Decimal(str(item.price)),
            quantity=Decimal(str(item.quantity)),
            side=OrderSide("SELL"),
        )
        for item in getattr(depth, "asks", [])  # type: ignore[attr-defined]
    ]
    return bids, asks


def market_snapshot_from_sources(
    symbol: Symbol,
    depth_proto: Optional[PublicAggreDepthsV3Api_pb2.PublicAggreDepthsV3Api] = None,
    trades: Optional[Iterable[Trade]] = None,
    ticker_proto: Optional[PublicBookTickerV3Api_pb2.PublicBookTickerV3Api] = None,
) -> MarketSnapshot:
    """
    Build a MarketSnapshot aggregate from available feed DTOs.

    The function accepts partial data (depth only, depth + trades, etc.) so
    the callers can incrementally enrich the snapshot.
    """

    bids, asks = _levels_from_depth(depth_proto)
    ticker: Ticker | None = None
    if ticker_proto is not None:
        bid = Decimal(str(getattr(ticker_proto, "bidPrice", 0)))
        ask = Decimal(str(getattr(ticker_proto, "askPrice", 0)))
        last = Decimal(str(getattr(ticker_proto, "lastPrice", 0)))
        if bid > 0 and ask > 0 and last > 0:
            ticker = Ticker(
                symbol=symbol,
                last_price=last,
                bid_price=bid,
                ask_price=ask,
                ts=_default_timestamp().value,
            )

    return MarketSnapshot(
        symbol=symbol,
        bids=bids,
        asks=asks,
        trades=list(trades or []),
        ticker=ticker,
        updated_at=_default_timestamp(),
    )


def account_state_from_proto(
    symbol: Symbol, account_proto: PrivateAccountV3Api_pb2.PrivateAccountV3Api
) -> AccountState:
    """
    Translate private account snapshot DTO into AccountState aggregate.

    Balance parsing is intentionally minimal; further normalization can be
    implemented when business rules are ready.
    """

    balances: list[Balance] = []
    for item in getattr(account_proto, "balances", []):  # type: ignore[attr-defined]
        balances.append(
            Balance(
                asset=getattr(item, "asset", ""),
                free=Decimal(str(getattr(item, "free", 0))),
                locked=Decimal(str(getattr(item, "locked", 0))),
            )
        )

    account = Account(
        can_trade=bool(getattr(account_proto, "canTrade", True)),
        update_time=_default_timestamp(),
        balances=balances,
    )
    return AccountState(
        symbol=symbol,
        account=account,
        open_orders=[],
        updated_at=_default_timestamp(),
    )


def trading_session_from_orders(
    symbol: Symbol, orders: Optional[Iterable[Order]] = None, trades: Optional[Iterable[Trade]] = None
) -> TradingSession:
    """Create a TradingSession aggregate from existing order/trade records."""

    return TradingSession(
        symbol=symbol,
        open_orders=list(orders or []),
        trades=list(trades or []),
        started_at=_default_timestamp(),
        last_activity_at=_default_timestamp(),
    )


def trades_from_public_proto(
    symbol: Symbol, deals_proto: Optional[PublicAggreDealsV3Api_pb2.PublicAggreDealsV3Api] = None
) -> list[Trade]:
    """Convert public trades DTO to domain trades (skeleton mapping)."""

    if deals_proto is None:
        return []

    trades: list[Trade] = []
    for item in getattr(deals_proto, "deals", []):  # type: ignore[attr-defined]
        trade_id_str = str(getattr(item, "tradeId", "0"))
        order_id_str = str(getattr(item, "orderId", "0"))
        trades.append(
            Trade(
                trade_id=TradeId(trade_id_str),
                order_id=OrderId(order_id_str),
                symbol=symbol,
                side=OrderSide("BUY") if bool(getattr(item, "isBuyerMaker", False)) else OrderSide("SELL"),
                price=Decimal(str(getattr(item, "price", 0))),
                quantity=Decimal(str(getattr(item, "quantity", 0))),
                fee=None,
                fee_asset=None,
                timestamp=_default_timestamp(),
            )
        )
    return trades


def klines_from_proto(
    symbol: Symbol, kline_proto: Optional[PublicSpotKlineV3Api_pb2.PublicSpotKlineV3Api] = None
) -> list[Kline]:
    """Convert spot kline DTOs to domain klines (skeleton mapping)."""

    if kline_proto is None:
        return []

    klines: list[Kline] = []
    interval = KlineInterval(str(getattr(kline_proto, "interval", "1m")))
    for item in getattr(kline_proto, "klineList", []):  # type: ignore[attr-defined]
        open_time_ms = int(getattr(item, "openTime", 0))
        close_time_ms = int(getattr(item, "closeTime", 0))
        klines.append(
            Kline(
                symbol=symbol,
                interval=interval,
                open=Decimal(str(getattr(item, "open", 0))),
                high=Decimal(str(getattr(item, "high", 0))),
                low=Decimal(str(getattr(item, "low", 0))),
                close=Decimal(str(getattr(item, "close", 0))),
                volume=Decimal(str(getattr(item, "volume", 0))),
                open_time=Timestamp(datetime.fromtimestamp(open_time_ms / 1000, tz=timezone.utc)),
                close_time=Timestamp(datetime.fromtimestamp(close_time_ms / 1000, tz=timezone.utc)),
            )
        )
    return klines


def orders_from_private_proto(
    symbol: Symbol, orders_proto: Optional[PrivateOrdersV3Api_pb2.PrivateOrdersV3Api] = None
) -> list[Order]:
    """Convert private orders DTO to domain orders (skeleton mapping)."""

    if orders_proto is None:
        return []

    orders: list[Order] = []
    for item in getattr(orders_proto, "orders", []):  # type: ignore[attr-defined]
        orders.append(
            Order(
                order_id=OrderId(str(getattr(item, "orderId", ""))),
                symbol=symbol,
                side=OrderSide(str(getattr(item, "side", "BUY"))),
                order_type=OrderType(str(getattr(item, "type", "LIMIT"))),
                status=OrderStatus(str(getattr(item, "status", "NEW"))),
                price=Decimal(str(getattr(item, "price", 0))),
                quantity=Quantity(Decimal(str(getattr(item, "origQty", 0)))),
                created_at=_default_timestamp(),
                time_in_force=None,
                client_order_id=str(getattr(item, "clientOrderId", "")) if getattr(item, "clientOrderId", None) else None,
                executed_quantity=Decimal(str(getattr(item, "executedQty", 0))),
                cumulative_quote_quantity=Decimal(str(getattr(item, "cummulativeQuoteQty", 0))),
                updated_at=_default_timestamp(),
            )
        )
    return orders
</file>

<file path="src/app/infrastructure/exchange/mexc/qrl/qrl_rest_client.py">
from src.app.domain.value_objects.qrl_usdt_pair import QrlUsdtPair
from src.app.infrastructure.exchange.mexc.rest_client import MexcRestClient
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class QrlRestClient:
    """Wrapper to freeze symbol to QRL/USDT for all REST calls."""

    def __init__(self, settings: MexcSettings):
        self._settings = settings
        self._client = MexcRestClient(settings)

    async def __aenter__(self) -> "QrlRestClient":
        await self._client.__aenter__()
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self._client.__aexit__(exc_type, exc, tb)

    async def ticker_24h(self) -> dict:
        return await self._client.ticker_24h(symbol=QrlUsdtPair.symbol())

    async def klines(self, *, interval: str, limit: int) -> list:
        return await self._client.klines(symbol=QrlUsdtPair.symbol(), interval=interval, limit=limit)

    async def depth(self, *, limit: int = 50) -> dict:
        return await self._client.depth(symbol=QrlUsdtPair.symbol(), limit=limit)

    async def market_trades(self, *, limit: int = 50) -> list:
        return await self._client.trades(symbol=QrlUsdtPair.symbol(), limit=limit)

    async def create_order(
        self,
        *,
        side: str,
        order_type: str,
        quantity: str,
        price: str | None,
        time_in_force: str | None,
        client_order_id: str | None,
    ) -> dict:
        return await self._client.create_order(
            symbol=QrlUsdtPair.symbol(),
            side=side,
            order_type=order_type,
            quantity=quantity,
            price=price,
            time_in_force=time_in_force,
            client_order_id=client_order_id,
        )

    async def get_order(self, *, order_id: str | None, client_order_id: str | None) -> dict:
        return await self._client.get_order(
            symbol=QrlUsdtPair.symbol(), order_id=order_id, client_order_id=client_order_id
        )

    async def cancel_order(self, *, order_id: str | None, client_order_id: str | None) -> dict:
        return await self._client.cancel_order(
            symbol=QrlUsdtPair.symbol(), order_id=order_id, client_order_id=client_order_id
        )
</file>

<file path="src/app/interfaces/http/api/market_routes.py">
from fastapi import APIRouter, Query

from src.app.application.market.use_cases.get_depth import GetDepthUseCase
from src.app.application.market.use_cases.get_kline import GetKlineUseCase
from src.app.application.market.use_cases.get_market_trades import GetMarketTradesInput, GetMarketTradesUseCase
from src.app.application.market.use_cases.get_stats24h import GetStats24hUseCase
from src.app.application.market.use_cases.get_ticker import GetTickerUseCase

router = APIRouter()


@router.get("/depth")
async def get_depth(limit: int = Query(default=50, ge=5, le=1000)):
    """Get order book depth for QRL/USDT."""
    usecase = GetDepthUseCase()
    from src.app.application.market.use_cases.get_depth import GetDepthInput

    return await usecase.execute(data=GetDepthInput(limit=limit))


@router.get("/ticker")
async def get_ticker():
    """Get ticker for QRL/USDT."""
    usecase = GetTickerUseCase()
    return await usecase.execute()


@router.get("/kline")
async def get_kline(interval: str = Query(default="1m"), limit: int = Query(default=50, ge=1, le=500)):
    """Get kline data for QRL/USDT."""
    usecase = GetKlineUseCase()
    from src.app.application.market.use_cases.get_kline import GetKlineInput

    return await usecase.execute(data=GetKlineInput(interval=interval, limit=limit))


@router.get("/stats24h")
async def get_stats_24h():
    """Get 24h statistics for QRL/USDT."""
    usecase = GetStats24hUseCase()
    return await usecase.execute()


@router.get("/trades")
async def get_market_trades(limit: int = Query(default=50, ge=1, le=500)):
    """Get recent public trades for QRL/USDT."""
    usecase = GetMarketTradesUseCase()
    return await usecase.execute(data=GetMarketTradesInput(limit=limit))
</file>

<file path="src/app/interfaces/http/pages/static/js/domain/order.js">
(() => {
  const cancelOrder = async (cfg, orderId) => {
    if (!orderId) throw new Error("orderId required");
    const url = `${cfg.cancelOrderBase || "/api/trading/orders"}/${orderId}/cancel`;
    const resp = await fetch(url, { method: "POST" });
    const data = await resp.json().catch(() => ({}));
    if (!resp.ok) {
      const detail = data.detail || JSON.stringify(data);
      throw new Error(detail);
    }
    return data;
  };

  window.orderDomain = { cancelOrder };
})();
</file>

<file path="src/app/infrastructure/exchange/mexc/mappers.py">
"""Mapping helpers between MEXC API payloads and domain objects."""

from datetime import datetime, timezone
from decimal import Decimal, InvalidOperation
from typing import Any

from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.entities.trade import Trade
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.order_book import DepthLevel, OrderBook
from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.domain.value_objects.timestamp import Timestamp
from src.app.domain.value_objects.trade_id import TradeId


def _to_decimal(value: Any) -> Decimal:
    return Decimal(str(value))


def _to_timestamp_from_ms(value: int | float | str) -> Timestamp:
    if value in (None, "", 0):
        ms_value = 0
    else:
        try:
            ms_value = int(value)
        except (TypeError, ValueError):
            ms_value = 0
    dt = datetime.fromtimestamp(ms_value / 1000, tz=timezone.utc)
    return Timestamp(dt)


def server_time_to_timestamp(payload: dict[str, Any]) -> Timestamp:
    return _to_timestamp_from_ms(payload.get("serverTime", 0))


def account_from_api(payload: dict[str, Any]) -> Account:
    balances = [
        Balance(asset=item["asset"], free=_to_decimal(item["free"]), locked=_to_decimal(item["locked"]))
        for item in payload.get("balances", [])
    ]
    return Account(
        can_trade=bool(payload.get("canTrade", True)),
        update_time=_to_timestamp_from_ms(payload.get("updateTime", 0)),
        balances=balances,
    )


def order_from_api(payload: dict[str, Any]) -> Order:
    order_id_value = payload.get("orderId")
    if order_id_value is None:
        raise ValueError("orderId is required in MEXC response")
    return Order(
        order_id=OrderId(str(order_id_value)),
        symbol=Symbol(payload.get("symbol", "QRLUSDT")),
        side=Side(payload.get("side", "BUY")),
        order_type=OrderType(payload.get("type", "LIMIT")),
        status=OrderStatus(payload.get("status", "NEW")),
        price=_to_decimal(payload.get("price", "0")),
        quantity=Quantity(_to_decimal(payload.get("origQty", payload.get("quantity", "0.00000001")))),
        time_in_force=TimeInForce(payload["timeInForce"]) if payload.get("timeInForce") else None,
        created_at=_to_timestamp_from_ms(payload.get("transactTime", payload.get("createTime", 0))),
        client_order_id=payload.get("clientOrderId") or payload.get("origClientOrderId"),
        executed_quantity=_to_decimal(payload.get("executedQty", "0"))
        if payload.get("executedQty") is not None
        else None,
        cumulative_quote_quantity=_to_decimal(payload.get("cummulativeQuoteQty", "0"))
        if payload.get("cummulativeQuoteQty") is not None
        else None,
        updated_at=_to_timestamp_from_ms(payload["updateTime"]) if payload.get("updateTime") else None,
    )


def trade_from_api(payload: dict[str, Any]) -> Trade:
    return Trade(
        trade_id=TradeId(str(payload.get("id"))),
        order_id=OrderId(str(payload.get("orderId"))),
        symbol=Symbol(payload.get("symbol", "QRLUSDT")),
        side=Side("BUY" if payload.get("isBuyer") else "SELL"),
        price=_to_decimal(payload.get("price", "0")),
        quantity=_to_decimal(payload.get("qty", payload.get("quantity", "0"))),
        fee=_to_decimal(payload["commission"]) if payload.get("commission") else None,
        fee_asset=payload.get("commissionAsset"),
        timestamp=_to_timestamp_from_ms(payload.get("time", 0)),
    )


def _parse_levels(raw: Any) -> list[DepthLevel]:
    levels: list[DepthLevel] = []
    if not isinstance(raw, list):
        return levels
    for item in raw:
        if not isinstance(item, (list, tuple)) or len(item) < 2:
            continue
        try:
            price = _to_decimal(item[0])
            quantity = _to_decimal(item[1])
            level = DepthLevel(price=price, quantity=quantity)
        except (InvalidOperation, TypeError, ValueError):
            continue
        levels.append(level)
    return levels


def order_book_from_api(payload: dict[str, Any]) -> OrderBook:
    """Map depth payload to an OrderBook VO."""

    bids = _parse_levels(payload.get("bids", []))
    asks = _parse_levels(payload.get("asks", []))
    return OrderBook(bids=bids, asks=asks)
</file>

<file path="src/app/infrastructure/exchange/mexc/settings.py">
from typing import Literal

from pydantic import Field, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict


class MexcSettings(BaseSettings):
    """Configuration for MEXC REST client."""

    api_key: str = Field(alias="MEXC_API_KEY")
    api_secret: str = Field(alias="MEXC_SECRET_KEY")
    base_url: str = Field(default="https://api.mexc.com", alias="MEXC_BASE_URL")
    recv_window: int = Field(default=5000, alias="MEXC_RECV_WINDOW")
    timeout: int = Field(default=10, alias="MEXC_TIMEOUT")
    max_connections: int = Field(default=20, alias="MEXC_MAX_CONNECTIONS", gt=0)
    max_keepalive_connections: int = Field(default=10, alias="MEXC_MAX_KEEPALIVE", gt=0)
    keepalive_expiry: float = Field(default=15.0, alias="MEXC_KEEPALIVE_EXPIRY", gt=0)
    sub_account_mode: Literal["SPOT", "BROKER"] = Field(default="SPOT", alias="SUB_ACCOUNT_MODE")
    sub_account_id: int | str | None = Field(default=None, alias="SUB_ACCOUNT_ID")
    sub_account_name: str | None = Field(default=None, alias="SUB_ACCOUNT_NAME")

    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

    @field_validator("sub_account_mode")
    @classmethod
    def _uppercase_mode(cls, value: str) -> str:
        return value.upper()

    @field_validator("sub_account_id", "sub_account_name")
    @classmethod
    def _empty_to_none(cls, value: str | int | None) -> str | int | None:
        if isinstance(value, str) and value.strip() == "":
            return None
        return value

    @field_validator("api_key", "api_secret")
    @classmethod
    def _strip_whitespace(cls, value: str) -> str:
        cleaned = value.strip()
        if "\n" in cleaned or "\r" in cleaned:
            cleaned = cleaned.replace("\n", "").replace("\r", "")
        return cleaned
</file>

<file path="src/app/interfaces/http/pages/static/js/pages/dashboard-renderers.js">
(() => {
  const $ = (id) => document.getElementById(id);
  const setText = (id, v = "") => {
    const el = $(id);
    if (el) el.textContent = v;
  };

  const chartEl = $("klineChart");
  const chart =
    window.Chart && chartEl
      ? new Chart(chartEl.getContext("2d"), {
          type: "line",
          data: { labels: [], datasets: [{ data: [], borderColor: "#2196f3", fill: false, tension: 0.2 }] },
        })
      : { data: { labels: [], datasets: [{ data: [] }] }, update() {} };

  const setPrice = (d) => {
    setText("price-error", "");
    setText("bid", d?.bid ?? "--");
    setText("ask", d?.ask ?? "--");
    setText("last", d?.last ?? "--");
    const raw = d?.timestamp;
    const parsed = typeof raw === "number" || typeof raw === "string" ? new Date(raw) : new Date();
    setText("timestamp", parsed.toISOString());
  };

  const setKlines = (items = []) => {
    chart.data.labels = items.map((k) => new Date(k.timestamp).toLocaleTimeString());
    chart.data.datasets[0].data = items.map((k) => Number(k.close));
    chart.update();
  };

  const setBalances = (payload = {}) => {
    setText("balance-error", "");
    const balances = payload.balances || [];
    const byAsset = (asset) => balances.find((b) => b.asset === asset) || { free: "--", locked: "--" };
    const qrl = byAsset("QRL");
    const usdt = byAsset("USDT");
    setText("bal-qrl-free", qrl.free);
    setText("bal-qrl-locked", qrl.locked);
    setText("bal-usdt-free", usdt.free);
    setText("bal-usdt-locked", usdt.locked);
  };

  const normalizeDepth = (item) => (Array.isArray(item) ? { price: item[0], qty: item[1] } : { price: item?.price ?? item?.p ?? "--", qty: item?.quantity ?? item?.q ?? "--" });

  const setDepth = (payload = {}) => {
    setText("depth-error", "");
    const bidsEl = $("depth-bids");
    const asksEl = $("depth-asks");
    const build = (items = []) =>
      items
        .slice(0, 10)
        .map((entry) => {
          const { price, qty } = normalizeDepth(entry);
          return `<li><span class="price">${price}</span><span class="qty">${qty}</span></li>`;
        })
        .join("");
    if (bidsEl) bidsEl.innerHTML = build(payload.bids);
    if (asksEl) asksEl.innerHTML = build(payload.asks);
  };

  const normalizeTrade = (t = {}) => {
    const side = t.side ?? (t.isBuyerMaker === true ? "SELL" : t.isBuyerMaker === false ? "BUY" : "--");
    const tsRaw = t.timestamp ?? t.time ?? Date.now();
    return { price: t.price ?? t.p ?? "--", qty: t.quantity ?? t.q ?? "--", side, ts: typeof tsRaw === "string" ? tsRaw : new Date(tsRaw).toISOString() };
  };

  const setTrades = (payload = []) => {
    setText("trades-error", "");
    const el = $("trades-list");
    if (!el) return;
    el.innerHTML = payload
      .slice(0, 20)
      .map((t) => {
        const n = normalizeTrade(t);
        return `<li><span class="side ${n.side === "BUY" ? "buy" : "sell"}">${n.side}</span><span class="price">${n.price}</span><span class="qty">${n.qty}</span><span class="ts">${n.ts}</span></li>`;
      })
      .join("");
  };

  const formatAmount = (price, qty, quote) => {
    if (quote !== undefined && quote !== null) return quote;
    const p = Number(price);
    const q = Number(qty);
    return Number.isFinite(p) && Number.isFinite(q) ? (p * q).toFixed(4) : "--";
  };

  const normalizeOrder = (o = {}) => {
    const status = (o.status ?? "--").toString().toUpperCase();
    const price = o.price ?? o.limit_price ?? o.avg_price ?? "--";
    const qty = o.quantity ?? o.orig_qty ?? "--";
    const quote =
      o.cumulative_quote_quantity ??
      o.cum_quote_quantity ??
      o.cumulative_quote_qty ??
      o.cummulativeQuoteQty ??
      undefined;
    return {
      side: o.side ?? "--",
      status,
      price,
      qty,
      amount: formatAmount(price, qty, quote),
      id: o.order_id ?? o.orderId ?? "--",
      canCancel: !["CANCELED", "FILLED", "REJECTED", "EXPIRED"].includes(status),
    };
  };

  const setOrders = (payload = []) => {
    setText("orders-error", "");
    const el = $("orders-list");
    if (!el) return;
    const header =
      '<li class="orders-header"><span class="id">訂單ID</span><span class="side">方向</span><span class="price">價格</span><span class="qty">數量</span><span class="amount">金額</span><span class="status">狀態</span><span class="action">操作</span></li>';
    el.innerHTML =
      header +
      payload
        .slice(0, 20)
        .map((o) => {
          const n = normalizeOrder(o);
          const action = n.canCancel
            ? `<button class="order-cancel" data-order-id="${n.id}" aria-label="取消訂單 ${n.id}">取消</button>`
            : `<span class="status-label">${n.status}</span>`;
          return `<li data-order-id="${n.id}"><span class="id">${n.id}</span><span class="side ${n.side === "BUY" ? "buy" : "sell"}">${n.side}</span><span class="price">${n.price}</span><span class="qty">${n.qty}</span><span class="amount">${n.amount}</span><span class="status">${n.status}</span><span class="action">${action}</span></li>`;
        })
        .join("");
  };

  window.dashboardUI = { setText, setPrice, setKlines, setBalances, setDepth, setTrades, setOrders };
})();
</file>

<file path="src/app/interfaces/http/schemas.py">
"""Pydantic schemas for interface layer requests/responses."""

from datetime import datetime
from decimal import Decimal
from typing import Literal

from pydantic import BaseModel, ConfigDict, Field


class PlaceOrderRequest(BaseModel):
    symbol: str = Field(default="QRLUSDT", description="Trading symbol")
    side: Literal["BUY", "SELL"]
    order_type: Literal["LIMIT", "MARKET"] = Field(default="LIMIT", alias="type")
    quantity: Decimal
    price: Decimal | None = None
    time_in_force: Literal["GTC", "IOC", "FOK"] | None = Field(default="GTC", alias="timeInForce")
    client_order_id: str | None = Field(default=None, alias="clientOrderId")


class CancelOrderRequest(BaseModel):
    symbol: str = Field(default="QRLUSDT", description="Trading symbol")
    order_id: str | None = Field(default=None, alias="orderId")
    client_order_id: str | None = Field(default=None, alias="clientOrderId")


class GetOrderRequest(BaseModel):
    symbol: str = Field(default="QRLUSDT", description="Trading symbol")
    order_id: str | None = Field(default=None, alias="orderId")
    client_order_id: str | None = Field(default=None, alias="clientOrderId")


class ListTradesRequest(BaseModel):
    symbol: str = Field(default="QRLUSDT", description="Trading symbol")


class AllocationResponse(BaseModel):
    """Response returned when the allocation task is triggered."""

    model_config = ConfigDict(from_attributes=True)

    request_id: str = Field(description="Identifier for the allocation trigger")
    status: str = Field(description="Execution status for the allocation task")
    executed_at: datetime = Field(description="UTC timestamp when the task executed")
    action: str = Field(description="Trade action executed (BUY, SELL, SKIP, REJECTED)")
    order_id: str | None = Field(default=None, description="Order identifier returned by the exchange")
    reason: str | None = Field(default=None, description="Reason when action is skipped or rejected")
    slippage_pct: Decimal | None = Field(
        default=None, description="Calculated slippage percentage for the planned order"
    )
    expected_fill: Decimal | None = Field(
        default=None, description="Expected fill quantity based on current depth"
    )
</file>

<file path="src/app/interfaces/tasks/entrypoints.py">
"""HTTP/Scheduler entrypoints for background tasks."""

import asyncio
import os

from src.app.application.system.use_cases.allocation import AllocationResult, AllocationUseCase


def _allocation_timeout_seconds() -> float:
    """Read the scheduler task timeout from the environment."""
    raw: str | None = os.getenv("TASK_TIMEOUT_SECONDS", "20")
    try:
        return float(raw)
    except ValueError:
        return 20.0


async def run_allocation(timeout_seconds: float | None = None) -> AllocationResult:
    """Trigger the allocation use case for Cloud Scheduler with a bounded runtime."""
    usecase = AllocationUseCase()
    timeout = timeout_seconds or _allocation_timeout_seconds()
    return await asyncio.wait_for(usecase.execute(), timeout=timeout)
</file>

<file path="src/app/infrastructure/exchange/mexc/rest_client.py">
import hashlib
import hmac
import time
from typing import Any
from urllib.parse import urlencode

import httpx

from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class MexcRestClient:
    """Async REST client for MEXC spot API v3."""

    def __init__(self, settings: MexcSettings):
        self._settings = settings
        self._client: httpx.AsyncClient | None = None

    async def __aenter__(self) -> "MexcRestClient":
        limits = httpx.Limits(
            max_connections=self._settings.max_connections,
            max_keepalive_connections=self._settings.max_keepalive_connections,
            keepalive_expiry=self._settings.keepalive_expiry,
        )
        self._client = httpx.AsyncClient(
            base_url=self._settings.base_url,
            timeout=httpx.Timeout(self._settings.timeout),
            limits=limits,
        )
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        if self._client:
            await self._client.aclose()
            self._client = None

    def _assert_client(self) -> httpx.AsyncClient:
        if self._client is None:
            raise RuntimeError("MexcRestClient context has not been entered")
        return self._client

    def _signed_params(self, params: dict[str, Any]) -> dict[str, Any]:
        payload = {k: v for k, v in params.items() if v is not None}
        if self._settings.sub_account_mode == "BROKER":
            if self._settings.sub_account_name is not None:
                payload.setdefault("subAccount", self._settings.sub_account_name)
        elif self._settings.sub_account_id is not None:
            payload.setdefault("subAccountId", self._settings.sub_account_id)
        payload.setdefault("timestamp", int(time.time() * 1000))
        payload.setdefault("recvWindow", self._settings.recv_window)
        query = urlencode(payload, doseq=True)
        signature = hmac.new(
            self._settings.api_secret.encode("utf-8"),
            query.encode("utf-8"),
            hashlib.sha256,
        ).hexdigest()
        payload["signature"] = signature
        return payload

    async def _request(
        self, method: str, path: str, params: dict[str, Any] | None = None, signed: bool = False
    ) -> dict[str, Any]:
        client = self._assert_client()
        request_params = self._signed_params(params or {}) if signed else params or {}
        headers = {"X-MEXC-APIKEY": self._settings.api_key} if signed else None
        response = await client.request(method, path, params=request_params, headers=headers)
        response.raise_for_status()
        return response.json()

    async def ping(self) -> dict[str, Any]:
        return await self._request("GET", "/api/v3/ping")

    async def get_server_time(self) -> dict[str, Any]:
        return await self._request("GET", "/api/v3/time")

    async def get_account(self) -> dict[str, Any]:
        return await self._request("GET", "/api/v3/account", signed=True)

    async def create_order(
        self,
        *,
        symbol: str,
        side: str,
        order_type: str,
        quantity: str | None = None,
        price: str | None = None,
        time_in_force: str | None = None,
        client_order_id: str | None = None,
    ) -> dict[str, Any]:
        params: dict[str, Any] = {
            "symbol": symbol,
            "side": side,
            "type": order_type,
            "quantity": quantity,
            "price": price,
            "timeInForce": time_in_force,
            "newClientOrderId": client_order_id,
        }
        return await self._request("POST", "/api/v3/order", params=params, signed=True)

    async def get_order(
        self, *, symbol: str, order_id: str | None = None, client_order_id: str | None = None
    ) -> dict[str, Any]:
        params: dict[str, Any] = {
            "symbol": symbol,
            "orderId": order_id,
            "origClientOrderId": client_order_id,
        }
        return await self._request("GET", "/api/v3/order", params=params, signed=True)

    async def cancel_order(
        self, *, symbol: str, order_id: str | None = None, client_order_id: str | None = None
    ) -> dict[str, Any]:
        params: dict[str, Any] = {
            "symbol": symbol,
            "orderId": order_id,
            "origClientOrderId": client_order_id,
        }
        return await self._request("DELETE", "/api/v3/order", params=params, signed=True)

    async def list_open_orders(self, *, symbol: str | None = None) -> list[dict[str, Any]]:
        params: dict[str, Any] = {"symbol": symbol} if symbol else {}
        result = await self._request("GET", "/api/v3/openOrders", params=params, signed=True)
        if isinstance(result, list):
            return result
        return []

    async def list_trades(self, *, symbol: str, limit: int = 50) -> list[dict[str, Any]]:
        params: dict[str, Any] = {"symbol": symbol, "limit": limit}
        result = await self._request("GET", "/api/v3/myTrades", params=params, signed=True)
        if isinstance(result, list):
            return result
        return []

    async def ticker_24h(self, *, symbol: str) -> dict[str, Any]:
        params = {"symbol": symbol}
        return await self._request("GET", "/api/v3/ticker/24hr", params=params)

    async def klines(self, *, symbol: str, interval: str, limit: int = 100) -> list[list[Any]]:
        params = {"symbol": symbol, "interval": interval, "limit": limit}
        result = await self._request("GET", "/api/v3/klines", params=params)
        if isinstance(result, list):
            return result
        return []

    async def trades(self, *, symbol: str, limit: int = 50) -> list[dict[str, Any]]:
        """Public recent trades."""
        params = {"symbol": symbol, "limit": limit}
        result = await self._request("GET", "/api/v3/trades", params=params)
        if isinstance(result, list):
            return result
        return []

    async def depth(self, *, symbol: str, limit: int = 50) -> dict[str, Any]:
        params: dict[str, Any] = {"symbol": symbol, "limit": limit}
        return await self._request("GET", "/api/v3/depth", params=params)
</file>

<file path="src/app/interfaces/http/api/qrl_routes.py">
import asyncio
from decimal import Decimal

from fastapi import APIRouter, HTTPException, Query

from src.app.application.market.qrl.get_qrl_depth import GetQrlDepth
from src.app.application.market.qrl.get_qrl_kline import GetQrlKline
from src.app.application.market.qrl.get_qrl_price import GetQrlPrice
from src.app.application.market.use_cases.get_market_trades import GetMarketTradesUseCase
from src.app.application.trading.qrl.cancel_qrl_order import CancelQrlOrder
from src.app.application.trading.qrl.get_qrl_order import GetQrlOrder
from src.app.application.trading.qrl.place_qrl_order import PlaceQrlOrder
from src.app.application.account.use_cases.get_balance import GetBalanceUseCase
from src.app.application.trading.use_cases.list_orders import ListOrdersUseCase
from src.app.application.trading.use_cases.list_trades import ListTradesUseCase
from src.app.domain.value_objects.qrl_price import QrlPrice
from src.app.domain.value_objects.qrl_quantity import QrlQuantity
from src.app.infrastructure.exchange.mexc.qrl.qrl_rest_client import QrlRestClient
from src.app.infrastructure.exchange.mexc.qrl.qrl_settings import QrlSettings
from src.app.interfaces.http.schemas import PlaceOrderRequest

router = APIRouter()


def _client() -> QrlRestClient:
    return QrlRestClient(QrlSettings())


@router.get("/price")
async def qrl_price():
    usecase = GetQrlPrice(_client())
    try:
        snapshot = await usecase.execute()
        return snapshot.to_dict()
    except Exception as exc:
        raise HTTPException(status_code=502, detail=f"Failed to fetch QRL price: {exc}") from exc


@router.get("/kline")
async def qrl_kline(interval: str = Query(default="1m"), limit: int = Query(default=50, ge=1, le=500)):
    usecase = GetQrlKline(_client(), interval=interval, limit=limit)
    try:
        raw = await usecase.execute()
        normalized = [
            {"timestamp": item[0], "open": item[1], "high": item[2], "low": item[3], "close": item[4], "volume": item[5]}
            for item in raw
        ]
        return normalized
    except Exception as exc:
        raise HTTPException(status_code=502, detail=f"Failed to fetch QRL klines: {exc}") from exc


@router.get("/depth")
async def qrl_depth(limit: int = Query(default=50, ge=5, le=1000)):
    usecase = GetQrlDepth(_client(), limit=limit)
    try:
        return await usecase.execute()
    except Exception as exc:
        raise HTTPException(status_code=502, detail=f"Failed to fetch QRL depth: {exc}") from exc


@router.post("/orders")
async def qrl_place_order(request: PlaceOrderRequest):
    usecase = PlaceQrlOrder(_client())
    price_vo = QrlPrice(request.price) if request.price is not None else None
    qty_vo = QrlQuantity(request.quantity)
    return await usecase.execute(
        side=request.side,
        order_type=request.order_type,
        price=price_vo,
        quantity=qty_vo,
        time_in_force=request.time_in_force,
        client_order_id=request.client_order_id,
    )


@router.post("/orders/{order_id}/cancel")
async def qrl_cancel_order(order_id: str):
    usecase = CancelQrlOrder(_client())
    return await usecase.execute(order_id=order_id, client_order_id=None)


@router.get("/orders/{order_id}")
async def qrl_get_order(order_id: str):
    usecase = GetQrlOrder(_client())
    return await usecase.execute(order_id=order_id, client_order_id=None)


@router.get("/summary")
async def qrl_summary(
    interval: str = Query(default="1m"),
    kline_limit: int = Query(default=50, ge=1, le=500),
    depth_limit: int = Query(default=50, ge=5, le=1000),
    trades_limit: int = Query(default=50, ge=1, le=500),
):
    """Aggregate price, kline, depth, and balance for dashboard consumption."""
    price_uc = GetQrlPrice(_client())
    kline_uc = GetQrlKline(_client(), interval=interval, limit=kline_limit)
    depth_uc = GetQrlDepth(_client(), limit=depth_limit)
    balance_uc = GetBalanceUseCase()
    orders_uc = ListOrdersUseCase()
    trades_uc = ListTradesUseCase()
    market_trades_uc = GetMarketTradesUseCase()

    price_result, kline_result, depth_result, balance_result, orders, trades, market_trades = await asyncio.gather(
        price_uc.execute(),
        kline_uc.execute(),
        depth_uc.execute(),
        balance_uc.execute(),
        orders_uc.execute(symbol="QRLUSDT"),
        trades_uc.execute("QRLUSDT"),
        market_trades_uc.execute(),
    )

    normalized_klines = [
        {"timestamp": item[0], "open": item[1], "high": item[2], "low": item[3], "close": item[4], "volume": item[5]}
        for item in kline_result
    ]
    return {
        "price": price_result.to_dict(),
        "klines": normalized_klines,
        "depth": depth_result,
        "balance": balance_result,
        "orders": orders,
        "trades": trades,
        "market_trades": market_trades[:trades_limit],
    }
</file>

<file path="src/app/interfaces/http/pages/static/js/pages/dashboard.js">
(() => {
  const cfg = window.dashboardConfig || {};
  const ui = window.dashboardUI || {};
  if (!ui.setPrice || !ui.setText) return;

  const load = async (url) => {
    const resp = await fetch(url);
    let data = {};
    try {
      data = await resp.json();
    } catch (_err) {
      data = {};
    }
    return { ok: resp.ok, data };
  };

  const err = (id, detail, fallback) => ui.setText(id, detail || fallback);

  async function refresh() {
    try {
      const [price, kline, bal, depth, trades, orders] = await Promise.all([
        load(cfg.priceUrl),
        load(cfg.klineUrl),
        load(cfg.balanceUrl),
        load(cfg.depthUrl),
        load(cfg.tradesUrl),
        load(cfg.ordersUrl),
      ]);
      price.ok ? ui.setPrice(price.data) : err("price-error", price.data.detail, "價格取得失敗");
      kline.ok && ui.setKlines(kline.data);
      bal.ok ? ui.setBalances(bal.data) : err("balance-error", bal.data.detail, "餘額取得失敗");
      depth.ok ? ui.setDepth(depth.data) : err("depth-error", depth.data.detail, "Depth 取得失敗");
      trades.ok ? ui.setTrades(trades.data) : err("trades-error", trades.data.detail, "Trades 取得失敗");
      orders.ok ? ui.setOrders(orders.data) : err("orders-error", orders.data.detail, "Orders 取得失敗");
    } catch (ex) {
      ["price", "balance", "depth", "trades", "orders"].forEach((key) => err(`${key}-error`, null, "連線錯誤"));
      console.error(ex);
    }
  }

  const wireSideToggle = () => {
    document.querySelectorAll(".side-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".side-btn").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        const sideInput = document.querySelector('input[name="side"]');
        if (sideInput) sideInput.value = btn.dataset.side;
      });
    });
  };

  const wireOrderForm = () => {
    const form = document.getElementById("orderForm");
    const resultEl = document.getElementById("orderResult");
    if (!form || !resultEl) return;
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const payload = {
        symbol: "QRLUSDT",
        side: form.side.value,
        order_type: form.order_type.value,
        quantity: form.quantity.value,
        price: form.price.value || null,
        time_in_force: form.time_in_force.value,
      };
      resultEl.textContent = "送出中...";
      try {
        const resp = await fetch(cfg.orderUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const data = await resp.json().catch(() => ({}));
        resultEl.textContent = resp.ok
          ? `成功: orderId=${data.order_id || data.orderId || "N/A"}`
          : `失敗: ${data.detail || JSON.stringify(data)}`;
      } catch (ex) {
        resultEl.textContent = `錯誤: ${ex}`;
      }
    });
  };

  const cancelOrder = async (orderId, button) => {
    if (!orderId || !cfg.ordersUrl) return;
    const url = `${cfg.ordersUrl}/${encodeURIComponent(orderId)}/cancel`;
    const originalText = button.textContent;
    button.disabled = true;
    button.textContent = "取消中...";
    try {
      const resp = await fetch(url, { method: "POST" });
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok) {
        err("orders-error", data.detail, "取消失敗");
      } else {
        ui.setText("orders-error", "");
        refresh();
      }
    } catch (ex) {
      err("orders-error", String(ex), "取消失敗");
    } finally {
      button.disabled = false;
      button.textContent = originalText || "取消";
    }
  };

  const wireOrderActions = () => {
    const list = document.getElementById("orders-list");
    if (!list) return;
    list.addEventListener("click", (event) => {
      const button = event.target.closest(".order-cancel");
      if (!button) return;
      const orderId = button.dataset.orderId;
      cancelOrder(orderId, button);
    });
  };

  document.addEventListener("DOMContentLoaded", () => {
    wireSideToggle();
    wireOrderForm();
    wireOrderActions();
    refresh();
    setInterval(refresh, cfg.refreshMs || 10000);
  });
})();
</file>

<file path="src/app/interfaces/http/api/tasks_routes.py">
import asyncio
import logging

from fastapi import APIRouter, HTTPException
import httpx
from pydantic import ValidationError

from src.app.interfaces.http.schemas import AllocationResponse
from src.app.interfaces.tasks import entrypoints

router = APIRouter()
api_router = APIRouter()
logger = logging.getLogger(__name__)


async def _trigger_allocation() -> AllocationResponse:
    """Run the allocation task and normalize the response."""
    try:
        result = await entrypoints.run_allocation()
    except asyncio.TimeoutError:
        raise HTTPException(status_code=504, detail="Allocation task exceeded timeout")
    except (ValidationError, httpx.HTTPError) as exc:
        logger.exception("Allocation failed due to configuration or upstream API error")
        raise HTTPException(status_code=502, detail=str(exc))
    except Exception:
        logger.exception("Unexpected allocation failure")
        raise HTTPException(status_code=500, detail="Allocation task failed")
    return AllocationResponse.model_validate(result)


@router.api_route(
    "/allocation",
    methods=["POST", "GET"],
    response_model=AllocationResponse,
    tags=["tasks"],
    name="tasks_allocation_trigger",
)
async def trigger_allocation() -> AllocationResponse:
    """Endpoint for Cloud Scheduler to trigger an allocation run."""
    return await _trigger_allocation()


@api_router.api_route(
    "/allocation",
    methods=["POST", "GET"],
    response_model=AllocationResponse,
    tags=["tasks"],
    name="api_tasks_allocation_trigger",
)
async def trigger_allocation_api() -> AllocationResponse:
    """API-aligned alias to trigger allocation under the /api/tasks namespace."""
    return await _trigger_allocation()
</file>

<file path="tests/test_tasks_allocation_route.py">
import asyncio
from datetime import datetime, timezone
import httpx

import pytest
from fastapi.testclient import TestClient

from main import create_app
from src.app.application.system.use_cases.allocation import AllocationResult
from src.app.interfaces.tasks import entrypoints


@pytest.fixture(autouse=True)
def mock_allocation(monkeypatch):
    async def _mock_run_allocation() -> AllocationResult:
        return AllocationResult(
            request_id="mock-req",
            status="ok",
            executed_at=datetime(2026, 1, 1, tzinfo=timezone.utc),
            action="BUY",
            order_id="mock-order",
        )

    monkeypatch.setattr(entrypoints, "run_allocation", _mock_run_allocation)


def test_allocation_endpoint_allows_get_and_returns_payload():
    app = create_app()
    client = TestClient(app)

    resp = client.get("/tasks/allocation")

    assert resp.status_code == 200
    data = resp.json()
    assert data["status"] == "ok"
    assert data["action"] == "BUY"
    assert data["order_id"] == "mock-order"
    assert data["request_id"] == "mock-req"


def test_allocation_endpoint_available_under_api_prefix():
    app = create_app()
    client = TestClient(app)

    resp = client.get("/api/tasks/allocation")

    assert resp.status_code == 200
    data = resp.json()
    assert data["status"] == "ok"
    assert data["action"] == "BUY"
    assert data["order_id"] == "mock-order"
    assert data["request_id"] == "mock-req"


def test_allocation_endpoint_returns_504_on_timeout(monkeypatch):
    app = create_app()
    client = TestClient(app)

    async def _timeout_allocation() -> AllocationResult:
        raise asyncio.TimeoutError()

    monkeypatch.setattr(entrypoints, "run_allocation", _timeout_allocation)

    resp = client.get("/tasks/allocation")

    assert resp.status_code == 504
    assert resp.json()["detail"] == "Allocation task exceeded timeout"


def test_allocation_endpoint_returns_502_on_upstream_error(monkeypatch):
    app = create_app()
    client = TestClient(app)

    async def _upstream_failure():
        raise httpx.HTTPError("mexc unreachable")

    monkeypatch.setattr(entrypoints, "run_allocation", _upstream_failure)

    resp = client.get("/tasks/allocation")

    assert resp.status_code == 502
    assert "mexc unreachable" in resp.json()["detail"]
</file>

<file path="src/app/application/system/use_cases/allocation.py">
"""System use case to expose an allocation trigger for schedulers."""

from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal
from typing import Callable
from uuid import uuid4

from src.app.application.exchange.mexc_service import MexcService, PlaceOrderRequest, build_mexc_service
from src.app.domain.entities.account import Account
from src.app.domain.services.balance_comparison_rule import BalanceComparisonRule
from src.app.domain.services.depth_calculator import DepthCalculator
from src.app.domain.services.slippage_analyzer import SlippageAnalyzer
from src.app.domain.services.valuation_service import ValuationService
from src.app.domain.value_objects.balance_comparison_result import BalanceComparisonResult
from src.app.domain.value_objects.normalized_balances import NormalizedBalances
from src.app.domain.value_objects.order_command import OrderCommand
from src.app.domain.value_objects.order_book import OrderBook
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.slippage import SlippageAssessment
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.infrastructure.exchange.mexc.settings import MexcSettings


class AllocationConfig:
    """Default configuration values for the allocation flow."""

    SYMBOL = Symbol("QRLUSDT")
    TIME_IN_FORCE = TimeInForce("GTC")
    LIMIT_PRICE = Decimal("1")
    TARGET_QUANTITY = Quantity(Decimal("1"))
    DEPTH_LIMIT = 20
    SLIPPAGE_THRESHOLD_PCT = Decimal("5")
    PRICE_BUFFER_PCT = Decimal("0.001")  # 0.1%


@dataclass(frozen=True)
class AllocationResult:
    """Outcome returned when an allocation task is triggered."""

    request_id: str
    status: str
    executed_at: datetime
    action: str
    order_id: str | None
    reason: str | None = None
    slippage_pct: Decimal | None = None
    expected_fill: Decimal | None = None


class AllocationUseCase:
    """Check QRL:USDT balance ratio and place a limit order when slippage is acceptable."""

    def __init__(
        self,
        service_factory: Callable[[], MexcService] | None = None,
        *,
        depth_limit: int = AllocationConfig.DEPTH_LIMIT,
        slippage_threshold_pct: Decimal = AllocationConfig.SLIPPAGE_THRESHOLD_PCT,
        target_quantity: Quantity | None = None,
        limit_price: Decimal = AllocationConfig.LIMIT_PRICE,
    ):
        self._service_factory = service_factory or (lambda: build_mexc_service(MexcSettings()))
        self._comparison_rule = BalanceComparisonRule()
        self._depth_calculator = DepthCalculator()
        self._slippage_analyzer = SlippageAnalyzer(slippage_threshold_pct)
        self._valuation_service = ValuationService()
        self._depth_limit = depth_limit
        self._target_quantity = target_quantity or AllocationConfig.TARGET_QUANTITY
        self._limit_price = Decimal(limit_price)

    async def execute(self) -> AllocationResult:
        """Compare balances, evaluate depth/slippage, and submit a balancing order."""
        request_id = str(uuid4())
        executed_at = datetime.now(timezone.utc)
        async with self._service_factory() as svc:
            account = await svc.get_account()
            try:
                quote = await svc.get_price(AllocationConfig.SYMBOL)
                mid_price = (quote.bid + quote.ask) / Decimal("2")
            except Exception:
                return _result_from_price_error(request_id, executed_at)

            balances = _normalize_balances(account, mid_price, self._valuation_service)
            comparison = self._comparison_rule.evaluate(balances)
            if comparison.action == "skip" or comparison.preferred_side is None:
                return _result_from_skip(request_id, executed_at, comparison)

            order_book = await svc.get_depth(AllocationConfig.SYMBOL, limit=self._depth_limit)
            filled, weighted_price = self._depth_calculator.compute(
                order_book, comparison.preferred_side, self._target_quantity
            )
            best_bid = _best_bid(order_book)
            best_ask = _best_ask(order_book)
            top_price = _best_price(order_book, comparison.preferred_side)
            if top_price <= 0 or best_bid <= 0 or best_ask <= 0:
                return _result_from_slippage(
                    request_id, executed_at, SlippageAssessment(Decimal("0"), Decimal("0"), False, "No executable depth")
                )
            slippage = self._slippage_analyzer.assess(
                side=comparison.preferred_side,
                desired_price=top_price,
                target_quantity=self._target_quantity,
                fill_quantity=filled,
                weighted_price=weighted_price,
            )
            if not slippage.is_acceptable:
                return _result_from_slippage(request_id, executed_at, slippage)

            limit_price = _compute_limit_price(
                side=comparison.preferred_side,
                best_bid=best_bid,
                best_ask=best_ask,
                buffer_pct=AllocationConfig.PRICE_BUFFER_PCT,
            )
            if limit_price is None:
                return _result_from_slippage(
                    request_id,
                    executed_at,
                    SlippageAssessment(Decimal("0"), Decimal("0"), False, "Cannot place maker limit"),
                )
            command = _build_order_command(
                side=comparison.preferred_side, quantity=self._target_quantity, limit_price=limit_price
            )
            order = await svc.place_order(
                PlaceOrderRequest(
                    symbol=command.symbol,
                    side=command.side,
                    order_type=OrderType("LIMIT"),
                    quantity=command.quantity,
                    price=command.price,
                    time_in_force=command.time_in_force,
                )
            )

        return _result_from_success(
            request_id=request_id,
            executed_at=executed_at,
            slippage=slippage,
            side=command.side,
            order_id=order.order_id.value,
        )


def _normalize_balances(account: Account, mid_price: Decimal, valuation: ValuationService) -> NormalizedBalances:
    """Return normalized balances using total (free + locked) holdings."""
    qrl_total = Decimal("0")
    usdt_total = Decimal("0")
    for bal in account.balances:
        asset = bal.asset.upper()
        if asset == "QRL":
            qrl_total += bal.free + bal.locked
        if asset == "USDT":
            usdt_total += bal.free + bal.locked
    qrl_value = valuation.value(qrl_total, mid_price)
    return NormalizedBalances(qrl_free=qrl_value, usdt_free=usdt_total)


def _build_order_command(*, side: Side, quantity: Quantity, limit_price: Decimal) -> OrderCommand:
    return OrderCommand(
        symbol=AllocationConfig.SYMBOL,
        side=side,
        quantity=quantity,
        price=Price.from_single(limit_price),
        time_in_force=AllocationConfig.TIME_IN_FORCE,
    )


def _best_price(book: OrderBook, side: Side) -> Decimal:
    prices = [level.price for level in (book.asks if side.value == "BUY" else book.bids)]
    if not prices:
        return Decimal("0")
    return min(prices) if side.value == "BUY" else max(prices)


def _best_bid(book: OrderBook) -> Decimal:
    bids = [level.price for level in book.bids]
    return max(bids) if bids else Decimal("0")


def _best_ask(book: OrderBook) -> Decimal:
    asks = [level.price for level in book.asks]
    return min(asks) if asks else Decimal("0")


def _compute_limit_price(*, side: Side, best_bid: Decimal, best_ask: Decimal, buffer_pct: Decimal) -> Decimal | None:
    """Return a maker-style limit price that does not cross the spread."""
    if best_bid <= 0 or best_ask <= 0 or best_bid >= best_ask:
        return None
    if side.value == "BUY":
        candidate = best_bid * (Decimal("1") - buffer_pct)
        if candidate >= best_ask:
            return None
        return candidate
    candidate = best_ask * (Decimal("1") + buffer_pct)
    if candidate <= best_bid:
        return None
    return candidate


def _result_from_skip(
    request_id: str, executed_at: datetime, comparison: BalanceComparisonResult
) -> AllocationResult:
    return AllocationResult(
        request_id=request_id,
        status="skipped",
        executed_at=executed_at,
        action="SKIP",
        order_id=None,
        reason=comparison.reason,
        slippage_pct=None,
        expected_fill=None,
    )


def _result_from_slippage(
    request_id: str, executed_at: datetime, slippage: SlippageAssessment
) -> AllocationResult:
    return AllocationResult(
        request_id=request_id,
        status="rejected",
        executed_at=executed_at,
        action="REJECTED",
        order_id=None,
        reason=slippage.reason,
        slippage_pct=slippage.slippage_pct,
        expected_fill=slippage.expected_fill,
    )


def _result_from_price_error(request_id: str, executed_at: datetime) -> AllocationResult:
    return AllocationResult(
        request_id=request_id,
        status="rejected",
        executed_at=executed_at,
        action="REJECTED",
        order_id=None,
        reason="Price unavailable",
        slippage_pct=None,
        expected_fill=None,
    )


def _result_from_success(
    *,
    request_id: str,
    executed_at: datetime,
    slippage: SlippageAssessment,
    side: Side,
    order_id: str,
) -> AllocationResult:
    return AllocationResult(
        request_id=request_id,
        status="ok",
        executed_at=executed_at,
        action=side.value,
        order_id=order_id,
        reason=None,
        slippage_pct=slippage.slippage_pct,
        expected_fill=slippage.expected_fill,
    )
</file>

<file path="src/app/interfaces/http/pages/static/css/dashboard.css">
body {
  font-family: Arial, sans-serif;
  margin: 24px;
}

.skip-link {
  position: absolute;
  left: -999px;
  top: auto;
  width: 1px;
  height: 1px;
  overflow: hidden;
}

.skip-link:focus {
  left: 12px;
  top: 12px;
  width: auto;
  height: auto;
  padding: 8px 12px;
  background: #fff;
  border: 2px solid #2196f3;
  border-radius: 6px;
  z-index: 1000;
}

.dashboard-grid {
  display: grid;
  grid-template-columns: 360px 1fr 360px;
  grid-template-areas:
    "price kline orderform"
    "depth kline orderform"
    "trades kline balances"
    "trades kline orders";
  gap: 12px;
  align-items: start;
}

@media (max-width: 1100px) {
  .dashboard-grid {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    grid-template-areas:
      "price"
      "kline"
      "orderform"
      "depth"
      "trades"
      "balances"
      "orders";
  }
}

.card {
  border: 1px solid #e0e0e0;
  padding: 12px;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
  background: #fff;
}

.price-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
}

.label {
  color: #666;
}

.value {
  font-weight: bold;
}

canvas {
  max-width: 100%;
}

.depth-list,
.trades-list,
.orders-list {
  list-style: none;
  padding: 0;
  margin: 0;
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #eee;
  border-radius: 6px;
}

.depth-list li,
.trades-list li,
.orders-list li {
  display: grid;
  grid-template-columns: repeat(4, minmax(0, 1fr));
  padding: 6px 8px;
  border-bottom: 1px solid #f2f2f2;
  font-size: 0.92rem;
}

.depth-list li:last-child,
.trades-list li:last-child,
.orders-list li:last-child {
  border-bottom: none;
}

.depth-list .price,
.trades-list .price,
.orders-list .price {
  font-weight: 600;
}

.trades-list .side.buy,
.orders-list .side.buy {
  color: #2e7d32;
  font-weight: 700;
}

.trades-list .side.sell,
.orders-list .side.sell {
  color: #c62828;
  font-weight: 700;
}

.depth-col {
  flex: 1;
}

.flex-row {
  display: flex;
  gap: 12px;
}

.vertical-stack {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.price-card {
  grid-area: price;
  max-width: 360px;
  width: 100%;
  justify-self: start;
}

.kline-card {
  grid-area: kline;
}

.depth-card {
  grid-area: depth;
  max-width: 360px;
}

.depth-card .depth-list {
  max-height: 320px;
}

.depth-list li {
  grid-template-columns: repeat(2, minmax(0, 1fr));
}

.trades-card {
  grid-area: trades;
  max-width: 360px;
  width: 100%;
  justify-self: start;
}

.trades-card .trades-list {
  max-height: 150px;
}

.trades-list li {
  grid-template-columns: repeat(4, minmax(0, 1fr));
}

.orders-card {
  grid-area: orders;
  max-width: 360px;
  width: 100%;
  justify-self: start;
}

.orders-card .orders-list {
  max-height: 240px;
}

.balance-card {
  grid-area: balances;
  max-width: 360px;
  width: 100%;
  justify-self: start;
}

.order-card {
  grid-area: orderform;
  max-width: 340px;
}

.depth-list li {
  grid-template-columns: repeat(2, minmax(0, 1fr));
  padding: 4px 6px;
  font-size: 0.9rem;
}

.trades-list li {
  grid-template-columns: repeat(4, minmax(0, 1fr));
  padding: 4px 6px;
  font-size: 0.9rem;
}

.orders-list li {
  /* Columns: ID | Side | Price | Quantity | Amount | Status | Action */
  grid-template-columns: 1.6fr 0.8fr 1fr 1fr 1fr 1fr 0.9fr;
  padding: 4px 6px;
  font-size: 0.9rem;
}

.orders-list .orders-header {
  position: sticky;
  top: 0;
  background: #fafafa;
  font-weight: 700;
  z-index: 1;
}

.orders-list .status-label {
  color: #555;
}

.orders-list .order-cancel {
  padding: 6px 10px;
  background: #2196f3;
  color: #fff;
  border: 1px solid #2196f3;
  border-radius: 4px;
}

.depth-list,
.trades-list,
.orders-list {
  max-height: 240px;
}

form .form-row {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-bottom: 10px;
}

form label {
  width: 120px;
  color: #444;
}

form input,
form select {
  flex: 1;
  padding: 6px 8px;
}

button {
  padding: 8px 14px;
  background: #2196f3;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.side-toggle {
  display: inline-flex;
  gap: 8px;
}

.side-btn {
  background: #e0e0e0;
  color: #333;
  border: 1px solid #d0d0d0;
}

.side-btn.active {
  background: #2196f3;
  color: #fff;
  border-color: #2196f3;
}

.order-result {
  margin-top: 8px;
  color: #333;
  font-size: 0.95rem;
}
</file>

<file path="tests/test_allocation_use_case.py">
from datetime import datetime, timezone
from decimal import Decimal
import pytest

from src.app.application.exchange.mexc_service import PlaceOrderRequest
from src.app.application.system.use_cases.allocation import AllocationUseCase
from src.app.domain.entities.account import Account
from src.app.domain.entities.order import Order
from src.app.domain.value_objects.balance import Balance
from src.app.domain.value_objects.order_book import DepthLevel, OrderBook
from src.app.domain.value_objects.order_id import OrderId
from src.app.domain.value_objects.order_status import OrderStatus
from src.app.domain.value_objects.order_type import OrderType
from src.app.domain.value_objects.price import Price
from src.app.domain.value_objects.quantity import Quantity
from src.app.domain.value_objects.side import Side
from src.app.domain.value_objects.symbol import Symbol
from src.app.domain.value_objects.time_in_force import TimeInForce
from src.app.domain.value_objects.timestamp import Timestamp


class FakeService:
    def __init__(
        self,
        qrl_free: str,
        usdt_free: str,
        *,
        qrl_locked: str = "0",
        usdt_locked: str = "0",
        bids: list[DepthLevel] | None = None,
        asks: list[DepthLevel] | None = None,
        price_bid: str = "1",
        price_ask: str = "1",
    ):
        self._qrl_free = Decimal(qrl_free)
        self._usdt_free = Decimal(usdt_free)
        self._qrl_locked = Decimal(qrl_locked)
        self._usdt_locked = Decimal(usdt_locked)
        self._book = OrderBook(bids=bids or [], asks=asks or [])
        self._price = Price(
            bid=Decimal(price_bid),
            ask=Decimal(price_ask),
            last=Decimal(price_bid),
            timestamp=Timestamp(datetime.now(timezone.utc)),
        )
        self.last_order_request: PlaceOrderRequest | None = None

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc, tb):
        return None

    async def get_account(self) -> Account:
        return Account(
            can_trade=True,
            update_time=Timestamp(datetime.now(timezone.utc)),
            balances=[
                Balance(asset="QRL", free=self._qrl_free, locked=self._qrl_locked),
                Balance(asset="USDT", free=self._usdt_free, locked=self._usdt_locked),
            ],
        )

    async def get_depth(self, symbol: Symbol, limit: int = 50) -> OrderBook:
        return self._book

    async def get_price(self, symbol: Symbol) -> Price:
        return self._price

    async def place_order(self, request: PlaceOrderRequest) -> Order:
        self.last_order_request = request
        return Order(
            order_id=OrderId("test-order"),
            symbol=request.symbol,
            side=request.side,
            order_type=request.order_type,
            status=OrderStatus("NEW"),
            price=request.price.last if request.price else Decimal("0"),
            quantity=request.quantity,
            created_at=Timestamp(datetime.now(timezone.utc)),
            time_in_force=request.time_in_force,
        )


@pytest.mark.asyncio
async def test_allocation_skips_when_balances_even():
    service = FakeService(qrl_free="1", usdt_free="1")
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "skipped"
    assert result.action == "SKIP"
    assert result.order_id is None
    assert service.last_order_request is None


@pytest.mark.asyncio
async def test_allocation_uses_locked_balances_for_ratio():
    service = FakeService(qrl_free="0.2", qrl_locked="0.8", usdt_free="1")
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "skipped"
    assert result.action == "SKIP"
    assert service.last_order_request is None


@pytest.mark.asyncio
async def test_allocation_rejects_on_slippage():
    service = FakeService(
        qrl_free="0.1",
        usdt_free="5",
        asks=[
            DepthLevel(price=Decimal("1"), quantity=Decimal("0.1")),
            DepthLevel(price=Decimal("2.5"), quantity=Decimal("1")),
        ],
    )
    usecase = AllocationUseCase(service_factory=lambda: service, slippage_threshold_pct=Decimal("5"))

    result = await usecase.execute()

    assert result.status == "rejected"
    assert result.action == "REJECTED"
    assert result.order_id is None
    assert result.reason is not None
    assert service.last_order_request is None


@pytest.mark.asyncio
async def test_allocation_places_order_when_slippage_ok():
    service = FakeService(
        qrl_free="2",
        usdt_free="1",
        bids=[DepthLevel(price=Decimal("1.01"), quantity=Decimal("1.5"))],
        asks=[DepthLevel(price=Decimal("1.02"), quantity=Decimal("1.0"))],
    )
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "ok"
    assert result.action == "SELL"
    assert result.order_id == "test-order"
    assert result.expected_fill == Decimal("1")
    assert service.last_order_request is not None
    assert service.last_order_request.side.value == "SELL"
    assert service.last_order_request.price is not None
    assert service.last_order_request.price.last == Decimal("1.02102")
    assert service.last_order_request.quantity.value == Decimal("1")
    assert service.last_order_request.time_in_force == TimeInForce("GTC")


@pytest.mark.asyncio
async def test_allocation_skips_when_value_balanced_but_qty_not():
    # QRL qty > USDT qty, but price=0.5 makes values equal (1 USDT vs 1 USDT)
    service = FakeService(qrl_free="2", usdt_free="1", price_bid="0.5", price_ask="0.5")
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "skipped"
    assert service.last_order_request is None


@pytest.mark.asyncio
async def test_allocation_rejects_when_price_unavailable(monkeypatch):
    service = FakeService(qrl_free="0.5", usdt_free="1")

    async def raise_price(symbol: Symbol):
        raise RuntimeError("price failed")

    service.get_price = raise_price  # type: ignore
    usecase = AllocationUseCase(service_factory=lambda: service)

    result = await usecase.execute()

    assert result.status == "rejected"
    assert result.reason == "Price unavailable"
    assert service.last_order_request is None
</file>

<file path="src/app/interfaces/http/pages/templates/dashboard/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>QRL/USDT Dashboard</title>
<link rel="stylesheet" href="/static/css/dashboard.css" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<a href="#maincontent" class="skip-link">Skip to content</a>
<main id="maincontent" class="dashboard-grid">
<div class="card price-card">
<div class="price-row"><span class="label">買價</span><span id="bid" class="value">--</span></div>
<div class="price-row"><span class="label">賣價</span><span id="ask" class="value">--</span></div>
<div class="price-row"><span class="label">最新價</span><span id="last" class="value">--</span></div>
<div class="price-row"><span class="label">更新時間</span><span id="timestamp" class="value">--</span></div>
<div class="price-row error" id="price-error" aria-live="polite"></div>
</div>
<div class="card kline-card">
<canvas id="klineChart" height="240"></canvas>
</div>
<div class="card depth-card">
<h2>深度</h2>
<div class="vertical-stack">
<div class="label">賣盤</div>
<ul id="depth-asks" class="depth-list"></ul>
<div class="label">買盤</div>
<ul id="depth-bids" class="depth-list"></ul>
</div>
<div class="price-row error" id="depth-error" aria-live="polite"></div>
</div>
<div class="card trades-card">
<h2>近期成交</h2>
<ul id="trades-list" class="trades-list"></ul>
<div class="price-row error" id="trades-error" aria-live="polite"></div>
</div>
<div class="card orders-card">
<h2>我的訂單</h2>
<ul id="orders-list" class="orders-list"></ul>
<div class="price-row error" id="orders-error" aria-live="polite"></div>
</div>
<div class="card balance-card">
<h2>餘額</h2>
<div class="price-row"><span class="label">QRL 可用</span><span id="bal-qrl-free" class="value">--</span></div>
<div class="price-row"><span class="label">QRL 凍結</span><span id="bal-qrl-locked" class="value">--</span></div>
<div class="price-row"><span class="label">USDT 可用</span><span id="bal-usdt-free" class="value">--</span></div>
<div class="price-row"><span class="label">USDT 凍結</span><span id="bal-usdt-locked" class="value">--</span></div>
<div class="price-row error" id="balance-error" aria-live="polite"></div>
</div>
<div class="card order-card">
<h2>下單</h2>
<form id="orderForm">
<div class="form-row">
<label>方向</label>
<div class="side-toggle" role="group" aria-label="Side">
<button type="button" data-side="BUY" class="side-btn active">買入</button>
<button type="button" data-side="SELL" class="side-btn">賣出</button>
</div>
<input type="hidden" name="side" value="BUY" />
</div>
<div class="form-row">
<label>類型</label>
<select name="order_type">
<option value="LIMIT">LIMIT</option>
<option value="MARKET">MARKET</option>
</select>
</div>
<div class="form-row">
<label>數量</label>
<input name="quantity" type="number" step="0.0001" required />
</div>
<div class="form-row">
<label>價格</label>
<input name="price" type="number" step="0.0001" />
</div>
<div class="form-row">
<label>有效期限</label>
<select name="time_in_force">
<option value="GTC">GTC</option>
<option value="IOC">IOC</option>
<option value="FOK">FOK</option>
</select>
</div>
<button type="submit">送出</button>
<div id="orderResult" class="order-result"></div>
</form>
</div>
</main>
<script id="dashboard-config" type="application/json">{{ dashboard_config | tojson }}</script>
<script src="/static/js/pages/dashboard-config.js" defer></script>
<script src="/static/js/domain/order.js" defer></script>
<script src="/static/js/pages/dashboard-renderers.js" defer></script>
<script src="/static/js/pages/dashboard.js" defer></script>
</body>
</html>
</file>

</files>
